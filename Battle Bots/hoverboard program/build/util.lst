ARM GAS  /tmp/cc14G55i.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.BLDC_Init,"ax",%progbits
  16              		.align	1
  17              		.global	BLDC_Init
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	BLDC_Init:
  25              	.LFB66:
  26              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-firmware-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <stdlib.h> // for abs()
  23:Src/util.c    **** #include <string.h>
  24:Src/util.c    **** #include "stm32f1xx_hal.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "setup.h"
  27:Src/util.c    **** #include "config.h"
  28:Src/util.c    **** #include "eeprom.h"
  29:Src/util.c    **** #include "util.h"
  30:Src/util.c    **** #include "BLDC_controller.h"
  31:Src/util.c    **** #include "rtwtypes.h"
  32:Src/util.c    **** #include "comms.h"
ARM GAS  /tmp/cc14G55i.s 			page 2


  33:Src/util.c    **** 
  34:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
  35:Src/util.c    **** #include "hd44780.h"
  36:Src/util.c    **** #endif
  37:Src/util.c    **** 
  38:Src/util.c    **** /* =========================== Variable Definitions =========================== */
  39:Src/util.c    **** 
  40:Src/util.c    **** //------------------------------------------------------------------------
  41:Src/util.c    **** // Global variables set externally
  42:Src/util.c    **** //------------------------------------------------------------------------
  43:Src/util.c    **** extern volatile adc_buf_t adc_buffer;
  44:Src/util.c    **** extern I2C_HandleTypeDef hi2c2;
  45:Src/util.c    **** extern UART_HandleTypeDef huart2;
  46:Src/util.c    **** extern UART_HandleTypeDef huart3;
  47:Src/util.c    **** 
  48:Src/util.c    **** extern int16_t batVoltage;
  49:Src/util.c    **** extern uint8_t backwardDrive;
  50:Src/util.c    **** extern uint8_t buzzerCount;             // global variable for the buzzer counts. can be 1, 2, 3, 4
  51:Src/util.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  52:Src/util.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  53:Src/util.c    **** 
  54:Src/util.c    **** extern uint8_t enable;                  // global variable for motor enable
  55:Src/util.c    **** 
  56:Src/util.c    **** extern uint8_t nunchuk_data[6];
  57:Src/util.c    **** extern volatile uint32_t timeoutCntGen; // global counter for general timeout counter
  58:Src/util.c    **** extern volatile uint8_t  timeoutFlgGen; // global flag for general timeout counter
  59:Src/util.c    **** extern volatile uint32_t main_loop_counter;
  60:Src/util.c    **** 
  61:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  62:Src/util.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  63:Src/util.c    **** #endif
  64:Src/util.c    **** 
  65:Src/util.c    **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
  66:Src/util.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  67:Src/util.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  68:Src/util.c    **** #endif
  69:Src/util.c    **** 
  70:Src/util.c    **** 
  71:Src/util.c    **** //------------------------------------------------------------------------
  72:Src/util.c    **** // Global variables set here in util.c
  73:Src/util.c    **** //------------------------------------------------------------------------
  74:Src/util.c    **** // Matlab defines - from auto-code generation
  75:Src/util.c    **** //---------------
  76:Src/util.c    **** RT_MODEL rtM_Left_;                     /* Real-time model */
  77:Src/util.c    **** RT_MODEL rtM_Right_;                    /* Real-time model */
  78:Src/util.c    **** RT_MODEL *const rtM_Left  = &rtM_Left_;
  79:Src/util.c    **** RT_MODEL *const rtM_Right = &rtM_Right_;
  80:Src/util.c    **** 
  81:Src/util.c    **** extern P rtP_Left;                      /* Block parameters (auto storage) */
  82:Src/util.c    **** DW       rtDW_Left;                     /* Observable states */
  83:Src/util.c    **** ExtU     rtU_Left;                      /* External inputs */
  84:Src/util.c    **** ExtY     rtY_Left;                      /* External outputs */
  85:Src/util.c    **** 
  86:Src/util.c    **** P        rtP_Right;                     /* Block parameters (auto storage) */
  87:Src/util.c    **** DW       rtDW_Right;                    /* Observable states */
  88:Src/util.c    **** ExtU     rtU_Right;                     /* External inputs */
  89:Src/util.c    **** ExtY     rtY_Right;                     /* External outputs */
ARM GAS  /tmp/cc14G55i.s 			page 3


  90:Src/util.c    **** //---------------
  91:Src/util.c    **** 
  92:Src/util.c    **** uint8_t  inIdx      = 0;
  93:Src/util.c    **** uint8_t  inIdx_prev = 0;
  94:Src/util.c    **** #if defined(PRI_INPUT1) && defined(PRI_INPUT2) && defined(AUX_INPUT1) && defined(AUX_INPUT2)
  95:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1}, {0, 0, 0, AUX_INPUT1} };
  96:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2}, {0, 0, 0, AUX_INPUT2} };
  97:Src/util.c    **** #else
  98:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1} };
  99:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2} };
 100:Src/util.c    **** #endif
 101:Src/util.c    **** 
 102:Src/util.c    **** int16_t  speedAvg;                      // average measured speed
 103:Src/util.c    **** int16_t  speedAvgAbs;                   // average measured speed in absolute
 104:Src/util.c    **** uint8_t  timeoutFlgADC    = 0;          // Timeout Flag for ADC Protection:    0 = OK, 1 = Problem 
 105:Src/util.c    **** uint8_t  timeoutFlgSerial = 0;          // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
 106:Src/util.c    **** 
 107:Src/util.c    **** uint8_t  ctrlModReqRaw = CTRL_MOD_REQ;
 108:Src/util.c    **** uint8_t  ctrlModReq    = CTRL_MOD_REQ;  // Final control mode request 
 109:Src/util.c    **** 
 110:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 111:Src/util.c    **** LCD_PCF8574_HandleTypeDef lcd;
 112:Src/util.c    **** #endif
 113:Src/util.c    **** 
 114:Src/util.c    **** #ifdef VARIANT_TRANSPOTTER
 115:Src/util.c    **** float    setDistance;
 116:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1337};       // Virtual address defined by the user: 0xFFFF va
 117:Src/util.c    **** static   uint16_t saveValue       = 0;
 118:Src/util.c    **** static   uint8_t  saveValue_valid = 0;
 119:Src/util.c    **** #elif !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 120:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
 121:Src/util.c    ****                                      1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018};
 122:Src/util.c    **** #else
 123:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000};       // Dummy virtual address to avoid warnings
 124:Src/util.c    **** #endif
 125:Src/util.c    **** 
 126:Src/util.c    **** 
 127:Src/util.c    **** //------------------------------------------------------------------------
 128:Src/util.c    **** // Local variables
 129:Src/util.c    **** //------------------------------------------------------------------------
 130:Src/util.c    **** static int16_t INPUT_MAX;             // [-] Input target maximum limitation
 131:Src/util.c    **** static int16_t INPUT_MIN;             // [-] Input target minimum limitation
 132:Src/util.c    **** 
 133:Src/util.c    **** 
 134:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 135:Src/util.c    ****   static uint8_t  cur_spd_valid  = 0;
 136:Src/util.c    ****   static uint8_t  inp_cal_valid  = 0;
 137:Src/util.c    **** #endif
 138:Src/util.c    **** 
 139:Src/util.c    **** #if defined(CONTROL_ADC)
 140:Src/util.c    **** static uint16_t timeoutCntADC = ADC_PROTECT_TIMEOUT;  // Timeout counter for ADC Protection
 141:Src/util.c    **** #endif
 142:Src/util.c    **** 
 143:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 144:Src/util.c    **** static uint8_t  rx_buffer_L[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 145:Src/util.c    **** static uint32_t rx_buffer_L_len = ARRAY_LEN(rx_buffer_L);
 146:Src/util.c    **** #endif
ARM GAS  /tmp/cc14G55i.s 			page 4


 147:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 148:Src/util.c    **** static uint16_t timeoutCntSerial_L = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 149:Src/util.c    **** static uint8_t  timeoutFlgSerial_L = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 150:Src/util.c    **** #endif
 151:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
 152:Src/util.c    **** SerialSideboard Sideboard_L;
 153:Src/util.c    **** SerialSideboard Sideboard_L_raw;
 154:Src/util.c    **** static uint32_t Sideboard_L_len = sizeof(Sideboard_L);
 155:Src/util.c    **** #endif
 156:Src/util.c    **** 
 157:Src/util.c    **** #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 158:Src/util.c    **** static uint8_t  rx_buffer_R[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 159:Src/util.c    **** static uint32_t rx_buffer_R_len = ARRAY_LEN(rx_buffer_R);
 160:Src/util.c    **** #endif
 161:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 162:Src/util.c    **** static uint16_t timeoutCntSerial_R = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 163:Src/util.c    **** static uint8_t  timeoutFlgSerial_R = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 164:Src/util.c    **** #endif
 165:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
 166:Src/util.c    **** SerialSideboard Sideboard_R;
 167:Src/util.c    **** SerialSideboard Sideboard_R_raw;
 168:Src/util.c    **** static uint32_t Sideboard_R_len = sizeof(Sideboard_R);
 169:Src/util.c    **** #endif
 170:Src/util.c    **** 
 171:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2)
 172:Src/util.c    **** static SerialCommand commandL;
 173:Src/util.c    **** static SerialCommand commandL_raw;
 174:Src/util.c    **** static uint32_t commandL_len = sizeof(commandL);
 175:Src/util.c    ****   #ifdef CONTROL_IBUS
 176:Src/util.c    ****   static uint16_t ibusL_captured_value[IBUS_NUM_CHANNELS];
 177:Src/util.c    ****   #endif
 178:Src/util.c    **** #endif
 179:Src/util.c    **** 
 180:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3)
 181:Src/util.c    **** static SerialCommand commandR;
 182:Src/util.c    **** static SerialCommand commandR_raw;
 183:Src/util.c    **** static uint32_t commandR_len = sizeof(commandR);
 184:Src/util.c    ****   #ifdef CONTROL_IBUS
 185:Src/util.c    ****   static uint16_t ibusR_captured_value[IBUS_NUM_CHANNELS];
 186:Src/util.c    ****   #endif
 187:Src/util.c    **** #endif
 188:Src/util.c    **** 
 189:Src/util.c    **** #if defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 190:Src/util.c    **** static uint8_t button1;                 // Blue
 191:Src/util.c    **** static uint8_t button2;                 // Green
 192:Src/util.c    **** #endif
 193:Src/util.c    **** 
 194:Src/util.c    **** #ifdef VARIANT_HOVERCAR
 195:Src/util.c    **** static uint8_t brakePressed;
 196:Src/util.c    **** #endif
 197:Src/util.c    **** 
 198:Src/util.c    **** #if defined(CRUISE_CONTROL_SUPPORT) || (defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTR
 199:Src/util.c    **** static uint8_t cruiseCtrlAcv = 0;
 200:Src/util.c    **** static uint8_t standstillAcv = 0;
 201:Src/util.c    **** #endif
 202:Src/util.c    **** 
 203:Src/util.c    **** /* =========================== Retargeting printf =========================== */
ARM GAS  /tmp/cc14G55i.s 			page 5


 204:Src/util.c    **** /* retarget the C library printf function to the USART */
 205:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 206:Src/util.c    ****   #ifdef __GNUC__
 207:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 208:Src/util.c    ****   #else
 209:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 210:Src/util.c    ****   #endif
 211:Src/util.c    ****   PUTCHAR_PROTOTYPE {
 212:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2)
 213:Src/util.c    ****       HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 1000);
 214:Src/util.c    ****     #elif defined(DEBUG_SERIAL_USART3)
 215:Src/util.c    ****       HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 1000);
 216:Src/util.c    ****     #endif
 217:Src/util.c    ****     return ch;
 218:Src/util.c    ****   }
 219:Src/util.c    ****   
 220:Src/util.c    ****   #ifdef __GNUC__
 221:Src/util.c    ****     int _write(int file, char *data, int len) {
 222:Src/util.c    ****       int i;
 223:Src/util.c    ****       for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 224:Src/util.c    ****       return len;
 225:Src/util.c    ****     }
 226:Src/util.c    ****   #endif
 227:Src/util.c    **** #endif
 228:Src/util.c    **** 
 229:Src/util.c    ****  
 230:Src/util.c    **** /* =========================== Initialization Functions =========================== */
 231:Src/util.c    **** 
 232:Src/util.c    **** void BLDC_Init(void) {
  27              		.loc 1 232 22 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
 233:Src/util.c    ****   /* Set BLDC controller parameters */ 
 234:Src/util.c    ****   rtP_Left.b_angleMeasEna       = 0;            // Motor angle input: 0 = estimated angle, 1 = meas
  38              		.loc 1 234 3 view .LVU1
  39              		.loc 1 234 33 is_stmt 0 view .LVU2
  40 0002 204C     		ldr	r4, .L3
  41 0004 0023     		movs	r3, #0
  42 0006 84F8FB30 		strb	r3, [r4, #251]
 235:Src/util.c    ****   rtP_Left.z_selPhaCurMeasABC   = 0;            // Left motor measured current phases {Green, Blue}
  43              		.loc 1 235 3 is_stmt 1 view .LVU3
  44              		.loc 1 235 33 is_stmt 0 view .LVU4
  45 000a 84F8FA30 		strb	r3, [r4, #250]
 236:Src/util.c    ****   rtP_Left.z_ctrlTypSel         = CTRL_TYP_SEL;
  46              		.loc 1 236 3 is_stmt 1 view .LVU5
  47              		.loc 1 236 33 is_stmt 0 view .LVU6
  48 000e 0222     		movs	r2, #2
  49 0010 84F8F920 		strb	r2, [r4, #249]
 237:Src/util.c    ****   rtP_Left.b_diagEna            = DIAG_ENA;
ARM GAS  /tmp/cc14G55i.s 			page 6


  50              		.loc 1 237 3 is_stmt 1 view .LVU7
  51              		.loc 1 237 33 is_stmt 0 view .LVU8
  52 0014 0126     		movs	r6, #1
  53 0016 84F8FD60 		strb	r6, [r4, #253]
 238:Src/util.c    ****   rtP_Left.i_max                = (I_MOT_MAX * A2BIT_CONV) << 4;        // fixdt(1,16,4)
  54              		.loc 1 238 3 is_stmt 1 view .LVU9
  55              		.loc 1 238 33 is_stmt 0 view .LVU10
  56 001a 42F6E062 		movw	r2, #12000
  57 001e A4F8CE20 		strh	r2, [r4, #206]	@ movhi
 239:Src/util.c    ****   rtP_Left.n_max                = N_MOT_MAX << 4;                       // fixdt(1,16,4)
  58              		.loc 1 239 3 is_stmt 1 view .LVU11
  59              		.loc 1 239 33 is_stmt 0 view .LVU12
  60 0022 4FF47A51 		mov	r1, #16000
  61 0026 A4F8DA10 		strh	r1, [r4, #218]	@ movhi
 240:Src/util.c    ****   rtP_Left.b_fieldWeakEna       = FIELD_WEAK_ENA; 
  62              		.loc 1 240 3 is_stmt 1 view .LVU13
  63              		.loc 1 240 33 is_stmt 0 view .LVU14
  64 002a 84F8FE30 		strb	r3, [r4, #254]
 241:Src/util.c    ****   rtP_Left.id_fieldWeakMax      = (FIELD_WEAK_MAX * A2BIT_CONV) << 4;   // fixdt(1,16,4)
  65              		.loc 1 241 3 is_stmt 1 view .LVU15
  66              		.loc 1 241 33 is_stmt 0 view .LVU16
  67 002e 4FF47A63 		mov	r3, #4000
  68 0032 A4F8D030 		strh	r3, [r4, #208]	@ movhi
 242:Src/util.c    ****   rtP_Left.a_phaAdvMax          = PHASE_ADV_MAX << 4;                   // fixdt(1,16,4)
  69              		.loc 1 242 3 is_stmt 1 view .LVU17
  70              		.loc 1 242 33 is_stmt 0 view .LVU18
  71 0036 4FF4C873 		mov	r3, #400
  72 003a A4F8CC30 		strh	r3, [r4, #204]	@ movhi
 243:Src/util.c    ****   rtP_Left.r_fieldWeakHi        = FIELD_WEAK_HI << 4;                   // fixdt(1,16,4)
  73              		.loc 1 243 3 is_stmt 1 view .LVU19
  74              		.loc 1 243 33 is_stmt 0 view .LVU20
  75 003e A4F8E010 		strh	r1, [r4, #224]	@ movhi
 244:Src/util.c    ****   rtP_Left.r_fieldWeakLo        = FIELD_WEAK_LO << 4;                   // fixdt(1,16,4)
  76              		.loc 1 244 3 is_stmt 1 view .LVU21
  77              		.loc 1 244 33 is_stmt 0 view .LVU22
  78 0042 A4F8E220 		strh	r2, [r4, #226]	@ movhi
 245:Src/util.c    **** 
 246:Src/util.c    ****   rtP_Right                     = rtP_Left;     // Copy the Left motor parameters to the Right moto
  79              		.loc 1 246 3 is_stmt 1 view .LVU23
  80              		.loc 1 246 33 is_stmt 0 view .LVU24
  81 0046 104D     		ldr	r5, .L3+4
  82 0048 4FF48072 		mov	r2, #256
  83 004c 2146     		mov	r1, r4
  84 004e 2846     		mov	r0, r5
  85 0050 FFF7FEFF 		bl	memcpy
  86              	.LVL0:
 247:Src/util.c    ****   rtP_Right.z_selPhaCurMeasABC  = 1;            // Right motor measured current phases {Blue, Yello
  87              		.loc 1 247 3 is_stmt 1 view .LVU25
  88              		.loc 1 247 33 is_stmt 0 view .LVU26
  89 0054 85F8FA60 		strb	r6, [r5, #250]
 248:Src/util.c    **** 
 249:Src/util.c    ****   /* Pack LEFT motor data into RTM */
 250:Src/util.c    ****   rtM_Left->defaultParam        = &rtP_Left;
  90              		.loc 1 250 3 is_stmt 1 view .LVU27
  91              		.loc 1 250 33 is_stmt 0 view .LVU28
  92 0058 0C48     		ldr	r0, .L3+8
  93 005a 0460     		str	r4, [r0]
ARM GAS  /tmp/cc14G55i.s 			page 7


 251:Src/util.c    ****   rtM_Left->dwork               = &rtDW_Left;
  94              		.loc 1 251 3 is_stmt 1 view .LVU29
  95              		.loc 1 251 33 is_stmt 0 view .LVU30
  96 005c 0C4B     		ldr	r3, .L3+12
  97 005e C360     		str	r3, [r0, #12]
 252:Src/util.c    ****   rtM_Left->inputs              = &rtU_Left;
  98              		.loc 1 252 3 is_stmt 1 view .LVU31
  99              		.loc 1 252 33 is_stmt 0 view .LVU32
 100 0060 0C4B     		ldr	r3, .L3+16
 101 0062 4360     		str	r3, [r0, #4]
 253:Src/util.c    ****   rtM_Left->outputs             = &rtY_Left;
 102              		.loc 1 253 3 is_stmt 1 view .LVU33
 103              		.loc 1 253 33 is_stmt 0 view .LVU34
 104 0064 0C4B     		ldr	r3, .L3+20
 105 0066 8360     		str	r3, [r0, #8]
 254:Src/util.c    **** 
 255:Src/util.c    ****   /* Pack RIGHT motor data into RTM */
 256:Src/util.c    ****   rtM_Right->defaultParam       = &rtP_Right;
 106              		.loc 1 256 3 is_stmt 1 view .LVU35
 107              		.loc 1 256 33 is_stmt 0 view .LVU36
 108 0068 0C4C     		ldr	r4, .L3+24
 109 006a 2560     		str	r5, [r4]
 257:Src/util.c    ****   rtM_Right->dwork              = &rtDW_Right;
 110              		.loc 1 257 3 is_stmt 1 view .LVU37
 111              		.loc 1 257 33 is_stmt 0 view .LVU38
 112 006c 0C4B     		ldr	r3, .L3+28
 113 006e E360     		str	r3, [r4, #12]
 258:Src/util.c    ****   rtM_Right->inputs             = &rtU_Right;
 114              		.loc 1 258 3 is_stmt 1 view .LVU39
 115              		.loc 1 258 33 is_stmt 0 view .LVU40
 116 0070 0C4B     		ldr	r3, .L3+32
 117 0072 6360     		str	r3, [r4, #4]
 259:Src/util.c    ****   rtM_Right->outputs            = &rtY_Right;
 118              		.loc 1 259 3 is_stmt 1 view .LVU41
 119              		.loc 1 259 33 is_stmt 0 view .LVU42
 120 0074 0C4B     		ldr	r3, .L3+36
 121 0076 A360     		str	r3, [r4, #8]
 260:Src/util.c    **** 
 261:Src/util.c    ****   /* Initialize BLDC controllers */
 262:Src/util.c    ****   BLDC_controller_initialize(rtM_Left);
 122              		.loc 1 262 3 is_stmt 1 view .LVU43
 123 0078 FFF7FEFF 		bl	BLDC_controller_initialize
 124              	.LVL1:
 263:Src/util.c    ****   BLDC_controller_initialize(rtM_Right);
 125              		.loc 1 263 3 view .LVU44
 126 007c 2046     		mov	r0, r4
 127 007e FFF7FEFF 		bl	BLDC_controller_initialize
 128              	.LVL2:
 264:Src/util.c    **** }
 129              		.loc 1 264 1 is_stmt 0 view .LVU45
 130 0082 70BD     		pop	{r4, r5, r6, pc}
 131              	.L4:
 132              		.align	2
 133              	.L3:
 134 0084 00000000 		.word	rtP_Left
 135 0088 00000000 		.word	.LANCHOR0
 136 008c 00000000 		.word	.LANCHOR1
ARM GAS  /tmp/cc14G55i.s 			page 8


 137 0090 00000000 		.word	.LANCHOR2
 138 0094 00000000 		.word	.LANCHOR3
 139 0098 00000000 		.word	.LANCHOR4
 140 009c 00000000 		.word	.LANCHOR5
 141 00a0 00000000 		.word	.LANCHOR6
 142 00a4 00000000 		.word	.LANCHOR7
 143 00a8 00000000 		.word	.LANCHOR8
 144              		.cfi_endproc
 145              	.LFE66:
 147              		.section	.text.Input_Lim_Init,"ax",%progbits
 148              		.align	1
 149              		.global	Input_Lim_Init
 150              		.syntax unified
 151              		.thumb
 152              		.thumb_func
 153              		.fpu softvfp
 155              	Input_Lim_Init:
 156              	.LFB67:
 265:Src/util.c    **** 
 266:Src/util.c    **** void Input_Lim_Init(void) {     // Input Limitations - ! Do NOT touch !
 157              		.loc 1 266 27 is_stmt 1 view -0
 158              		.cfi_startproc
 159              		@ args = 0, pretend = 0, frame = 0
 160              		@ frame_needed = 0, uses_anonymous_args = 0
 161              		@ link register save eliminated.
 267:Src/util.c    ****   if (rtP_Left.b_fieldWeakEna || rtP_Right.b_fieldWeakEna) {
 162              		.loc 1 267 3 view .LVU47
 163              		.loc 1 267 15 is_stmt 0 view .LVU48
 164 0000 0C4B     		ldr	r3, .L9
 165 0002 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 166              		.loc 1 267 6 view .LVU49
 167 0006 1BB9     		cbnz	r3, .L6
 168              		.loc 1 267 43 discriminator 1 view .LVU50
 169 0008 0B4B     		ldr	r3, .L9+4
 170 000a 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 171              		.loc 1 267 31 discriminator 1 view .LVU51
 172 000e 43B1     		cbz	r3, .L7
 173              	.L6:
 268:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 174              		.loc 1 268 5 is_stmt 1 view .LVU52
 175              		.loc 1 268 15 is_stmt 0 view .LVU53
 176 0010 0A4B     		ldr	r3, .L9+8
 177 0012 4FF47A72 		mov	r2, #1000
 178 0016 1A80     		strh	r2, [r3]	@ movhi
 269:Src/util.c    ****     INPUT_MIN = MIN(-1000,-FIELD_WEAK_HI);
 179              		.loc 1 269 5 is_stmt 1 view .LVU54
 180              		.loc 1 269 15 is_stmt 0 view .LVU55
 181 0018 094B     		ldr	r3, .L9+12
 182 001a 4FF61842 		movw	r2, #64536
 183 001e 1A80     		strh	r2, [r3]	@ movhi
 184 0020 7047     		bx	lr
 185              	.L7:
 270:Src/util.c    ****   } else {
 271:Src/util.c    ****     INPUT_MAX =  1000;
 186              		.loc 1 271 5 is_stmt 1 view .LVU56
 187              		.loc 1 271 15 is_stmt 0 view .LVU57
 188 0022 064B     		ldr	r3, .L9+8
ARM GAS  /tmp/cc14G55i.s 			page 9


 189 0024 4FF47A72 		mov	r2, #1000
 190 0028 1A80     		strh	r2, [r3]	@ movhi
 272:Src/util.c    ****     INPUT_MIN = -1000;
 191              		.loc 1 272 5 is_stmt 1 view .LVU58
 192              		.loc 1 272 15 is_stmt 0 view .LVU59
 193 002a 054B     		ldr	r3, .L9+12
 194 002c 4FF61842 		movw	r2, #64536
 195 0030 1A80     		strh	r2, [r3]	@ movhi
 273:Src/util.c    ****   }
 274:Src/util.c    **** }
 196              		.loc 1 274 1 view .LVU60
 197 0032 7047     		bx	lr
 198              	.L10:
 199              		.align	2
 200              	.L9:
 201 0034 00000000 		.word	rtP_Left
 202 0038 00000000 		.word	.LANCHOR0
 203 003c 00000000 		.word	.LANCHOR9
 204 0040 00000000 		.word	.LANCHOR10
 205              		.cfi_endproc
 206              	.LFE67:
 208              		.section	.text.poweronMelody,"ax",%progbits
 209              		.align	1
 210              		.global	poweronMelody
 211              		.syntax unified
 212              		.thumb
 213              		.thumb_func
 214              		.fpu softvfp
 216              	poweronMelody:
 217              	.LFB69:
 275:Src/util.c    **** 
 276:Src/util.c    **** void Input_Init(void) {
 277:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 278:Src/util.c    ****     PPM_Init();
 279:Src/util.c    ****   #endif
 280:Src/util.c    **** 
 281:Src/util.c    ****  #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 282:Src/util.c    ****     PWM_Init();
 283:Src/util.c    ****   #endif
 284:Src/util.c    **** 
 285:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USA
 286:Src/util.c    ****     UART2_Init();
 287:Src/util.c    ****   #endif
 288:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(FEEDBACK_SERIAL_USA
 289:Src/util.c    ****     UART3_Init();
 290:Src/util.c    ****   #endif
 291:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 292:Src/util.c    ****     HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_buffer_L, sizeof(rx_buffer_L));
 293:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 294:Src/util.c    ****   #endif
 295:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 296:Src/util.c    ****     HAL_UART_Receive_DMA(&huart3, (uint8_t *)rx_buffer_R, sizeof(rx_buffer_R));
 297:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 298:Src/util.c    ****   #endif
 299:Src/util.c    **** 
 300:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 301:Src/util.c    ****     uint16_t writeCheck, readVal;
ARM GAS  /tmp/cc14G55i.s 			page 10


 302:Src/util.c    ****     HAL_FLASH_Unlock();
 303:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 304:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 305:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 306:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 307:Src/util.c    ****         printf("Using the configuration from EEprom\r\n");
 308:Src/util.c    ****       #endif
 309:Src/util.c    **** 
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 321:Src/util.c    ****       
 322:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 323:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 324:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 325:Src/util.c    ****       }
 326:Src/util.c    ****     } else {
 327:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 328:Src/util.c    ****         printf("Using the configuration from config.h\r\n");
 329:Src/util.c    ****       #endif
 330:Src/util.c    **** 
 331:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 333:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 334:Src/util.c    ****         } else {
 335:Src/util.c    ****           input1[i].typ = input1[i].typDef;
 336:Src/util.c    ****         }
 337:Src/util.c    ****         if (input2[i].typDef == 3) {
 338:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 339:Src/util.c    ****         } else {
 340:Src/util.c    ****           input2[i].typ = input2[i].typDef;
 341:Src/util.c    ****         }
 342:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 343:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 344:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 345:Src/util.c    ****       }
 346:Src/util.c    ****     }
 347:Src/util.c    ****     HAL_FLASH_Lock();
 348:Src/util.c    ****   #endif
 349:Src/util.c    **** 
 350:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
 351:Src/util.c    ****     enable = 1;
 352:Src/util.c    **** 
 353:Src/util.c    ****     HAL_FLASH_Unlock();
 354:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 355:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &saveValue);
 356:Src/util.c    ****     HAL_FLASH_Lock();
 357:Src/util.c    **** 
 358:Src/util.c    ****     setDistance = saveValue / 1000.0;
ARM GAS  /tmp/cc14G55i.s 			page 11


 359:Src/util.c    ****     if (setDistance < 0.2) {
 360:Src/util.c    ****       setDistance = 1.0;
 361:Src/util.c    ****     }
 362:Src/util.c    ****   #endif
 363:Src/util.c    **** 
 364:Src/util.c    ****   #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 365:Src/util.c    ****     I2C_Init();
 366:Src/util.c    ****     HAL_Delay(50);
 367:Src/util.c    ****     lcd.pcf8574.PCF_I2C_ADDRESS = 0x27;
 368:Src/util.c    ****     lcd.pcf8574.PCF_I2C_TIMEOUT = 5;
 369:Src/util.c    ****     lcd.pcf8574.i2c             = hi2c2;
 370:Src/util.c    ****     lcd.NUMBER_OF_LINES         = NUMBER_OF_LINES_2;
 371:Src/util.c    ****     lcd.type                    = TYPE0;
 372:Src/util.c    **** 
 373:Src/util.c    ****     if(LCD_Init(&lcd)!=LCD_OK) {
 374:Src/util.c    ****         // error occured
 375:Src/util.c    ****         //TODO while(1);
 376:Src/util.c    ****     }
 377:Src/util.c    **** 
 378:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 379:Src/util.c    ****     HAL_Delay(5);
 380:Src/util.c    ****     LCD_SetLocation(&lcd, 0, 0);
 381:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 382:Src/util.c    ****       LCD_WriteString(&lcd, "TranspOtter V2.1");
 383:Src/util.c    ****     #else
 384:Src/util.c    ****       LCD_WriteString(&lcd, "Hover V2.0");
 385:Src/util.c    ****     #endif
 386:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Initializing...");
 387:Src/util.c    ****   #endif
 388:Src/util.c    **** 
 389:Src/util.c    ****   #if defined(VARIANT_TRANSPOTTER) && defined(SUPPORT_LCD)
 390:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 391:Src/util.c    ****     HAL_Delay(5);
 392:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Bat:");
 393:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 1); LCD_WriteString(&lcd, "V");
 394:Src/util.c    ****     LCD_SetLocation(&lcd, 15, 1); LCD_WriteString(&lcd, "A");
 395:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 396:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 397:Src/util.c    ****     LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 398:Src/util.c    ****   #endif
 399:Src/util.c    **** }
 400:Src/util.c    **** 
 401:Src/util.c    **** /**
 402:Src/util.c    ****   * @brief  Disable Rx Errors detection interrupts on UART peripheral (since we do not want DMA to 
 403:Src/util.c    ****   *         The incorrect data will be filtered based on the START_FRAME and checksum.
 404:Src/util.c    ****   * @param  huart: UART handle.
 405:Src/util.c    ****   * @retval None
 406:Src/util.c    ****   */
 407:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 408:Src/util.c    ****     defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 409:Src/util.c    **** void UART_DisableRxErrors(UART_HandleTypeDef *huart)
 410:Src/util.c    **** {  
 411:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);    /* Disable PE (Parity Error) interrupts */  
 412:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);     /* Disable EIE (Frame error, noise error, ove
 413:Src/util.c    **** }
 414:Src/util.c    **** #endif
 415:Src/util.c    **** 
ARM GAS  /tmp/cc14G55i.s 			page 12


 416:Src/util.c    **** 
 417:Src/util.c    **** /* =========================== General Functions =========================== */
 418:Src/util.c    **** 
 419:Src/util.c    **** void poweronMelody(void) {
 218              		.loc 1 419 26 is_stmt 1 view -0
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 0
 221              		@ frame_needed = 0, uses_anonymous_args = 0
 222 0000 10B5     		push	{r4, lr}
 223              	.LCFI1:
 224              		.cfi_def_cfa_offset 8
 225              		.cfi_offset 4, -8
 226              		.cfi_offset 14, -4
 420:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 227              		.loc 1 420 5 view .LVU62
 228              		.loc 1 420 17 is_stmt 0 view .LVU63
 229 0002 084B     		ldr	r3, .L15
 230 0004 0022     		movs	r2, #0
 231 0006 1A70     		strb	r2, [r3]
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 232              		.loc 1 421 5 is_stmt 1 view .LVU64
 233              	.LBB2:
 234              		.loc 1 421 10 view .LVU65
 235              	.LVL3:
 236              		.loc 1 421 14 is_stmt 0 view .LVU66
 237 0008 0824     		movs	r4, #8
 238              		.loc 1 421 5 view .LVU67
 239 000a 05E0     		b	.L12
 240              	.LVL4:
 241              	.L13:
 422:Src/util.c    ****       buzzerFreq = (uint8_t)i;
 242              		.loc 1 422 7 is_stmt 1 discriminator 3 view .LVU68
 243              		.loc 1 422 18 is_stmt 0 discriminator 3 view .LVU69
 244 000c 064B     		ldr	r3, .L15+4
 245 000e 1C70     		strb	r4, [r3]
 423:Src/util.c    ****       HAL_Delay(100);
 246              		.loc 1 423 7 is_stmt 1 discriminator 3 view .LVU70
 247 0010 6420     		movs	r0, #100
 248 0012 FFF7FEFF 		bl	HAL_Delay
 249              	.LVL5:
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 250              		.loc 1 421 29 discriminator 3 view .LVU71
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 251              		.loc 1 421 30 is_stmt 0 discriminator 3 view .LVU72
 252 0016 013C     		subs	r4, r4, #1
 253              	.LVL6:
 254              	.L12:
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 255              		.loc 1 421 21 is_stmt 1 discriminator 1 view .LVU73
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 256              		.loc 1 421 5 is_stmt 0 discriminator 1 view .LVU74
 257 0018 002C     		cmp	r4, #0
 258 001a F7DA     		bge	.L13
 259              	.LBE2:
 424:Src/util.c    ****     }
 425:Src/util.c    ****     buzzerFreq = 0;
 260              		.loc 1 425 5 is_stmt 1 view .LVU75
ARM GAS  /tmp/cc14G55i.s 			page 13


 261              		.loc 1 425 16 is_stmt 0 view .LVU76
 262 001c 024B     		ldr	r3, .L15+4
 263 001e 0022     		movs	r2, #0
 264 0020 1A70     		strb	r2, [r3]
 426:Src/util.c    **** }
 265              		.loc 1 426 1 view .LVU77
 266 0022 10BD     		pop	{r4, pc}
 267              	.LVL7:
 268              	.L16:
 269              		.loc 1 426 1 view .LVU78
 270              		.align	2
 271              	.L15:
 272 0024 00000000 		.word	buzzerCount
 273 0028 00000000 		.word	buzzerFreq
 274              		.cfi_endproc
 275              	.LFE69:
 277              		.section	.text.beepCount,"ax",%progbits
 278              		.align	1
 279              		.global	beepCount
 280              		.syntax unified
 281              		.thumb
 282              		.thumb_func
 283              		.fpu softvfp
 285              	beepCount:
 286              	.LVL8:
 287              	.LFB70:
 427:Src/util.c    **** 
 428:Src/util.c    **** void beepCount(uint8_t cnt, uint8_t freq, uint8_t pattern) {
 288              		.loc 1 428 60 is_stmt 1 view -0
 289              		.cfi_startproc
 290              		@ args = 0, pretend = 0, frame = 0
 291              		@ frame_needed = 0, uses_anonymous_args = 0
 292              		@ link register save eliminated.
 429:Src/util.c    ****     buzzerCount   = cnt;
 293              		.loc 1 429 5 view .LVU80
 294              		.loc 1 429 19 is_stmt 0 view .LVU81
 295 0000 034B     		ldr	r3, .L18
 296 0002 1870     		strb	r0, [r3]
 430:Src/util.c    ****     buzzerFreq    = freq;
 297              		.loc 1 430 5 is_stmt 1 view .LVU82
 298              		.loc 1 430 19 is_stmt 0 view .LVU83
 299 0004 034B     		ldr	r3, .L18+4
 300 0006 1970     		strb	r1, [r3]
 431:Src/util.c    ****     buzzerPattern = pattern;
 301              		.loc 1 431 5 is_stmt 1 view .LVU84
 302              		.loc 1 431 19 is_stmt 0 view .LVU85
 303 0008 034B     		ldr	r3, .L18+8
 304 000a 1A70     		strb	r2, [r3]
 432:Src/util.c    **** }
 305              		.loc 1 432 1 view .LVU86
 306 000c 7047     		bx	lr
 307              	.L19:
 308 000e 00BF     		.align	2
 309              	.L18:
 310 0010 00000000 		.word	buzzerCount
 311 0014 00000000 		.word	buzzerFreq
 312 0018 00000000 		.word	buzzerPattern
ARM GAS  /tmp/cc14G55i.s 			page 14


 313              		.cfi_endproc
 314              	.LFE70:
 316              		.section	.text.beepLong,"ax",%progbits
 317              		.align	1
 318              		.global	beepLong
 319              		.syntax unified
 320              		.thumb
 321              		.thumb_func
 322              		.fpu softvfp
 324              	beepLong:
 325              	.LVL9:
 326              	.LFB71:
 433:Src/util.c    **** 
 434:Src/util.c    **** void beepLong(uint8_t freq) {
 327              		.loc 1 434 29 is_stmt 1 view -0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 0
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331              		.loc 1 434 29 is_stmt 0 view .LVU88
 332 0000 38B5     		push	{r3, r4, r5, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 16
 335              		.cfi_offset 3, -16
 336              		.cfi_offset 4, -12
 337              		.cfi_offset 5, -8
 338              		.cfi_offset 14, -4
 435:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 339              		.loc 1 435 5 is_stmt 1 view .LVU89
 340              		.loc 1 435 17 is_stmt 0 view .LVU90
 341 0002 0025     		movs	r5, #0
 342 0004 044B     		ldr	r3, .L22
 343 0006 1D70     		strb	r5, [r3]
 436:Src/util.c    ****     buzzerFreq = freq;
 344              		.loc 1 436 5 is_stmt 1 view .LVU91
 345              		.loc 1 436 16 is_stmt 0 view .LVU92
 346 0008 044C     		ldr	r4, .L22+4
 347 000a 2070     		strb	r0, [r4]
 437:Src/util.c    ****     HAL_Delay(500);
 348              		.loc 1 437 5 is_stmt 1 view .LVU93
 349 000c 4FF4FA70 		mov	r0, #500
 350              	.LVL10:
 351              		.loc 1 437 5 is_stmt 0 view .LVU94
 352 0010 FFF7FEFF 		bl	HAL_Delay
 353              	.LVL11:
 438:Src/util.c    ****     buzzerFreq = 0;
 354              		.loc 1 438 5 is_stmt 1 view .LVU95
 355              		.loc 1 438 16 is_stmt 0 view .LVU96
 356 0014 2570     		strb	r5, [r4]
 439:Src/util.c    **** }
 357              		.loc 1 439 1 view .LVU97
 358 0016 38BD     		pop	{r3, r4, r5, pc}
 359              	.L23:
 360              		.align	2
 361              	.L22:
 362 0018 00000000 		.word	buzzerCount
 363 001c 00000000 		.word	buzzerFreq
 364              		.cfi_endproc
ARM GAS  /tmp/cc14G55i.s 			page 15


 365              	.LFE71:
 367              		.section	.text.beepShort,"ax",%progbits
 368              		.align	1
 369              		.global	beepShort
 370              		.syntax unified
 371              		.thumb
 372              		.thumb_func
 373              		.fpu softvfp
 375              	beepShort:
 376              	.LVL12:
 377              	.LFB72:
 440:Src/util.c    **** 
 441:Src/util.c    **** void beepShort(uint8_t freq) {
 378              		.loc 1 441 30 is_stmt 1 view -0
 379              		.cfi_startproc
 380              		@ args = 0, pretend = 0, frame = 0
 381              		@ frame_needed = 0, uses_anonymous_args = 0
 382              		.loc 1 441 30 is_stmt 0 view .LVU99
 383 0000 38B5     		push	{r3, r4, r5, lr}
 384              	.LCFI3:
 385              		.cfi_def_cfa_offset 16
 386              		.cfi_offset 3, -16
 387              		.cfi_offset 4, -12
 388              		.cfi_offset 5, -8
 389              		.cfi_offset 14, -4
 442:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 390              		.loc 1 442 5 is_stmt 1 view .LVU100
 391              		.loc 1 442 17 is_stmt 0 view .LVU101
 392 0002 0025     		movs	r5, #0
 393 0004 044B     		ldr	r3, .L26
 394 0006 1D70     		strb	r5, [r3]
 443:Src/util.c    ****     buzzerFreq = freq;
 395              		.loc 1 443 5 is_stmt 1 view .LVU102
 396              		.loc 1 443 16 is_stmt 0 view .LVU103
 397 0008 044C     		ldr	r4, .L26+4
 398 000a 2070     		strb	r0, [r4]
 444:Src/util.c    ****     HAL_Delay(100);
 399              		.loc 1 444 5 is_stmt 1 view .LVU104
 400 000c 6420     		movs	r0, #100
 401              	.LVL13:
 402              		.loc 1 444 5 is_stmt 0 view .LVU105
 403 000e FFF7FEFF 		bl	HAL_Delay
 404              	.LVL14:
 445:Src/util.c    ****     buzzerFreq = 0;
 405              		.loc 1 445 5 is_stmt 1 view .LVU106
 406              		.loc 1 445 16 is_stmt 0 view .LVU107
 407 0012 2570     		strb	r5, [r4]
 446:Src/util.c    **** }
 408              		.loc 1 446 1 view .LVU108
 409 0014 38BD     		pop	{r3, r4, r5, pc}
 410              	.L27:
 411 0016 00BF     		.align	2
 412              	.L26:
 413 0018 00000000 		.word	buzzerCount
 414 001c 00000000 		.word	buzzerFreq
 415              		.cfi_endproc
 416              	.LFE72:
ARM GAS  /tmp/cc14G55i.s 			page 16


 418              		.section	.text.beepShortMany,"ax",%progbits
 419              		.align	1
 420              		.global	beepShortMany
 421              		.syntax unified
 422              		.thumb
 423              		.thumb_func
 424              		.fpu softvfp
 426              	beepShortMany:
 427              	.LVL15:
 428              	.LFB73:
 447:Src/util.c    **** 
 448:Src/util.c    **** void beepShortMany(uint8_t cnt, int8_t dir) {
 429              		.loc 1 448 45 is_stmt 1 view -0
 430              		.cfi_startproc
 431              		@ args = 0, pretend = 0, frame = 0
 432              		@ frame_needed = 0, uses_anonymous_args = 0
 433              		.loc 1 448 45 is_stmt 0 view .LVU110
 434 0000 38B5     		push	{r3, r4, r5, lr}
 435              	.LCFI4:
 436              		.cfi_def_cfa_offset 16
 437              		.cfi_offset 3, -16
 438              		.cfi_offset 4, -12
 439              		.cfi_offset 5, -8
 440              		.cfi_offset 14, -4
 441 0002 0446     		mov	r4, r0
 449:Src/util.c    ****     if (dir >= 0) {   // increasing tone
 442              		.loc 1 449 5 is_stmt 1 view .LVU111
 443              		.loc 1 449 8 is_stmt 0 view .LVU112
 444 0004 0029     		cmp	r1, #0
 445 0006 15DB     		blt	.L34
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 446              		.loc 1 450 7 is_stmt 1 view .LVU113
 447              	.LBB3:
 448              		.loc 1 450 11 view .LVU114
 449              		.loc 1 450 19 is_stmt 0 view .LVU115
 450 0008 4400     		lsls	r4, r0, #1
 451 000a E4B2     		uxtb	r4, r4
 452              	.LVL16:
 453              		.loc 1 450 7 view .LVU116
 454 000c 05E0     		b	.L30
 455              	.LVL17:
 456              	.L31:
 451:Src/util.c    ****         beepShort(i + 3);
 457              		.loc 1 451 9 is_stmt 1 discriminator 3 view .LVU117
 458 000e E01C     		adds	r0, r4, #3
 459 0010 C0B2     		uxtb	r0, r0
 460 0012 FFF7FEFF 		bl	beepShort
 461              	.LVL18:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 462              		.loc 1 450 38 discriminator 3 view .LVU118
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 463              		.loc 1 450 39 is_stmt 0 discriminator 3 view .LVU119
 464 0016 023C     		subs	r4, r4, #2
 465              	.LVL19:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 466              		.loc 1 450 39 discriminator 3 view .LVU120
 467 0018 E4B2     		uxtb	r4, r4
ARM GAS  /tmp/cc14G55i.s 			page 17


 468              	.LVL20:
 469              	.L30:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 470              		.loc 1 450 30 is_stmt 1 discriminator 1 view .LVU121
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 471              		.loc 1 450 7 is_stmt 0 discriminator 1 view .LVU122
 472 001a 012C     		cmp	r4, #1
 473 001c F7D8     		bhi	.L31
 474              	.LVL21:
 475              	.L28:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 476              		.loc 1 450 7 discriminator 1 view .LVU123
 477              	.LBE3:
 452:Src/util.c    ****       }
 453:Src/util.c    ****     } else {          // decreasing tone
 454:Src/util.c    ****       for(uint8_t i = 2; i <= 2*cnt; i=i+2) {
 455:Src/util.c    ****         beepShort(i + 3);
 456:Src/util.c    ****       }
 457:Src/util.c    ****     }
 458:Src/util.c    **** }
 478              		.loc 1 458 1 view .LVU124
 479 001e 38BD     		pop	{r3, r4, r5, pc}
 480              	.LVL22:
 481              	.L33:
 482              	.LBB4:
 455:Src/util.c    ****       }
 483              		.loc 1 455 9 is_stmt 1 discriminator 3 view .LVU125
 484 0020 E81C     		adds	r0, r5, #3
 485 0022 C0B2     		uxtb	r0, r0
 486 0024 FFF7FEFF 		bl	beepShort
 487              	.LVL23:
 454:Src/util.c    ****         beepShort(i + 3);
 488              		.loc 1 454 38 discriminator 3 view .LVU126
 454:Src/util.c    ****         beepShort(i + 3);
 489              		.loc 1 454 39 is_stmt 0 discriminator 3 view .LVU127
 490 0028 0235     		adds	r5, r5, #2
 491              	.LVL24:
 454:Src/util.c    ****         beepShort(i + 3);
 492              		.loc 1 454 39 discriminator 3 view .LVU128
 493 002a EDB2     		uxtb	r5, r5
 494              	.LVL25:
 495              	.L29:
 454:Src/util.c    ****         beepShort(i + 3);
 496              		.loc 1 454 26 is_stmt 1 discriminator 1 view .LVU129
 454:Src/util.c    ****         beepShort(i + 3);
 497              		.loc 1 454 7 is_stmt 0 discriminator 1 view .LVU130
 498 002c B5EB440F 		cmp	r5, r4, lsl #1
 499 0030 F6DD     		ble	.L33
 500 0032 F4E7     		b	.L28
 501              	.LVL26:
 502              	.L34:
 454:Src/util.c    ****         beepShort(i + 3);
 503              		.loc 1 454 19 view .LVU131
 504 0034 0225     		movs	r5, #2
 505 0036 F9E7     		b	.L29
 506              	.LBE4:
 507              		.cfi_endproc
ARM GAS  /tmp/cc14G55i.s 			page 18


 508              	.LFE73:
 510              		.section	.text.calcAvgSpeed,"ax",%progbits
 511              		.align	1
 512              		.global	calcAvgSpeed
 513              		.syntax unified
 514              		.thumb
 515              		.thumb_func
 516              		.fpu softvfp
 518              	calcAvgSpeed:
 519              	.LFB74:
 459:Src/util.c    **** 
 460:Src/util.c    **** void calcAvgSpeed(void) {
 520              		.loc 1 460 25 is_stmt 1 view -0
 521              		.cfi_startproc
 522              		@ args = 0, pretend = 0, frame = 0
 523              		@ frame_needed = 0, uses_anonymous_args = 0
 524              		@ link register save eliminated.
 461:Src/util.c    ****     // Calculate measured average speed. The minus sign (-) is because motors spin in opposite dire
 462:Src/util.c    ****     speedAvg = 0;
 525              		.loc 1 462 5 view .LVU133
 526              		.loc 1 462 14 is_stmt 0 view .LVU134
 527 0000 0B4A     		ldr	r2, .L37
 528 0002 0023     		movs	r3, #0
 529 0004 1380     		strh	r3, [r2]	@ movhi
 463:Src/util.c    ****     #if defined(MOTOR_LEFT_ENA)
 464:Src/util.c    ****       #if defined(INVERT_L_DIRECTION)
 465:Src/util.c    ****         speedAvg -= rtY_Left.n_mot;
 466:Src/util.c    ****       #else
 467:Src/util.c    ****         speedAvg += rtY_Left.n_mot;
 530              		.loc 1 467 9 is_stmt 1 view .LVU135
 531              		.loc 1 467 29 is_stmt 0 view .LVU136
 532 0006 0B4B     		ldr	r3, .L37+4
 533 0008 B3F90810 		ldrsh	r1, [r3, #8]
 534 000c 8BB2     		uxth	r3, r1
 535              		.loc 1 467 18 view .LVU137
 536 000e 1180     		strh	r1, [r2]	@ movhi
 468:Src/util.c    ****       #endif
 469:Src/util.c    ****     #endif
 470:Src/util.c    ****     #if defined(MOTOR_RIGHT_ENA)
 471:Src/util.c    ****       #if defined(INVERT_R_DIRECTION)
 472:Src/util.c    ****         speedAvg += rtY_Right.n_mot;
 473:Src/util.c    ****       #else
 474:Src/util.c    ****         speedAvg -= rtY_Right.n_mot;
 537              		.loc 1 474 9 is_stmt 1 view .LVU138
 538              		.loc 1 474 30 is_stmt 0 view .LVU139
 539 0010 0949     		ldr	r1, .L37+8
 540 0012 0989     		ldrh	r1, [r1, #8]
 541              		.loc 1 474 18 view .LVU140
 542 0014 5B1A     		subs	r3, r3, r1
 543 0016 1BB2     		sxth	r3, r3
 544 0018 1380     		strh	r3, [r2]	@ movhi
 475:Src/util.c    ****       #endif
 476:Src/util.c    **** 
 477:Src/util.c    ****       // Average only if both motors are enabled
 478:Src/util.c    ****       #if defined(MOTOR_LEFT_ENA)
 479:Src/util.c    ****         speedAvg /= 2;
 545              		.loc 1 479 9 is_stmt 1 view .LVU141
ARM GAS  /tmp/cc14G55i.s 			page 19


 546              		.loc 1 479 18 is_stmt 0 view .LVU142
 547 001a 03EBD373 		add	r3, r3, r3, lsr #31
 548 001e 5B10     		asrs	r3, r3, #1
 549 0020 1380     		strh	r3, [r2]	@ movhi
 480:Src/util.c    ****       #endif  
 481:Src/util.c    ****     #endif
 482:Src/util.c    **** 
 483:Src/util.c    ****     // Handle the case when SPEED_COEFFICIENT sign is negative (which is when most significant bit 
 484:Src/util.c    ****     if (SPEED_COEFFICIENT & (1 << 16)) {
 550              		.loc 1 484 5 is_stmt 1 view .LVU143
 485:Src/util.c    ****       speedAvg    = -speedAvg;
 486:Src/util.c    ****     } 
 487:Src/util.c    ****     speedAvgAbs   = abs(speedAvg);
 551              		.loc 1 487 5 view .LVU144
 552              		.loc 1 487 21 is_stmt 0 view .LVU145
 553 0022 002B     		cmp	r3, #0
 554 0024 B8BF     		it	lt
 555 0026 5B42     		rsblt	r3, r3, #0
 556              		.loc 1 487 19 view .LVU146
 557 0028 044A     		ldr	r2, .L37+12
 558 002a 1380     		strh	r3, [r2]	@ movhi
 488:Src/util.c    **** }
 559              		.loc 1 488 1 view .LVU147
 560 002c 7047     		bx	lr
 561              	.L38:
 562 002e 00BF     		.align	2
 563              	.L37:
 564 0030 00000000 		.word	.LANCHOR11
 565 0034 00000000 		.word	.LANCHOR4
 566 0038 00000000 		.word	.LANCHOR8
 567 003c 00000000 		.word	.LANCHOR12
 568              		.cfi_endproc
 569              	.LFE74:
 571              		.section	.text.standstillHold,"ax",%progbits
 572              		.align	1
 573              		.global	standstillHold
 574              		.syntax unified
 575              		.thumb
 576              		.thumb_func
 577              		.fpu softvfp
 579              	standstillHold:
 580              	.LFB77:
 489:Src/util.c    **** 
 490:Src/util.c    ****  /*
 491:Src/util.c    ****  * Auto-calibration of the ADC Limits
 492:Src/util.c    ****  * This function finds the Minimum, Maximum, and Middle for the ADC input
 493:Src/util.c    ****  * Procedure:
 494:Src/util.c    ****  * - press the power button for more than 5 sec and release after the beep sound
 495:Src/util.c    ****  * - move the potentiometers freely to the min and max limits repeatedly
 496:Src/util.c    ****  * - release potentiometers to the resting postion
 497:Src/util.c    ****  * - press the power button to confirm or wait for the 20 sec timeout
 498:Src/util.c    ****  * The Values will be saved to flash. Values are persistent if you flash with platformio. To erase 
 499:Src/util.c    ****  */
 500:Src/util.c    **** void adcCalibLim(void) {
 501:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 502:Src/util.c    ****   calcAvgSpeed();
 503:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
ARM GAS  /tmp/cc14G55i.s 			page 20


 504:Src/util.c    ****     return;
 505:Src/util.c    ****   }
 506:Src/util.c    **** 
 507:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 508:Src/util.c    **** 
 509:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 510:Src/util.c    ****   printf("Input calibration started...\r\n");
 511:Src/util.c    ****   #endif
 512:Src/util.c    **** 
 513:Src/util.c    ****   readInputRaw();
 514:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 515:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 516:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 517:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 518:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 519:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 520:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 521:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 522:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 523:Src/util.c    ****   int16_t  input_margin    = 0;
 524:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 525:Src/util.c    ****   
 526:Src/util.c    ****   #ifdef CONTROL_ADC
 527:Src/util.c    ****   if (inIdx == CONTROL_ADC) {
 528:Src/util.c    ****     input_margin = ADC_MARGIN;
 529:Src/util.c    ****   }
 530:Src/util.c    ****   #endif
 531:Src/util.c    **** 
 532:Src/util.c    ****   // Extract MIN, MAX and MID from ADC while the power button is not pressed
 533:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && input_cal_timeout++ < 4000) {   // 20 sec ti
 534:Src/util.c    ****     readInputRaw();
 535:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 536:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 537:Src/util.c    ****     
 538:Src/util.c    ****     INPUT1_MID_temp = (int16_t)(input1_fixdt >> 16);// CLAMP(input1_fixdt >> 16, INPUT1_MIN, INPUT1
 539:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 540:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 541:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 542:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 543:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 544:Src/util.c    ****     HAL_Delay(5);
 545:Src/util.c    ****   }
 546:Src/util.c    **** 
 547:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 548:Src/util.c    ****   printf("Input1 is ");
 549:Src/util.c    ****   #endif
 550:Src/util.c    ****   uint8_t input1TypTemp = checkInputType(INPUT1_MIN_temp, INPUT1_MID_temp, INPUT1_MAX_temp);
 551:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 552:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 553:Src/util.c    ****     printf("..OK\r\n");
 554:Src/util.c    ****     #endif
 555:Src/util.c    ****   } else {
 556:Src/util.c    ****     input1TypTemp = 0; // Disable input
 557:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 558:Src/util.c    ****     printf("..NOK\r\n");
 559:Src/util.c    ****     #endif
 560:Src/util.c    ****   }
ARM GAS  /tmp/cc14G55i.s 			page 21


 561:Src/util.c    **** 
 562:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 563:Src/util.c    ****   printf("Input2 is ");
 564:Src/util.c    ****   #endif
 565:Src/util.c    ****   uint8_t input2TypTemp = checkInputType(INPUT2_MIN_temp, INPUT2_MID_temp, INPUT2_MAX_temp);
 566:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 567:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 568:Src/util.c    ****     printf("..OK\r\n");
 569:Src/util.c    ****     #endif
 570:Src/util.c    ****   } else {
 571:Src/util.c    ****     input2TypTemp = 0; // Disable input
 572:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 573:Src/util.c    ****     printf("..NOK\r\n");
 574:Src/util.c    ****     #endif
 575:Src/util.c    ****   }
 576:Src/util.c    **** 
 577:Src/util.c    **** 
 578:Src/util.c    ****   // At least one of the inputs is not ignored
 579:Src/util.c    ****   if (input1TypTemp != 0 || input2TypTemp != 0){
 580:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 581:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 582:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 583:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 584:Src/util.c    **** 
 585:Src/util.c    ****     input2[inIdx].typ = input2TypTemp;
 586:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 587:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 588:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 589:Src/util.c    **** 
 590:Src/util.c    ****     inp_cal_valid = 1;    // Mark calibration to be saved in Flash at shutdown
 591:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 592:Src/util.c    ****     printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i MAX:%
 593:Src/util.c    ****             input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 594:Src/util.c    ****             input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 595:Src/util.c    ****     #endif
 596:Src/util.c    ****   }else{
 597:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 598:Src/util.c    ****     printf("Both inputs cannot be ignored, calibration rejected.\r\n");
 599:Src/util.c    ****     #endif
 600:Src/util.c    ****   }
 601:Src/util.c    **** 
 602:Src/util.c    **** #endif
 603:Src/util.c    **** #endif  // AUTO_CALIBRATION_ENA
 604:Src/util.c    **** }
 605:Src/util.c    ****  /*
 606:Src/util.c    ****  * Update Maximum Motor Current Limit (via ADC1) and Maximum Speed Limit (via ADC2)
 607:Src/util.c    ****  * Procedure:
 608:Src/util.c    ****  * - press the power button for more than 5 sec and immediatelly after the beep sound press one mor
 609:Src/util.c    ****  * - move and hold the pots to a desired limit position for Current and Speed
 610:Src/util.c    ****  * - press the power button to confirm or wait for the 10 sec timeout
 611:Src/util.c    ****  */
 612:Src/util.c    **** void updateCurSpdLim(void) {
 613:Src/util.c    ****   calcAvgSpeed();
 614:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 615:Src/util.c    ****     return;
 616:Src/util.c    ****   }
 617:Src/util.c    **** 
ARM GAS  /tmp/cc14G55i.s 			page 22


 618:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 619:Src/util.c    **** 
 620:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 621:Src/util.c    ****   printf("Torque and Speed limits update started...\r\n");
 622:Src/util.c    ****   #endif
 623:Src/util.c    **** 
 624:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 625:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 626:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 627:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 628:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 629:Src/util.c    ****   cur_spd_valid = 0;
 630:Src/util.c    **** 
 631:Src/util.c    ****   // Wait for the power button press
 632:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && cur_spd_timeout++ < 2000) {  // 10 sec timeo
 633:Src/util.c    ****     readInputRaw();
 634:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 635:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 636:Src/util.c    ****     HAL_Delay(5);
 637:Src/util.c    ****   }
 638:Src/util.c    ****   // Calculate scaling factors
 639:Src/util.c    ****   cur_factor = CLAMP((input1_fixdt - (input1[inIdx].min << 16)) / (input1[inIdx].max - input1[inIdx
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 641:Src/util.c    ****       
 642:Src/util.c    ****   if (input1[inIdx].typ != 0){
 643:Src/util.c    ****     // Update current limit
 644:Src/util.c    ****     rtP_Left.i_max = rtP_Right.i_max  = (int16_t)((I_MOT_MAX * A2BIT_CONV * cur_factor) >> 12);    
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 646:Src/util.c    ****   }
 647:Src/util.c    **** 
 648:Src/util.c    ****   if (input2[inIdx].typ != 0){
 649:Src/util.c    ****     // Update speed limit
 650:Src/util.c    ****     rtP_Left.n_max = rtP_Right.n_max  = (int16_t)((N_MOT_MAX * spd_factor) >> 12);                 
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 652:Src/util.c    ****   }
 653:Src/util.c    **** 
 654:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 655:Src/util.c    ****   // cur_spd_valid: 0 = No limit changed, 1 = Current limit changed, 2 = Speed limit changed, 3 = B
 656:Src/util.c    ****   printf("Limits (%i)\r\nCurrent: fixdt:%li factor%i i_max:%i \r\nSpeed: fixdt:%li factor:%i n_max:
 657:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 658:Src/util.c    ****   #endif
 659:Src/util.c    **** 
 660:Src/util.c    **** #endif
 661:Src/util.c    **** }
 662:Src/util.c    **** 
 663:Src/util.c    ****  /*
 664:Src/util.c    ****  * Standstill Hold Function
 665:Src/util.c    ****  * This function uses Cruise Control to provide an anti-roll functionality at standstill.
 666:Src/util.c    ****  * Only available and makes sense for FOC VOLTAGE or FOC TORQUE mode.
 667:Src/util.c    ****  * 
 668:Src/util.c    ****  * Input:  none
 669:Src/util.c    ****  * Output: standstillAcv
 670:Src/util.c    ****  */
 671:Src/util.c    **** void standstillHold(void) {
 581              		.loc 1 671 27 is_stmt 1 view -0
 582              		.cfi_startproc
 583              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cc14G55i.s 			page 23


 584              		@ frame_needed = 0, uses_anonymous_args = 0
 585              		@ link register save eliminated.
 672:Src/util.c    ****   #if defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ != SPD_MODE)
 673:Src/util.c    ****     if (!rtP_Left.b_cruiseCtrlEna) {                                  // If Stanstill in NOT Active
 674:Src/util.c    ****       if (((input1[inIdx].cmd > 50 || input2[inIdx].cmd < -50) && speedAvgAbs < 30) // Check if Bra
 675:Src/util.c    ****           || (input2[inIdx].cmd < 20 && speedAvgAbs < 5)) {           // OR Throttle is small AND m
 676:Src/util.c    ****         rtP_Left.n_cruiseMotTgt   = 0;
 677:Src/util.c    ****         rtP_Right.n_cruiseMotTgt  = 0;
 678:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 1;
 679:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 1;
 680:Src/util.c    ****         standstillAcv = 1;
 681:Src/util.c    ****       } 
 682:Src/util.c    ****     }
 683:Src/util.c    ****     else {                                                            // If Stanstill is Active -> 
 684:Src/util.c    ****       if (input1[inIdx].cmd < 20 && input2[inIdx].cmd > 50 && !cruiseCtrlAcv) { // Check if Brake i
 685:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 0;
 686:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 0;
 687:Src/util.c    ****         standstillAcv = 0;
 688:Src/util.c    ****       }
 689:Src/util.c    ****     }
 690:Src/util.c    ****   #endif
 691:Src/util.c    **** }
 586              		.loc 1 691 1 view .LVU149
 587 0000 7047     		bx	lr
 588              		.cfi_endproc
 589              	.LFE77:
 591              		.section	.text.electricBrake,"ax",%progbits
 592              		.align	1
 593              		.global	electricBrake
 594              		.syntax unified
 595              		.thumb
 596              		.thumb_func
 597              		.fpu softvfp
 599              	electricBrake:
 600              	.LVL27:
 601              	.LFB78:
 692:Src/util.c    **** 
 693:Src/util.c    ****  /*
 694:Src/util.c    ****  * Electric Brake Function
 695:Src/util.c    ****  * In case of TORQUE mode, this function replaces the motor "freewheel" with a constant braking whe
 696:Src/util.c    ****  * This is useful when a small amount of motor braking is desired instead of "freewheel".
 697:Src/util.c    ****  * 
 698:Src/util.c    ****  * Input: speedBlend = fixdt(0,16,15), reverseDir = {0, 1}
 699:Src/util.c    ****  * Output: input2.cmd (Throtle) with brake component included
 700:Src/util.c    ****  */
 701:Src/util.c    **** void electricBrake(uint16_t speedBlend, uint8_t reverseDir) {
 602              		.loc 1 701 61 view -0
 603              		.cfi_startproc
 604              		@ args = 0, pretend = 0, frame = 0
 605              		@ frame_needed = 0, uses_anonymous_args = 0
 606              		@ link register save eliminated.
 702:Src/util.c    ****   #if defined(ELECTRIC_BRAKE_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ == TRQ_MODE)
 703:Src/util.c    ****     int16_t brakeVal;
 704:Src/util.c    **** 
 705:Src/util.c    ****     // Make sure the Brake pedal is opposite to the direction of motion AND it goes to 0 as we reac
 706:Src/util.c    ****     if (speedAvg > 0) {
 707:Src/util.c    ****       brakeVal = (int16_t)((-ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
ARM GAS  /tmp/cc14G55i.s 			page 24


 708:Src/util.c    ****     } else {
 709:Src/util.c    ****       brakeVal = (int16_t)(( ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 710:Src/util.c    ****     }
 711:Src/util.c    **** 
 712:Src/util.c    ****     // Check if direction is reversed
 713:Src/util.c    ****     if (reverseDir) {
 714:Src/util.c    ****       brakeVal = -brakeVal;
 715:Src/util.c    ****     }
 716:Src/util.c    **** 
 717:Src/util.c    ****     // Calculate the new input2.cmd with brake component included
 718:Src/util.c    ****     if (input2[inIdx].cmd >= 0 && input2[inIdx].cmd < ELECTRIC_BRAKE_THRES) {
 719:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((ELECTRIC_BRAKE_THRES - input2[inIdx].cmd) * brakeVal) / E
 720:Src/util.c    ****     } else if (input2[inIdx].cmd >= -ELECTRIC_BRAKE_THRES && input2[inIdx].cmd < 0) {
 721:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((ELECTRIC_BRAKE_THRES + input2[inIdx].cmd) * brakeVal) / E
 722:Src/util.c    ****     } else if (input2[inIdx].cmd >= ELECTRIC_BRAKE_THRES) {
 723:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((input2[inIdx].cmd - ELECTRIC_BRAKE_THRES) * INPUT_MAX) / 
 724:Src/util.c    ****     } else {  // when (input2.cmd < -ELECTRIC_BRAKE_THRES)
 725:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((input2[inIdx].cmd + ELECTRIC_BRAKE_THRES) * INPUT_MIN) / 
 726:Src/util.c    ****     }
 727:Src/util.c    ****   #endif
 728:Src/util.c    **** }
 607              		.loc 1 728 1 view .LVU151
 608 0000 7047     		bx	lr
 609              		.cfi_endproc
 610              	.LFE78:
 612              		.section	.text.cruiseControl,"ax",%progbits
 613              		.align	1
 614              		.global	cruiseControl
 615              		.syntax unified
 616              		.thumb
 617              		.thumb_func
 618              		.fpu softvfp
 620              	cruiseControl:
 621              	.LVL28:
 622              	.LFB79:
 729:Src/util.c    **** 
 730:Src/util.c    ****  /*
 731:Src/util.c    ****  * Cruise Control Function
 732:Src/util.c    ****  * This function activates/deactivates cruise control.
 733:Src/util.c    ****  * 
 734:Src/util.c    ****  * Input: button (as a pulse)
 735:Src/util.c    ****  * Output: cruiseCtrlAcv
 736:Src/util.c    ****  */
 737:Src/util.c    **** void cruiseControl(uint8_t button) {
 623              		.loc 1 737 36 view -0
 624              		.cfi_startproc
 625              		@ args = 0, pretend = 0, frame = 0
 626              		@ frame_needed = 0, uses_anonymous_args = 0
 627              		@ link register save eliminated.
 738:Src/util.c    ****   #ifdef CRUISE_CONTROL_SUPPORT
 739:Src/util.c    ****     if (button && !rtP_Left.b_cruiseCtrlEna) {                          // Cruise control activated
 740:Src/util.c    ****       rtP_Left.n_cruiseMotTgt   = rtY_Left.n_mot;
 741:Src/util.c    ****       rtP_Right.n_cruiseMotTgt  = rtY_Right.n_mot;
 742:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 1;
 743:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 1;
 744:Src/util.c    ****       cruiseCtrlAcv = 1;
 745:Src/util.c    ****       beepShortMany(2, 1);                                              // 200 ms beep delay. Acts 
ARM GAS  /tmp/cc14G55i.s 			page 25


 746:Src/util.c    ****     } else if (button && rtP_Left.b_cruiseCtrlEna && !standstillAcv) {  // Cruise control deactivat
 747:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 0;
 748:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 0;
 749:Src/util.c    ****       cruiseCtrlAcv = 0;
 750:Src/util.c    ****       beepShortMany(2, -1);
 751:Src/util.c    ****     }
 752:Src/util.c    ****   #endif
 753:Src/util.c    **** }
 628              		.loc 1 753 1 view .LVU153
 629 0000 7047     		bx	lr
 630              		.cfi_endproc
 631              	.LFE79:
 633              		.section	.text.checkInputType,"ax",%progbits
 634              		.align	1
 635              		.global	checkInputType
 636              		.syntax unified
 637              		.thumb
 638              		.thumb_func
 639              		.fpu softvfp
 641              	checkInputType:
 642              	.LVL29:
 643              	.LFB80:
 754:Src/util.c    **** 
 755:Src/util.c    ****  /*
 756:Src/util.c    ****  * Check Input Type
 757:Src/util.c    ****  * This function identifies the input type: 0: Disabled, 1: Normal Pot, 2: Middle Resting Pot
 758:Src/util.c    ****  */
 759:Src/util.c    **** int checkInputType(int16_t min, int16_t mid, int16_t max){
 644              		.loc 1 759 58 view -0
 645              		.cfi_startproc
 646              		@ args = 0, pretend = 0, frame = 0
 647              		@ frame_needed = 0, uses_anonymous_args = 0
 648              		.loc 1 759 58 is_stmt 0 view .LVU155
 649 0000 10B5     		push	{r4, lr}
 650              	.LCFI5:
 651              		.cfi_def_cfa_offset 8
 652              		.cfi_offset 4, -8
 653              		.cfi_offset 14, -4
 760:Src/util.c    **** 
 761:Src/util.c    ****   int type = 0;  
 654              		.loc 1 761 3 is_stmt 1 view .LVU156
 655              	.LVL30:
 762:Src/util.c    ****   #ifdef CONTROL_ADC
 763:Src/util.c    ****   int16_t threshold = 400;      // Threshold to define if values are too close
 656              		.loc 1 763 3 view .LVU157
 764:Src/util.c    ****   #else
 765:Src/util.c    ****   int16_t threshold = 200;
 766:Src/util.c    ****   #endif
 767:Src/util.c    **** 
 768:Src/util.c    ****   if ((min / threshold) == (max / threshold) || (mid / threshold) == (max / threshold) || min > max
 657              		.loc 1 768 3 view .LVU158
 658              		.loc 1 768 12 is_stmt 0 view .LVU159
 659 0002 1A4B     		ldr	r3, .L52
 660 0004 83FB00C4 		smull	ip, r4, r3, r0
 661 0008 4FEAE07E 		asr	lr, r0, #31
 662 000c CEEBE41E 		rsb	lr, lr, r4, asr #7
 663              		.loc 1 768 33 view .LVU160
ARM GAS  /tmp/cc14G55i.s 			page 26


 664 0010 83FB0243 		smull	r4, r3, r3, r2
 665 0014 4FEAE27C 		asr	ip, r2, #31
 666 0018 CCEBE313 		rsb	r3, ip, r3, asr #7
 667              		.loc 1 768 6 view .LVU161
 668 001c 9E45     		cmp	lr, r3
 669 001e 1BD0     		beq	.L45
 670              		.loc 1 768 54 discriminator 1 view .LVU162
 671 0020 124C     		ldr	r4, .L52
 672 0022 84FB01C4 		smull	ip, r4, r4, r1
 673 0026 4FEAE17C 		asr	ip, r1, #31
 674 002a CCEBE41C 		rsb	ip, ip, r4, asr #7
 675              		.loc 1 768 46 discriminator 1 view .LVU163
 676 002e 6345     		cmp	r3, ip
 677 0030 15D0     		beq	.L46
 678              		.loc 1 768 88 discriminator 2 view .LVU164
 679 0032 9042     		cmp	r0, r2
 680 0034 15DC     		bgt	.L47
 681              		.loc 1 768 101 discriminator 3 view .LVU165
 682 0036 8A42     		cmp	r2, r1
 683 0038 15DB     		blt	.L48
 769:Src/util.c    ****     type = 0;
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 771:Src/util.c    ****     printf("ignored");                // (MIN and MAX) OR (MID and MAX) are close, disable input
 772:Src/util.c    ****     #endif
 773:Src/util.c    ****   } else {
 774:Src/util.c    ****     if ((min / threshold) == (mid / threshold)){
 684              		.loc 1 774 5 is_stmt 1 view .LVU166
 685              		.loc 1 774 8 is_stmt 0 view .LVU167
 686 003a E645     		cmp	lr, ip
 687 003c 0AD0     		beq	.L51
 775:Src/util.c    ****       type = 1;
 776:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 777:Src/util.c    ****       printf("a normal pot");        // MIN and MID are close, it's a normal pot
 778:Src/util.c    ****       #endif
 779:Src/util.c    ****     } else {
 780:Src/util.c    ****       type = 2;
 688              		.loc 1 780 12 view .LVU168
 689 003e 0224     		movs	r4, #2
 690              	.L44:
 691              	.LVL31:
 781:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 782:Src/util.c    ****       printf("a mid-resting pot");   // it's a mid resting pot
 783:Src/util.c    ****       #endif
 784:Src/util.c    ****     }
 785:Src/util.c    **** 
 786:Src/util.c    ****     #ifdef CONTROL_ADC
 787:Src/util.c    ****     if ((min + ADC_MARGIN - ADC_PROTECT_THRESH) > 0 && (max - ADC_MARGIN + ADC_PROTECT_THRESH) < 40
 692              		.loc 1 787 5 is_stmt 1 view .LVU169
 693              		.loc 1 787 8 is_stmt 0 view .LVU170
 694 0040 6428     		cmp	r0, #100
 695 0042 0ADD     		ble	.L42
 696              		.loc 1 787 53 discriminator 1 view .LVU171
 697 0044 40F69A73 		movw	r3, #3994
 698 0048 9A42     		cmp	r2, r3
 699 004a 06DC     		bgt	.L42
 788:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 789:Src/util.c    ****       printf(" AND protected");
ARM GAS  /tmp/cc14G55i.s 			page 27


 790:Src/util.c    ****       #endif
 791:Src/util.c    ****       beepLong(2); // Indicate protection by a beep
 700              		.loc 1 791 7 is_stmt 1 view .LVU172
 701 004c 0220     		movs	r0, #2
 702              	.LVL32:
 703              		.loc 1 791 7 is_stmt 0 view .LVU173
 704 004e FFF7FEFF 		bl	beepLong
 705              	.LVL33:
 706              		.loc 1 791 7 view .LVU174
 707 0052 02E0     		b	.L42
 708              	.LVL34:
 709              	.L51:
 775:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 710              		.loc 1 775 12 view .LVU175
 711 0054 0124     		movs	r4, #1
 712 0056 F3E7     		b	.L44
 713              	.L45:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 714              		.loc 1 769 10 view .LVU176
 715 0058 0024     		movs	r4, #0
 716              	.LVL35:
 717              	.L42:
 792:Src/util.c    ****     }
 793:Src/util.c    ****     #endif
 794:Src/util.c    ****   }
 795:Src/util.c    **** 
 796:Src/util.c    ****   return type;
 797:Src/util.c    **** }
 718              		.loc 1 797 1 view .LVU177
 719 005a 2046     		mov	r0, r4
 720 005c 10BD     		pop	{r4, pc}
 721              	.LVL36:
 722              	.L46:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 723              		.loc 1 769 10 view .LVU178
 724 005e 0024     		movs	r4, #0
 725 0060 FBE7     		b	.L42
 726              	.L47:
 727 0062 0024     		movs	r4, #0
 728 0064 F9E7     		b	.L42
 729              	.L48:
 730 0066 0024     		movs	r4, #0
 796:Src/util.c    **** }
 731              		.loc 1 796 3 is_stmt 1 view .LVU179
 796:Src/util.c    **** }
 732              		.loc 1 796 10 is_stmt 0 view .LVU180
 733 0068 F7E7     		b	.L42
 734              	.L53:
 735 006a 00BF     		.align	2
 736              	.L52:
 737 006c 1F85EB51 		.word	1374389535
 738              		.cfi_endproc
 739              	.LFE80:
 741              		.section	.rodata.Input_Init.str1.4,"aMS",%progbits,1
 742              		.align	2
 743              	.LC0:
 744 0000 4C696D69 		.ascii	"Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\015\012L"
ARM GAS  /tmp/cc14G55i.s 			page 28


 744      74732049 
 744      6E707574 
 744      313A2054 
 744      59503A25 
 745 002d 696D6974 		.ascii	"imits Input2: TYP:%i MIN:%i MID:%i MAX:%i\015\012\000"
 745      7320496E 
 745      70757432 
 745      3A205459 
 745      503A2569 
 746              		.section	.text.Input_Init,"ax",%progbits
 747              		.align	1
 748              		.global	Input_Init
 749              		.syntax unified
 750              		.thumb
 751              		.thumb_func
 752              		.fpu softvfp
 754              	Input_Init:
 755              	.LFB68:
 276:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 756              		.loc 1 276 23 is_stmt 1 view -0
 757              		.cfi_startproc
 758              		@ args = 0, pretend = 0, frame = 8
 759              		@ frame_needed = 0, uses_anonymous_args = 0
 760 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 761              	.LCFI6:
 762              		.cfi_def_cfa_offset 32
 763              		.cfi_offset 4, -32
 764              		.cfi_offset 5, -28
 765              		.cfi_offset 6, -24
 766              		.cfi_offset 7, -20
 767              		.cfi_offset 8, -16
 768              		.cfi_offset 9, -12
 769              		.cfi_offset 10, -8
 770              		.cfi_offset 14, -4
 771 0004 88B0     		sub	sp, sp, #32
 772              	.LCFI7:
 773              		.cfi_def_cfa_offset 64
 301:Src/util.c    ****     HAL_FLASH_Unlock();
 774              		.loc 1 301 5 view .LVU182
 302:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 775              		.loc 1 302 5 view .LVU183
 776 0006 FFF7FEFF 		bl	HAL_FLASH_Unlock
 777              	.LVL37:
 303:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 778              		.loc 1 303 5 view .LVU184
 779 000a FFF7FEFF 		bl	EE_Init
 780              	.LVL38:
 304:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 781              		.loc 1 304 5 view .LVU185
 782 000e 0DF11E01 		add	r1, sp, #30
 783 0012 7D4B     		ldr	r3, .L69
 784 0014 1888     		ldrh	r0, [r3]
 785 0016 FFF7FEFF 		bl	EE_ReadVariable
 786              	.LVL39:
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 787              		.loc 1 305 5 view .LVU186
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /tmp/cc14G55i.s 			page 29


 788              		.loc 1 305 20 is_stmt 0 view .LVU187
 789 001a BDF81E20 		ldrh	r2, [sp, #30]
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 790              		.loc 1 305 8 view .LVU188
 791 001e 41F20103 		movw	r3, #4097
 792 0022 9A42     		cmp	r2, r3
 793 0024 01D0     		beq	.L66
 794              	.LBB5:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 795              		.loc 1 331 20 view .LVU189
 796 0026 0025     		movs	r5, #0
 797 0028 CBE0     		b	.L55
 798              	.L66:
 799              	.LBE5:
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 800              		.loc 1 310 7 is_stmt 1 view .LVU190
 801 002a 774E     		ldr	r6, .L69
 802 002c 07A9     		add	r1, sp, #28
 803 002e 7088     		ldrh	r0, [r6, #2]
 804 0030 FFF7FEFF 		bl	EE_ReadVariable
 805              	.LVL40:
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 806              		.loc 1 310 53 view .LVU191
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 807              		.loc 1 310 88 is_stmt 0 view .LVU192
 808 0034 BDF91C30 		ldrsh	r3, [sp, #28]
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 809              		.loc 1 310 86 view .LVU193
 810 0038 744D     		ldr	r5, .L69+4
 811 003a A5F8CE30 		strh	r3, [r5, #206]	@ movhi
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 812              		.loc 1 310 68 view .LVU194
 813 003e 744C     		ldr	r4, .L69+8
 814 0040 A4F8CE30 		strh	r3, [r4, #206]	@ movhi
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 815              		.loc 1 311 7 is_stmt 1 view .LVU195
 816 0044 07A9     		add	r1, sp, #28
 817 0046 B088     		ldrh	r0, [r6, #4]
 818 0048 FFF7FEFF 		bl	EE_ReadVariable
 819              	.LVL41:
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 820              		.loc 1 311 53 view .LVU196
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 821              		.loc 1 311 88 is_stmt 0 view .LVU197
 822 004c BDF91C30 		ldrsh	r3, [sp, #28]
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 823              		.loc 1 311 86 view .LVU198
 824 0050 A5F8DA30 		strh	r3, [r5, #218]	@ movhi
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 825              		.loc 1 311 68 view .LVU199
 826 0054 A4F8DA30 		strh	r3, [r4, #218]	@ movhi
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 827              		.loc 1 312 7 is_stmt 1 view .LVU200
 828              	.LBB6:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 829              		.loc 1 312 12 view .LVU201
 830              	.LVL42:
ARM GAS  /tmp/cc14G55i.s 			page 30


 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 831              		.loc 1 312 20 is_stmt 0 view .LVU202
 832 0058 0026     		movs	r6, #0
 833              	.LVL43:
 834              	.L56:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 835              		.loc 1 312 25 is_stmt 1 discriminator 1 view .LVU203
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 836              		.loc 1 312 7 is_stmt 0 discriminator 1 view .LVU204
 837 005a 002E     		cmp	r6, #0
 838 005c 40F0B380 		bne	.L58
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 839              		.loc 1 313 9 is_stmt 1 discriminator 3 view .LVU205
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 840              		.loc 1 313 43 is_stmt 0 discriminator 3 view .LVU206
 841 0060 F400     		lsls	r4, r6, #3
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 842              		.loc 1 313 41 discriminator 3 view .LVU207
 843 0062 E31C     		adds	r3, r4, #3
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 844              		.loc 1 313 9 discriminator 3 view .LVU208
 845 0064 DFF8A081 		ldr	r8, .L69
 846 0068 07A9     		add	r1, sp, #28
 847 006a 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 848 006e FFF7FEFF 		bl	EE_ReadVariable
 849              	.LVL44:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 850              		.loc 1 313 60 is_stmt 1 discriminator 3 view .LVU209
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 851              		.loc 1 313 76 is_stmt 0 discriminator 3 view .LVU210
 852 0072 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 853              		.loc 1 313 74 discriminator 3 view .LVU211
 854 0076 A21B     		subs	r2, r4, r6
 855 0078 664D     		ldr	r5, .L69+12
 856 007a 05EB4205 		add	r5, r5, r2, lsl #1
 857 007e 2B71     		strb	r3, [r5, #4]
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 858              		.loc 1 314 9 is_stmt 1 discriminator 3 view .LVU212
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 859              		.loc 1 314 41 is_stmt 0 discriminator 3 view .LVU213
 860 0080 231D     		adds	r3, r4, #4
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 861              		.loc 1 314 9 discriminator 3 view .LVU214
 862 0082 07A9     		add	r1, sp, #28
 863 0084 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 864 0088 FFF7FEFF 		bl	EE_ReadVariable
 865              	.LVL45:
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 866              		.loc 1 314 60 is_stmt 1 discriminator 3 view .LVU215
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 867              		.loc 1 314 76 is_stmt 0 discriminator 3 view .LVU216
 868 008c BDF91C30 		ldrsh	r3, [sp, #28]
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 869              		.loc 1 314 74 discriminator 3 view .LVU217
 870 0090 EB80     		strh	r3, [r5, #6]	@ movhi
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
ARM GAS  /tmp/cc14G55i.s 			page 31


 871              		.loc 1 315 9 is_stmt 1 discriminator 3 view .LVU218
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 872              		.loc 1 315 41 is_stmt 0 discriminator 3 view .LVU219
 873 0092 631D     		adds	r3, r4, #5
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 874              		.loc 1 315 9 discriminator 3 view .LVU220
 875 0094 07A9     		add	r1, sp, #28
 876 0096 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 877 009a FFF7FEFF 		bl	EE_ReadVariable
 878              	.LVL46:
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 879              		.loc 1 315 60 is_stmt 1 discriminator 3 view .LVU221
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 880              		.loc 1 315 76 is_stmt 0 discriminator 3 view .LVU222
 881 009e BDF91C30 		ldrsh	r3, [sp, #28]
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 882              		.loc 1 315 74 discriminator 3 view .LVU223
 883 00a2 2B81     		strh	r3, [r5, #8]	@ movhi
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 884              		.loc 1 316 9 is_stmt 1 discriminator 3 view .LVU224
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 885              		.loc 1 316 41 is_stmt 0 discriminator 3 view .LVU225
 886 00a4 A31D     		adds	r3, r4, #6
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 887              		.loc 1 316 9 discriminator 3 view .LVU226
 888 00a6 07A9     		add	r1, sp, #28
 889 00a8 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 890 00ac FFF7FEFF 		bl	EE_ReadVariable
 891              	.LVL47:
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 892              		.loc 1 316 60 is_stmt 1 discriminator 3 view .LVU227
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 893              		.loc 1 316 76 is_stmt 0 discriminator 3 view .LVU228
 894 00b0 BDF91C30 		ldrsh	r3, [sp, #28]
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 895              		.loc 1 316 74 discriminator 3 view .LVU229
 896 00b4 6B81     		strh	r3, [r5, #10]	@ movhi
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 897              		.loc 1 317 9 is_stmt 1 discriminator 3 view .LVU230
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 898              		.loc 1 317 41 is_stmt 0 discriminator 3 view .LVU231
 899 00b6 E31D     		adds	r3, r4, #7
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 900              		.loc 1 317 9 discriminator 3 view .LVU232
 901 00b8 07A9     		add	r1, sp, #28
 902 00ba 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 903 00be FFF7FEFF 		bl	EE_ReadVariable
 904              	.LVL48:
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 905              		.loc 1 317 60 is_stmt 1 discriminator 3 view .LVU233
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 906              		.loc 1 317 76 is_stmt 0 discriminator 3 view .LVU234
 907 00c2 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 908              		.loc 1 317 74 discriminator 3 view .LVU235
 909 00c6 DFF85091 		ldr	r9, .L69+16
 910 00ca A71B     		subs	r7, r4, r6
ARM GAS  /tmp/cc14G55i.s 			page 32


 911 00cc 09EB4707 		add	r7, r9, r7, lsl #1
 912 00d0 3B71     		strb	r3, [r7, #4]
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 913              		.loc 1 318 9 is_stmt 1 discriminator 3 view .LVU236
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 914              		.loc 1 318 41 is_stmt 0 discriminator 3 view .LVU237
 915 00d2 06F1010A 		add	r10, r6, #1
 916 00d6 4FEACA03 		lsl	r3, r10, #3
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 917              		.loc 1 318 9 discriminator 3 view .LVU238
 918 00da 07A9     		add	r1, sp, #28
 919 00dc 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 920 00e0 FFF7FEFF 		bl	EE_ReadVariable
 921              	.LVL49:
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 922              		.loc 1 318 60 is_stmt 1 discriminator 3 view .LVU239
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 923              		.loc 1 318 76 is_stmt 0 discriminator 3 view .LVU240
 924 00e4 BDF91C30 		ldrsh	r3, [sp, #28]
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 925              		.loc 1 318 74 discriminator 3 view .LVU241
 926 00e8 FB80     		strh	r3, [r7, #6]	@ movhi
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 927              		.loc 1 319 9 is_stmt 1 discriminator 3 view .LVU242
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 928              		.loc 1 319 41 is_stmt 0 discriminator 3 view .LVU243
 929 00ea 04F10903 		add	r3, r4, #9
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 930              		.loc 1 319 9 discriminator 3 view .LVU244
 931 00ee 07A9     		add	r1, sp, #28
 932 00f0 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 933 00f4 FFF7FEFF 		bl	EE_ReadVariable
 934              	.LVL50:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 935              		.loc 1 319 60 is_stmt 1 discriminator 3 view .LVU245
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 936              		.loc 1 319 76 is_stmt 0 discriminator 3 view .LVU246
 937 00f8 BDF91C30 		ldrsh	r3, [sp, #28]
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 938              		.loc 1 319 74 discriminator 3 view .LVU247
 939 00fc 3B81     		strh	r3, [r7, #8]	@ movhi
 320:Src/util.c    ****       
 940              		.loc 1 320 9 is_stmt 1 discriminator 3 view .LVU248
 320:Src/util.c    ****       
 941              		.loc 1 320 41 is_stmt 0 discriminator 3 view .LVU249
 942 00fe 04F10A03 		add	r3, r4, #10
 320:Src/util.c    ****       
 943              		.loc 1 320 9 discriminator 3 view .LVU250
 944 0102 07A9     		add	r1, sp, #28
 945 0104 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 946 0108 FFF7FEFF 		bl	EE_ReadVariable
 947              	.LVL51:
 320:Src/util.c    ****       
 948              		.loc 1 320 60 is_stmt 1 discriminator 3 view .LVU251
 320:Src/util.c    ****       
 949              		.loc 1 320 76 is_stmt 0 discriminator 3 view .LVU252
 950 010c BDF91C30 		ldrsh	r3, [sp, #28]
ARM GAS  /tmp/cc14G55i.s 			page 33


 320:Src/util.c    ****       
 951              		.loc 1 320 74 discriminator 3 view .LVU253
 952 0110 7B81     		strh	r3, [r7, #10]	@ movhi
 322:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 953              		.loc 1 322 9 is_stmt 1 discriminator 3 view .LVU254
 323:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 954              		.loc 1 323 65 is_stmt 0 discriminator 3 view .LVU255
 955 0112 B5F90A20 		ldrsh	r2, [r5, #10]
 324:Src/util.c    ****       }
 956              		.loc 1 324 20 discriminator 3 view .LVU256
 957 0116 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 324:Src/util.c    ****       }
 958              		.loc 1 324 35 discriminator 3 view .LVU257
 959 0118 B7F90600 		ldrsh	r0, [r7, #6]
 324:Src/util.c    ****       }
 960              		.loc 1 324 50 discriminator 3 view .LVU258
 961 011c B7F90840 		ldrsh	r4, [r7, #8]
 322:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 962              		.loc 1 322 9 discriminator 3 view .LVU259
 963 0120 0493     		str	r3, [sp, #16]
 964 0122 0394     		str	r4, [sp, #12]
 965 0124 0290     		str	r0, [sp, #8]
 966 0126 0191     		str	r1, [sp, #4]
 967 0128 0092     		str	r2, [sp]
 968 012a B5F90830 		ldrsh	r3, [r5, #8]
 969 012e B5F90620 		ldrsh	r2, [r5, #6]
 970 0132 2979     		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 971 0134 3948     		ldr	r0, .L69+20
 972 0136 FFF7FEFF 		bl	printf
 973              	.LVL52:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 974              		.loc 1 312 38 is_stmt 1 discriminator 3 view .LVU260
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 975              		.loc 1 312 39 is_stmt 0 discriminator 3 view .LVU261
 976 013a 5FFA8AF6 		uxtb	r6, r10
 977              	.LVL53:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 978              		.loc 1 312 39 discriminator 3 view .LVU262
 979 013e 8CE7     		b	.L56
 980              	.LVL54:
 981              	.L63:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 982              		.loc 1 312 39 discriminator 3 view .LVU263
 983              	.LBE6:
 984              	.LBB7:
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 985              		.loc 1 332 9 is_stmt 1 view .LVU264
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 986              		.loc 1 332 22 is_stmt 0 view .LVU265
 987 0140 2C46     		mov	r4, r5
 988 0142 C5EBC503 		rsb	r3, r5, r5, lsl #3
 989 0146 334A     		ldr	r2, .L69+12
 990 0148 02EB4303 		add	r3, r2, r3, lsl #1
 991 014c 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 992              		.loc 1 332 12 view .LVU266
 993 014e 0329     		cmp	r1, #3
ARM GAS  /tmp/cc14G55i.s 			page 34


 994 0150 3ED0     		beq	.L67
 335:Src/util.c    ****         }
 995              		.loc 1 335 11 is_stmt 1 view .LVU267
 335:Src/util.c    ****         }
 996              		.loc 1 335 25 is_stmt 0 view .LVU268
 997 0152 C5EBC503 		rsb	r3, r5, r5, lsl #3
 998 0156 2F4A     		ldr	r2, .L69+12
 999 0158 02EB4303 		add	r3, r2, r3, lsl #1
 1000 015c 1971     		strb	r1, [r3, #4]
 1001              	.L60:
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1002              		.loc 1 337 9 is_stmt 1 view .LVU269
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1003              		.loc 1 337 22 is_stmt 0 view .LVU270
 1004 015e C4EBC403 		rsb	r3, r4, r4, lsl #3
 1005 0162 2D4A     		ldr	r2, .L69+16
 1006 0164 02EB4303 		add	r3, r2, r3, lsl #1
 1007 0168 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1008              		.loc 1 337 12 view .LVU271
 1009 016a 0329     		cmp	r1, #3
 1010 016c 3ED0     		beq	.L68
 340:Src/util.c    ****         }
 1011              		.loc 1 340 11 is_stmt 1 view .LVU272
 340:Src/util.c    ****         }
 1012              		.loc 1 340 25 is_stmt 0 view .LVU273
 1013 016e C4EBC403 		rsb	r3, r4, r4, lsl #3
 1014 0172 294A     		ldr	r2, .L69+16
 1015 0174 02EB4303 		add	r3, r2, r3, lsl #1
 1016 0178 1971     		strb	r1, [r3, #4]
 1017              	.L62:
 342:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1018              		.loc 1 342 9 is_stmt 1 discriminator 2 view .LVU274
 343:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1019              		.loc 1 343 20 is_stmt 0 discriminator 2 view .LVU275
 1020 017a C4EBC403 		rsb	r3, r4, r4, lsl #3
 1021 017e 2549     		ldr	r1, .L69+12
 1022 0180 01EB4301 		add	r1, r1, r3, lsl #1
 343:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1023              		.loc 1 343 65 discriminator 2 view .LVU276
 1024 0184 B1F90A00 		ldrsh	r0, [r1, #10]
 344:Src/util.c    ****       }
 1025              		.loc 1 344 20 discriminator 2 view .LVU277
 1026 0188 234A     		ldr	r2, .L69+16
 1027 018a 02EB4303 		add	r3, r2, r3, lsl #1
 1028 018e 1E79     		ldrb	r6, [r3, #4]	@ zero_extendqisi2
 344:Src/util.c    ****       }
 1029              		.loc 1 344 35 discriminator 2 view .LVU278
 1030 0190 B3F90670 		ldrsh	r7, [r3, #6]
 344:Src/util.c    ****       }
 1031              		.loc 1 344 50 discriminator 2 view .LVU279
 1032 0194 B3F90830 		ldrsh	r3, [r3, #8]
 344:Src/util.c    ****       }
 1033              		.loc 1 344 65 discriminator 2 view .LVU280
 1034 0198 C4EBC404 		rsb	r4, r4, r4, lsl #3
 1035 019c 02EB4404 		add	r4, r2, r4, lsl #1
 1036 01a0 B4F90A20 		ldrsh	r2, [r4, #10]
ARM GAS  /tmp/cc14G55i.s 			page 35


 342:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1037              		.loc 1 342 9 discriminator 2 view .LVU281
 1038 01a4 0492     		str	r2, [sp, #16]
 1039 01a6 0393     		str	r3, [sp, #12]
 1040 01a8 0297     		str	r7, [sp, #8]
 1041 01aa 0196     		str	r6, [sp, #4]
 1042 01ac 0090     		str	r0, [sp]
 1043 01ae B1F90830 		ldrsh	r3, [r1, #8]
 1044 01b2 B1F90620 		ldrsh	r2, [r1, #6]
 1045 01b6 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 1046 01b8 1848     		ldr	r0, .L69+20
 1047 01ba FFF7FEFF 		bl	printf
 1048              	.LVL55:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1049              		.loc 1 331 38 is_stmt 1 discriminator 2 view .LVU282
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1050              		.loc 1 331 39 is_stmt 0 discriminator 2 view .LVU283
 1051 01be 0135     		adds	r5, r5, #1
 1052              	.LVL56:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1053              		.loc 1 331 39 discriminator 2 view .LVU284
 1054 01c0 EDB2     		uxtb	r5, r5
 1055              	.LVL57:
 1056              	.L55:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1057              		.loc 1 331 25 is_stmt 1 discriminator 1 view .LVU285
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1058              		.loc 1 331 7 is_stmt 0 discriminator 1 view .LVU286
 1059 01c2 002D     		cmp	r5, #0
 1060 01c4 BCD0     		beq	.L63
 1061              	.LVL58:
 1062              	.L58:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1063              		.loc 1 331 7 discriminator 1 view .LVU287
 1064              	.LBE7:
 347:Src/util.c    ****   #endif
 1065              		.loc 1 347 5 is_stmt 1 view .LVU288
 1066 01c6 FFF7FEFF 		bl	HAL_FLASH_Lock
 1067              	.LVL59:
 399:Src/util.c    **** 
 1068              		.loc 1 399 1 is_stmt 0 view .LVU289
 1069 01ca 08B0     		add	sp, sp, #32
 1070              	.LCFI8:
 1071              		.cfi_remember_state
 1072              		.cfi_def_cfa_offset 32
 1073              		@ sp needed
 1074 01cc BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1075              	.LVL60:
 1076              	.L67:
 1077              	.LCFI9:
 1078              		.cfi_restore_state
 1079              	.LBB8:
 333:Src/util.c    ****         } else {
 1080              		.loc 1 333 11 is_stmt 1 view .LVU290
 333:Src/util.c    ****         } else {
 1081              		.loc 1 333 27 is_stmt 0 view .LVU291
 1082 01d0 C5EBC506 		rsb	r6, r5, r5, lsl #3
ARM GAS  /tmp/cc14G55i.s 			page 36


 1083 01d4 02EB4606 		add	r6, r2, r6, lsl #1
 1084 01d8 B6F90A20 		ldrsh	r2, [r6, #10]
 1085 01dc B6F90810 		ldrsh	r1, [r6, #8]
 1086 01e0 B6F90600 		ldrsh	r0, [r6, #6]
 1087 01e4 FFF7FEFF 		bl	checkInputType
 1088              	.LVL61:
 333:Src/util.c    ****         } else {
 1089              		.loc 1 333 25 view .LVU292
 1090 01e8 3071     		strb	r0, [r6, #4]
 1091 01ea B8E7     		b	.L60
 1092              	.L68:
 338:Src/util.c    ****         } else {
 1093              		.loc 1 338 11 is_stmt 1 view .LVU293
 338:Src/util.c    ****         } else {
 1094              		.loc 1 338 27 is_stmt 0 view .LVU294
 1095 01ec C4EBC406 		rsb	r6, r4, r4, lsl #3
 1096 01f0 02EB4606 		add	r6, r2, r6, lsl #1
 1097 01f4 B6F90A20 		ldrsh	r2, [r6, #10]
 1098 01f8 B6F90810 		ldrsh	r1, [r6, #8]
 1099 01fc B6F90600 		ldrsh	r0, [r6, #6]
 1100 0200 FFF7FEFF 		bl	checkInputType
 1101              	.LVL62:
 338:Src/util.c    ****         } else {
 1102              		.loc 1 338 25 view .LVU295
 1103 0204 3071     		strb	r0, [r6, #4]
 1104 0206 B8E7     		b	.L62
 1105              	.L70:
 1106              		.align	2
 1107              	.L69:
 1108 0208 00000000 		.word	.LANCHOR13
 1109 020c 00000000 		.word	.LANCHOR0
 1110 0210 00000000 		.word	rtP_Left
 1111 0214 00000000 		.word	.LANCHOR14
 1112 0218 00000000 		.word	.LANCHOR15
 1113 021c 00000000 		.word	.LC0
 1114              	.LBE8:
 1115              		.cfi_endproc
 1116              	.LFE68:
 1118              		.section	.text.calcInputCmd,"ax",%progbits
 1119              		.align	1
 1120              		.global	calcInputCmd
 1121              		.syntax unified
 1122              		.thumb
 1123              		.thumb_func
 1124              		.fpu softvfp
 1126              	calcInputCmd:
 1127              	.LVL63:
 1128              	.LFB81:
 798:Src/util.c    **** 
 799:Src/util.c    **** 
 800:Src/util.c    **** 
 801:Src/util.c    **** /* =========================== Input Functions =========================== */
 802:Src/util.c    **** 
 803:Src/util.c    ****  /*
 804:Src/util.c    ****  * Calculate Input Command
 805:Src/util.c    ****  * This function realizes dead-band around 0 and scales the input between [out_min, out_max]
 806:Src/util.c    ****  */
ARM GAS  /tmp/cc14G55i.s 			page 37


 807:Src/util.c    **** void calcInputCmd(InputStruct *in, int16_t out_min, int16_t out_max) {
 1129              		.loc 1 807 70 is_stmt 1 view -0
 1130              		.cfi_startproc
 1131              		@ args = 0, pretend = 0, frame = 0
 1132              		@ frame_needed = 0, uses_anonymous_args = 0
 808:Src/util.c    ****   switch (in->typ){
 1133              		.loc 1 808 3 view .LVU297
 1134              		.loc 1 808 13 is_stmt 0 view .LVU298
 1135 0000 90F804C0 		ldrb	ip, [r0, #4]	@ zero_extendqisi2
 1136              		.loc 1 808 3 view .LVU299
 1137 0004 BCF1010F 		cmp	ip, #1
 1138 0008 05D0     		beq	.L72
 1139 000a BCF1020F 		cmp	ip, #2
 1140 000e 17D0     		beq	.L73
 809:Src/util.c    ****     case 1: // Input is a normal pot
 810:Src/util.c    ****       in->cmd = CLAMP(MAP(in->raw, in->min, in->max, 0, out_max), 0, out_max);
 811:Src/util.c    ****       break;
 812:Src/util.c    ****     case 2: // Input is a mid resting pot
 813:Src/util.c    ****       if( in->raw > in->mid - in->dband && in->raw < in->mid + in->dband ) {
 814:Src/util.c    ****         in->cmd = 0;
 815:Src/util.c    ****       } else if(in->raw > in->mid) {
 816:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 817:Src/util.c    ****       } else {
 818:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid - in->dband, in->min, 0, out_min), out_min, 0);
 819:Src/util.c    ****       }
 820:Src/util.c    ****       break;
 821:Src/util.c    ****     default: // Input is ignored
 822:Src/util.c    ****       in->cmd = 0;
 1141              		.loc 1 822 7 is_stmt 1 view .LVU300
 1142              		.loc 1 822 15 is_stmt 0 view .LVU301
 1143 0010 0023     		movs	r3, #0
 1144 0012 4380     		strh	r3, [r0, #2]	@ movhi
 823:Src/util.c    ****       break;
 1145              		.loc 1 823 7 is_stmt 1 view .LVU302
 1146 0014 7047     		bx	lr
 1147              	.L72:
 810:Src/util.c    ****       break;
 1148              		.loc 1 810 7 view .LVU303
 810:Src/util.c    ****       break;
 1149              		.loc 1 810 17 is_stmt 0 view .LVU304
 1150 0016 B0F90030 		ldrsh	r3, [r0]
 1151 001a B0F906C0 		ldrsh	ip, [r0, #6]
 1152 001e A3EB0C03 		sub	r3, r3, ip
 1153 0022 02FB03F3 		mul	r3, r2, r3
 1154 0026 B0F90A10 		ldrsh	r1, [r0, #10]
 1155              	.LVL64:
 810:Src/util.c    ****       break;
 1156              		.loc 1 810 17 view .LVU305
 1157 002a A1EB0C01 		sub	r1, r1, ip
 1158 002e 93FBF1F3 		sdiv	r3, r3, r1
 810:Src/util.c    ****       break;
 1159              		.loc 1 810 15 view .LVU306
 1160 0032 9A42     		cmp	r2, r3
 1161 0034 02DB     		blt	.L75
 810:Src/util.c    ****       break;
 1162              		.loc 1 810 17 discriminator 1 view .LVU307
 1163 0036 23EAE372 		bic	r2, r3, r3, asr #31
ARM GAS  /tmp/cc14G55i.s 			page 38


 1164              	.LVL65:
 810:Src/util.c    ****       break;
 1165              		.loc 1 810 15 discriminator 1 view .LVU308
 1166 003a 12B2     		sxth	r2, r2
 1167              	.L75:
 810:Src/util.c    ****       break;
 1168              		.loc 1 810 15 discriminator 4 view .LVU309
 1169 003c 4280     		strh	r2, [r0, #2]	@ movhi
 811:Src/util.c    ****     case 2: // Input is a mid resting pot
 1170              		.loc 1 811 7 is_stmt 1 discriminator 4 view .LVU310
 1171 003e 7047     		bx	lr
 1172              	.LVL66:
 1173              	.L73:
 807:Src/util.c    ****   switch (in->typ){
 1174              		.loc 1 807 70 is_stmt 0 view .LVU311
 1175 0040 30B5     		push	{r4, r5, lr}
 1176              	.LCFI10:
 1177              		.cfi_def_cfa_offset 12
 1178              		.cfi_offset 4, -12
 1179              		.cfi_offset 5, -8
 1180              		.cfi_offset 14, -4
 813:Src/util.c    ****         in->cmd = 0;
 1181              		.loc 1 813 7 is_stmt 1 view .LVU312
 813:Src/util.c    ****         in->cmd = 0;
 1182              		.loc 1 813 13 is_stmt 0 view .LVU313
 1183 0042 B0F90030 		ldrsh	r3, [r0]
 813:Src/util.c    ****         in->cmd = 0;
 1184              		.loc 1 813 23 view .LVU314
 1185 0046 B0F908C0 		ldrsh	ip, [r0, #8]
 813:Src/util.c    ****         in->cmd = 0;
 1186              		.loc 1 813 33 view .LVU315
 1187 004a B0F90CE0 		ldrsh	lr, [r0, #12]
 813:Src/util.c    ****         in->cmd = 0;
 1188              		.loc 1 813 29 view .LVU316
 1189 004e ACEB0E04 		sub	r4, ip, lr
 813:Src/util.c    ****         in->cmd = 0;
 1190              		.loc 1 813 9 view .LVU317
 1191 0052 A342     		cmp	r3, r4
 1192 0054 06DD     		ble	.L77
 813:Src/util.c    ****         in->cmd = 0;
 1193              		.loc 1 813 62 discriminator 1 view .LVU318
 1194 0056 0CEB0E05 		add	r5, ip, lr
 813:Src/util.c    ****         in->cmd = 0;
 1195              		.loc 1 813 41 discriminator 1 view .LVU319
 1196 005a AB42     		cmp	r3, r5
 1197 005c 02DA     		bge	.L77
 814:Src/util.c    ****       } else if(in->raw > in->mid) {
 1198              		.loc 1 814 9 is_stmt 1 view .LVU320
 814:Src/util.c    ****       } else if(in->raw > in->mid) {
 1199              		.loc 1 814 17 is_stmt 0 view .LVU321
 1200 005e 0023     		movs	r3, #0
 1201 0060 4380     		strh	r3, [r0, #2]	@ movhi
 1202 0062 12E0     		b	.L71
 1203              	.L77:
 815:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1204              		.loc 1 815 14 is_stmt 1 view .LVU322
 815:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
ARM GAS  /tmp/cc14G55i.s 			page 39


 1205              		.loc 1 815 16 is_stmt 0 view .LVU323
 1206 0064 6345     		cmp	r3, ip
 1207 0066 11DD     		ble	.L78
 816:Src/util.c    ****       } else {
 1208              		.loc 1 816 9 is_stmt 1 view .LVU324
 816:Src/util.c    ****       } else {
 1209              		.loc 1 816 19 is_stmt 0 view .LVU325
 1210 0068 F444     		add	ip, ip, lr
 1211 006a A3EB0C03 		sub	r3, r3, ip
 1212 006e 02FB03F3 		mul	r3, r2, r3
 1213 0072 B0F90A10 		ldrsh	r1, [r0, #10]
 1214              	.LVL67:
 816:Src/util.c    ****       } else {
 1215              		.loc 1 816 19 view .LVU326
 1216 0076 A1EB0C0C 		sub	ip, r1, ip
 1217 007a 93FBFCF3 		sdiv	r3, r3, ip
 816:Src/util.c    ****       } else {
 1218              		.loc 1 816 17 view .LVU327
 1219 007e 9A42     		cmp	r2, r3
 1220 0080 02DB     		blt	.L79
 816:Src/util.c    ****       } else {
 1221              		.loc 1 816 19 discriminator 1 view .LVU328
 1222 0082 23EAE372 		bic	r2, r3, r3, asr #31
 1223              	.LVL68:
 816:Src/util.c    ****       } else {
 1224              		.loc 1 816 17 discriminator 1 view .LVU329
 1225 0086 12B2     		sxth	r2, r2
 1226              	.L79:
 816:Src/util.c    ****       } else {
 1227              		.loc 1 816 17 discriminator 4 view .LVU330
 1228 0088 4280     		strh	r2, [r0, #2]	@ movhi
 1229              	.L71:
 824:Src/util.c    ****   }
 825:Src/util.c    **** }
 1230              		.loc 1 825 1 view .LVU331
 1231 008a 30BD     		pop	{r4, r5, pc}
 1232              	.LVL69:
 1233              	.L78:
 818:Src/util.c    ****       }
 1234              		.loc 1 818 9 is_stmt 1 view .LVU332
 818:Src/util.c    ****       }
 1235              		.loc 1 818 19 is_stmt 0 view .LVU333
 1236 008c 1B1B     		subs	r3, r3, r4
 1237 008e 01FB03F3 		mul	r3, r1, r3
 1238 0092 B0F90620 		ldrsh	r2, [r0, #6]
 1239              	.LVL70:
 818:Src/util.c    ****       }
 1240              		.loc 1 818 19 view .LVU334
 1241 0096 141B     		subs	r4, r2, r4
 1242 0098 93FBF4F3 		sdiv	r3, r3, r4
 818:Src/util.c    ****       }
 1243              		.loc 1 818 17 view .LVU335
 1244 009c 002B     		cmp	r3, #0
 1245 009e 02DD     		ble	.L86
 1246 00a0 0021     		movs	r1, #0
 1247              	.LVL71:
 1248              	.L80:
ARM GAS  /tmp/cc14G55i.s 			page 40


 818:Src/util.c    ****       }
 1249              		.loc 1 818 17 discriminator 4 view .LVU336
 1250 00a2 4180     		strh	r1, [r0, #2]	@ movhi
 1251 00a4 F1E7     		b	.L71
 1252              	.LVL72:
 1253              	.L86:
 818:Src/util.c    ****       }
 1254              		.loc 1 818 19 discriminator 1 view .LVU337
 1255 00a6 9942     		cmp	r1, r3
 1256 00a8 B8BF     		it	lt
 1257 00aa 1946     		movlt	r1, r3
 1258              	.LVL73:
 818:Src/util.c    ****       }
 1259              		.loc 1 818 17 discriminator 1 view .LVU338
 1260 00ac 09B2     		sxth	r1, r1
 1261 00ae F8E7     		b	.L80
 1262              		.cfi_endproc
 1263              	.LFE81:
 1265              		.section	.text.readInputRaw,"ax",%progbits
 1266              		.align	1
 1267              		.global	readInputRaw
 1268              		.syntax unified
 1269              		.thumb
 1270              		.thumb_func
 1271              		.fpu softvfp
 1273              	readInputRaw:
 1274              	.LFB82:
 826:Src/util.c    **** 
 827:Src/util.c    ****  /*
 828:Src/util.c    ****  * Function to read the Input Raw values from various input devices
 829:Src/util.c    ****  */
 830:Src/util.c    **** void readInputRaw(void) {
 1275              		.loc 1 830 25 is_stmt 1 view -0
 1276              		.cfi_startproc
 1277              		@ args = 0, pretend = 0, frame = 0
 1278              		@ frame_needed = 0, uses_anonymous_args = 0
 1279              		@ link register save eliminated.
 831:Src/util.c    ****     #ifdef CONTROL_ADC
 832:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 1280              		.loc 1 832 5 view .LVU340
 1281              		.loc 1 832 15 is_stmt 0 view .LVU341
 1282 0000 094B     		ldr	r3, .L89
 1283 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1284              		.loc 1 832 8 view .LVU342
 1285 0004 73B9     		cbnz	r3, .L87
 833:Src/util.c    ****       #ifdef ADC_ALTERNATE_CONNECT
 834:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_rx2;
 835:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_tx2;
 836:Src/util.c    ****       #else
 837:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_tx2;
 1286              		.loc 1 837 9 is_stmt 1 view .LVU343
 1287              		.loc 1 837 39 is_stmt 0 view .LVU344
 1288 0006 094A     		ldr	r2, .L89+4
 1289 0008 B2F80EC0 		ldrh	ip, [r2, #14]
 1290              		.loc 1 837 27 view .LVU345
 1291 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1292 0010 4100     		lsls	r1, r0, #1
ARM GAS  /tmp/cc14G55i.s 			page 41


 1293 0012 0748     		ldr	r0, .L89+8
 1294 0014 20F801C0 		strh	ip, [r0, r1]	@ movhi
 838:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_rx2;
 1295              		.loc 1 838 9 is_stmt 1 view .LVU346
 1296              		.loc 1 838 39 is_stmt 0 view .LVU347
 1297 0018 518A     		ldrh	r1, [r2, #18]
 1298              		.loc 1 838 27 view .LVU348
 1299 001a C3EBC303 		rsb	r3, r3, r3, lsl #3
 1300 001e 5A00     		lsls	r2, r3, #1
 1301 0020 044B     		ldr	r3, .L89+12
 1302 0022 9952     		strh	r1, [r3, r2]	@ movhi
 1303              	.L87:
 839:Src/util.c    ****       #endif
 840:Src/util.c    ****     }
 841:Src/util.c    ****     #endif
 842:Src/util.c    **** 
 843:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 844:Src/util.c    ****     if (Nunchuk_Read() == NUNCHUK_CONNECTED) {
 845:Src/util.c    ****       if (inIdx == CONTROL_NUNCHUK) {
 846:Src/util.c    ****         input1[inIdx].raw = (nunchuk_data[0] - 127) * 8; // X axis 0-255
 847:Src/util.c    ****         input2[inIdx].raw = (nunchuk_data[1] - 128) * 8; // Y axis 0-255
 848:Src/util.c    ****       }
 849:Src/util.c    ****       #ifdef SUPPORT_BUTTONS
 850:Src/util.c    ****         button1 = (uint8_t)nunchuk_data[5] & 1;
 851:Src/util.c    ****         button2 = (uint8_t)(nunchuk_data[5] >> 1) & 1;
 852:Src/util.c    ****       #endif
 853:Src/util.c    ****     }
 854:Src/util.c    ****     #endif
 855:Src/util.c    **** 
 856:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2)
 857:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART2) {
 858:Src/util.c    ****       #ifdef CONTROL_IBUS
 859:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 860:Src/util.c    ****           ibusL_captured_value[(i/2)] = CLAMP(commandL.channels[i] + (commandL.channels[i+1] << 8) 
 861:Src/util.c    ****         }
 862:Src/util.c    ****         input1[inIdx].raw = (ibusL_captured_value[0] - 500) * 2;
 863:Src/util.c    ****         input2[inIdx].raw = (ibusL_captured_value[1] - 500) * 2; 
 864:Src/util.c    ****       #else
 865:Src/util.c    ****         input1[inIdx].raw = commandL.steer;
 866:Src/util.c    ****         input2[inIdx].raw = commandL.speed;
 867:Src/util.c    ****       #endif
 868:Src/util.c    ****     }
 869:Src/util.c    ****     #endif
 870:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3)
 871:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART3) {
 872:Src/util.c    ****       #ifdef CONTROL_IBUS
 873:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 874:Src/util.c    ****           ibusR_captured_value[(i/2)] = CLAMP(commandR.channels[i] + (commandR.channels[i+1] << 8) 
 875:Src/util.c    ****         }
 876:Src/util.c    ****         input1[inIdx].raw = (ibusR_captured_value[0] - 500) * 2;
 877:Src/util.c    ****         input2[inIdx].raw = (ibusR_captured_value[1] - 500) * 2; 
 878:Src/util.c    ****       #else
 879:Src/util.c    ****         input1[inIdx].raw = commandR.steer;
 880:Src/util.c    ****         input2[inIdx].raw = commandR.speed;
 881:Src/util.c    ****       #endif
 882:Src/util.c    ****     }
 883:Src/util.c    ****     #endif
ARM GAS  /tmp/cc14G55i.s 			page 42


 884:Src/util.c    **** 
 885:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
 886:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART2) {
 887:Src/util.c    ****       input1[inIdx].raw = Sideboard_L.cmd1;
 888:Src/util.c    ****       input2[inIdx].raw = Sideboard_L.cmd2;
 889:Src/util.c    ****     }
 890:Src/util.c    ****     #endif
 891:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART3)
 892:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART3) {
 893:Src/util.c    ****       input1[inIdx].raw = Sideboard_R.cmd1;
 894:Src/util.c    ****       input2[inIdx].raw = Sideboard_R.cmd2;
 895:Src/util.c    ****     }
 896:Src/util.c    ****     #endif
 897:Src/util.c    **** 
 898:Src/util.c    ****     #if defined(CONTROL_PPM_LEFT)
 899:Src/util.c    ****     if (inIdx == CONTROL_PPM_LEFT) {
 900:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 901:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 902:Src/util.c    ****     }
 903:Src/util.c    ****     #endif
 904:Src/util.c    ****     #if defined(CONTROL_PPM_RIGHT)
 905:Src/util.c    ****     if (inIdx == CONTROL_PPM_RIGHT) {
 906:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 907:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 908:Src/util.c    ****     }
 909:Src/util.c    ****     #endif
 910:Src/util.c    ****     #if (defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)) && defined(SUPPORT_BUTTONS)
 911:Src/util.c    ****       button1 = ppm_captured_value[5] > 500;
 912:Src/util.c    ****       button2 = 0;
 913:Src/util.c    ****     #endif
 914:Src/util.c    **** 
 915:Src/util.c    ****     #if defined(CONTROL_PWM_LEFT)
 916:Src/util.c    ****     if (inIdx == CONTROL_PWM_LEFT) {
 917:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 918:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 919:Src/util.c    ****     }
 920:Src/util.c    ****     #endif
 921:Src/util.c    ****     #if defined(CONTROL_PWM_RIGHT)
 922:Src/util.c    ****     if (inIdx == CONTROL_PWM_RIGHT) {
 923:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 924:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 925:Src/util.c    ****     }
 926:Src/util.c    ****     #endif
 927:Src/util.c    **** 
 928:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 929:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_NORMAL
 930:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_rx2;
 931:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_tx2;
 932:Src/util.c    ****       #endif
 933:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_ALTERNATE
 934:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_tx2;
 935:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_rx2;
 936:Src/util.c    ****       #endif
 937:Src/util.c    ****     #endif
 938:Src/util.c    **** }
 1304              		.loc 1 938 1 view .LVU349
 1305 0024 7047     		bx	lr
ARM GAS  /tmp/cc14G55i.s 			page 43


 1306              	.L90:
 1307 0026 00BF     		.align	2
 1308              	.L89:
 1309 0028 00000000 		.word	.LANCHOR16
 1310 002c 00000000 		.word	adc_buffer
 1311 0030 00000000 		.word	.LANCHOR14
 1312 0034 00000000 		.word	.LANCHOR15
 1313              		.cfi_endproc
 1314              	.LFE82:
 1316              		.section	.text.handleTimeout,"ax",%progbits
 1317              		.align	1
 1318              		.global	handleTimeout
 1319              		.syntax unified
 1320              		.thumb
 1321              		.thumb_func
 1322              		.fpu softvfp
 1324              	handleTimeout:
 1325              	.LFB83:
 939:Src/util.c    **** 
 940:Src/util.c    ****  /*
 941:Src/util.c    ****  * Function to handle the ADC, UART and General timeout (Nunchuk, PPM, PWM)
 942:Src/util.c    ****  */
 943:Src/util.c    **** void handleTimeout(void) {
 1326              		.loc 1 943 26 is_stmt 1 view -0
 1327              		.cfi_startproc
 1328              		@ args = 0, pretend = 0, frame = 0
 1329              		@ frame_needed = 0, uses_anonymous_args = 0
 1330 0000 08B5     		push	{r3, lr}
 1331              	.LCFI11:
 1332              		.cfi_def_cfa_offset 8
 1333              		.cfi_offset 3, -8
 1334              		.cfi_offset 14, -4
 944:Src/util.c    ****     #ifdef CONTROL_ADC
 945:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 1335              		.loc 1 945 5 view .LVU351
 1336              		.loc 1 945 15 is_stmt 0 view .LVU352
 1337 0002 354B     		ldr	r3, .L102
 1338 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1339              		.loc 1 945 8 view .LVU353
 1340 0006 002B     		cmp	r3, #0
 1341 0008 3BD1     		bne	.L92
 946:Src/util.c    ****       // If input1 or Input2 is either below MIN - Threshold or above MAX + Threshold, ADC protecti
 947:Src/util.c    ****       if (IN_RANGE(input1[inIdx].raw, input1[inIdx].min - ADC_PROTECT_THRESH, input1[inIdx].max + A
 1342              		.loc 1 947 7 is_stmt 1 view .LVU354
 1343              		.loc 1 947 11 is_stmt 0 view .LVU355
 1344 000a 3449     		ldr	r1, .L102+4
 1345 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1346 0010 4200     		lsls	r2, r0, #1
 1347 0012 8818     		adds	r0, r1, r2
 1348 0014 895E     		ldrsh	r1, [r1, r2]
 1349 0016 B0F90620 		ldrsh	r2, [r0, #6]
 1350 001a C83A     		subs	r2, r2, #200
 1351              		.loc 1 947 10 view .LVU356
 1352 001c 9142     		cmp	r1, r2
 1353 001e 24DB     		blt	.L93
 1354              		.loc 1 947 11 discriminator 1 view .LVU357
 1355 0020 C3EBC302 		rsb	r2, r3, r3, lsl #3
ARM GAS  /tmp/cc14G55i.s 			page 44


 1356 0024 5000     		lsls	r0, r2, #1
 1357 0026 2D4A     		ldr	r2, .L102+4
 1358 0028 0244     		add	r2, r2, r0
 1359 002a B2F90A20 		ldrsh	r2, [r2, #10]
 1360 002e C832     		adds	r2, r2, #200
 1361 0030 9142     		cmp	r1, r2
 1362 0032 1ADC     		bgt	.L93
 948:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 1363              		.loc 1 948 11 discriminator 2 view .LVU358
 1364 0034 2A49     		ldr	r1, .L102+8
 1365 0036 C3EBC300 		rsb	r0, r3, r3, lsl #3
 1366 003a 4200     		lsls	r2, r0, #1
 1367 003c 8818     		adds	r0, r1, r2
 1368 003e 895E     		ldrsh	r1, [r1, r2]
 1369 0040 B0F90620 		ldrsh	r2, [r0, #6]
 1370 0044 C83A     		subs	r2, r2, #200
 947:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 1371              		.loc 1 947 119 discriminator 2 view .LVU359
 1372 0046 9142     		cmp	r1, r2
 1373 0048 0FDB     		blt	.L93
 1374              		.loc 1 948 11 view .LVU360
 1375 004a C3EBC302 		rsb	r2, r3, r3, lsl #3
 1376 004e 5000     		lsls	r0, r2, #1
 1377 0050 234A     		ldr	r2, .L102+8
 1378 0052 0244     		add	r2, r2, r0
 1379 0054 B2F90A20 		ldrsh	r2, [r2, #10]
 1380 0058 C832     		adds	r2, r2, #200
 1381 005a 9142     		cmp	r1, r2
 1382 005c 05DC     		bgt	.L93
 949:Src/util.c    ****           timeoutFlgADC = 0;                            // Reset the timeout flag
 1383              		.loc 1 949 11 is_stmt 1 view .LVU361
 1384              		.loc 1 949 25 is_stmt 0 view .LVU362
 1385 005e 0022     		movs	r2, #0
 1386 0060 2049     		ldr	r1, .L102+12
 1387 0062 0A70     		strb	r2, [r1]
 950:Src/util.c    ****           timeoutCntADC = 0;                            // Reset the timeout counter
 1388              		.loc 1 950 11 is_stmt 1 view .LVU363
 1389              		.loc 1 950 25 is_stmt 0 view .LVU364
 1390 0064 2049     		ldr	r1, .L102+16
 1391 0066 0A80     		strh	r2, [r1]	@ movhi
 1392 0068 0BE0     		b	.L92
 1393              	.L93:
 951:Src/util.c    ****       } else {
 952:Src/util.c    ****         if (timeoutCntADC++ >= ADC_PROTECT_TIMEOUT) {   // Timeout qualification
 1394              		.loc 1 952 9 is_stmt 1 view .LVU365
 1395              		.loc 1 952 26 is_stmt 0 view .LVU366
 1396 006a 1F49     		ldr	r1, .L102+16
 1397 006c 0A88     		ldrh	r2, [r1]
 1398 006e 501C     		adds	r0, r2, #1
 1399 0070 0880     		strh	r0, [r1]	@ movhi
 1400              		.loc 1 952 12 view .LVU367
 1401 0072 632A     		cmp	r2, #99
 1402 0074 05D9     		bls	.L92
 953:Src/util.c    ****           timeoutFlgADC = 1;                            // Timeout detected
 1403              		.loc 1 953 11 is_stmt 1 view .LVU368
 1404              		.loc 1 953 25 is_stmt 0 view .LVU369
 1405 0076 1B4A     		ldr	r2, .L102+12
ARM GAS  /tmp/cc14G55i.s 			page 45


 1406 0078 0121     		movs	r1, #1
 1407 007a 1170     		strb	r1, [r2]
 954:Src/util.c    ****           timeoutCntADC = ADC_PROTECT_TIMEOUT;          // Limit timout counter value
 1408              		.loc 1 954 11 is_stmt 1 view .LVU370
 1409              		.loc 1 954 25 is_stmt 0 view .LVU371
 1410 007c 1A4A     		ldr	r2, .L102+16
 1411 007e 6421     		movs	r1, #100
 1412 0080 1180     		strh	r1, [r2]	@ movhi
 1413              	.L92:
 955:Src/util.c    ****         }
 956:Src/util.c    ****       }
 957:Src/util.c    ****     }
 958:Src/util.c    ****     #endif
 959:Src/util.c    **** 
 960:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 961:Src/util.c    ****       if (timeoutCntSerial_L++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 962:Src/util.c    ****         timeoutFlgSerial_L = 1;                         // Timeout detected
 963:Src/util.c    ****         timeoutCntSerial_L = SERIAL_TIMEOUT;            // Limit timout counter value
 964:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1)
 965:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 966:Src/util.c    ****         #endif
 967:Src/util.c    ****       } else {                                          // No Timeout
 968:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
 969:Src/util.c    ****           if (Sideboard_L.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 970:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART2;
 971:Src/util.c    ****           } else {
 972:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART2;
 973:Src/util.c    ****           }
 974:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1
 975:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 976:Src/util.c    ****         #endif
 977:Src/util.c    ****       }
 978:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 0) || (defined(SIDEBOARD_SERI
 979:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_L;          // Report Timeout only on the Primary Input
 980:Src/util.c    ****       #endif
 981:Src/util.c    ****     #endif
 982:Src/util.c    **** 
 983:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 984:Src/util.c    ****       if (timeoutCntSerial_R++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 985:Src/util.c    ****         timeoutFlgSerial_R = 1;                         // Timeout detected
 986:Src/util.c    ****         timeoutCntSerial_R = SERIAL_TIMEOUT;            // Limit timout counter value
 987:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1)
 988:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 989:Src/util.c    ****         #endif
 990:Src/util.c    ****       } else {                                          // No Timeout
 991:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
 992:Src/util.c    ****           if (Sideboard_R.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 993:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART3;
 994:Src/util.c    ****           } else {
 995:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART3;
 996:Src/util.c    ****           }
 997:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1
 998:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 999:Src/util.c    ****         #endif
1000:Src/util.c    ****       }
1001:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 0) || (defined(SIDEBOARD_SERI
1002:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_R;          // Report Timeout only on the Primary Input
ARM GAS  /tmp/cc14G55i.s 			page 46


1003:Src/util.c    ****       #endif
1004:Src/util.c    ****     #endif
1005:Src/util.c    **** 
1006:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2) && defined(SIDEBOARD_SERIAL_USART3)
1007:Src/util.c    ****       timeoutFlgSerial = timeoutFlgSerial_L || timeoutFlgSerial_R;
1008:Src/util.c    ****     #endif
1009:Src/util.c    **** 
1010:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) || \
1011:Src/util.c    ****         defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT) || defined(CONTROL_PWM_LEFT) || def
1012:Src/util.c    ****       if (timeoutCntGen++ >= TIMEOUT) {                 // Timeout qualification
1013:Src/util.c    ****         #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) ||
1014:Src/util.c    ****             (defined(CONTROL_PPM_LEFT) && CONTROL_PPM_LEFT == 0) || (defined(CONTROL_PPM_RIGHT) && 
1015:Src/util.c    ****             (defined(CONTROL_PWM_LEFT) && CONTROL_PWM_LEFT == 0) || (defined(CONTROL_PWM_RIGHT) && 
1016:Src/util.c    ****           timeoutFlgGen = 1;                            // Report Timeout only on the Primary Input
1017:Src/util.c    ****           timeoutCntGen = TIMEOUT;
1018:Src/util.c    ****         #endif
1019:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1020:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1021:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
1022:Src/util.c    ****         #endif
1023:Src/util.c    ****       } else {
1024:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1025:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1026:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
1027:Src/util.c    ****         #endif
1028:Src/util.c    ****       }
1029:Src/util.c    ****     #endif
1030:Src/util.c    **** 
1031:Src/util.c    ****     // In case of timeout bring the system to a Safe State
1032:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial || timeoutFlgGen) {
 1414              		.loc 1 1032 5 is_stmt 1 view .LVU372
 1415              		.loc 1 1032 9 is_stmt 0 view .LVU373
 1416 0082 184A     		ldr	r2, .L102+12
 1417 0084 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1418              		.loc 1 1032 8 view .LVU374
 1419 0086 2AB9     		cbnz	r2, .L94
 1420              		.loc 1 1032 23 discriminator 1 view .LVU375
 1421 0088 184A     		ldr	r2, .L102+20
 1422 008a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1423 008c 12B9     		cbnz	r2, .L94
 1424              		.loc 1 1032 43 discriminator 2 view .LVU376
 1425 008e 184A     		ldr	r2, .L102+24
 1426 0090 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1427 0092 A2B1     		cbz	r2, .L95
 1428              	.L94:
1033:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 1429              		.loc 1 1033 7 is_stmt 1 view .LVU377
 1430              		.loc 1 1033 19 is_stmt 0 view .LVU378
 1431 0094 0021     		movs	r1, #0
 1432 0096 174A     		ldr	r2, .L102+28
 1433 0098 1170     		strb	r1, [r2]
1034:Src/util.c    ****       input1[inIdx].cmd  = 0;
 1434              		.loc 1 1034 7 is_stmt 1 view .LVU379
 1435              		.loc 1 1034 26 is_stmt 0 view .LVU380
 1436 009a C3EBC302 		rsb	r2, r3, r3, lsl #3
 1437 009e 5000     		lsls	r0, r2, #1
 1438 00a0 0E4A     		ldr	r2, .L102+4
ARM GAS  /tmp/cc14G55i.s 			page 47


 1439 00a2 0244     		add	r2, r2, r0
 1440 00a4 5180     		strh	r1, [r2, #2]	@ movhi
1035:Src/util.c    ****       input2[inIdx].cmd  = 0;
 1441              		.loc 1 1035 7 is_stmt 1 view .LVU381
 1442              		.loc 1 1035 26 is_stmt 0 view .LVU382
 1443 00a6 0E4A     		ldr	r2, .L102+8
 1444 00a8 0244     		add	r2, r2, r0
 1445 00aa 5180     		strh	r1, [r2, #2]	@ movhi
 1446              	.L96:
1036:Src/util.c    ****     } else {
1037:Src/util.c    ****       ctrlModReq  = ctrlModReqRaw;                                      // Follow the Mode request
1038:Src/util.c    ****     }
1039:Src/util.c    **** 
1040:Src/util.c    ****     // Beep in case of Input index change
1041:Src/util.c    ****     if (inIdx && !inIdx_prev) {                                         // rising edge
 1447              		.loc 1 1041 5 is_stmt 1 view .LVU383
 1448              		.loc 1 1041 8 is_stmt 0 view .LVU384
 1449 00ac 13B1     		cbz	r3, .L97
 1450              		.loc 1 1041 18 discriminator 1 view .LVU385
 1451 00ae 124A     		ldr	r2, .L102+32
 1452 00b0 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1453              		.loc 1 1041 15 discriminator 1 view .LVU386
 1454 00b2 4AB1     		cbz	r2, .L100
 1455              	.L97:
1042:Src/util.c    ****       beepShort(8);
1043:Src/util.c    ****     } else if (!inIdx && inIdx_prev) {                                  // falling edge
 1456              		.loc 1 1043 12 is_stmt 1 view .LVU387
 1457              		.loc 1 1043 15 is_stmt 0 view .LVU388
 1458 00b4 13B9     		cbnz	r3, .L91
 1459              		.loc 1 1043 23 discriminator 1 view .LVU389
 1460 00b6 104B     		ldr	r3, .L102+32
 1461 00b8 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1462 00ba 4BB9     		cbnz	r3, .L101
 1463              	.L91:
1044:Src/util.c    ****       beepShort(18);
1045:Src/util.c    ****     }
1046:Src/util.c    **** }
 1464              		.loc 1 1046 1 view .LVU390
 1465 00bc 08BD     		pop	{r3, pc}
 1466              	.L95:
1037:Src/util.c    ****     }
 1467              		.loc 1 1037 7 is_stmt 1 view .LVU391
1037:Src/util.c    ****     }
 1468              		.loc 1 1037 19 is_stmt 0 view .LVU392
 1469 00be 0F4A     		ldr	r2, .L102+36
 1470 00c0 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 1471 00c2 0C4A     		ldr	r2, .L102+28
 1472 00c4 1170     		strb	r1, [r2]
 1473 00c6 F1E7     		b	.L96
 1474              	.L100:
1042:Src/util.c    ****       beepShort(8);
 1475              		.loc 1 1042 7 is_stmt 1 view .LVU393
 1476 00c8 0820     		movs	r0, #8
 1477 00ca FFF7FEFF 		bl	beepShort
 1478              	.LVL74:
 1479 00ce F5E7     		b	.L91
 1480              	.L101:
ARM GAS  /tmp/cc14G55i.s 			page 48


1044:Src/util.c    ****       beepShort(18);
 1481              		.loc 1 1044 7 view .LVU394
 1482 00d0 1220     		movs	r0, #18
 1483 00d2 FFF7FEFF 		bl	beepShort
 1484              	.LVL75:
 1485              		.loc 1 1046 1 is_stmt 0 view .LVU395
 1486 00d6 F1E7     		b	.L91
 1487              	.L103:
 1488              		.align	2
 1489              	.L102:
 1490 00d8 00000000 		.word	.LANCHOR16
 1491 00dc 00000000 		.word	.LANCHOR14
 1492 00e0 00000000 		.word	.LANCHOR15
 1493 00e4 00000000 		.word	.LANCHOR17
 1494 00e8 00000000 		.word	.LANCHOR18
 1495 00ec 00000000 		.word	.LANCHOR19
 1496 00f0 00000000 		.word	timeoutFlgGen
 1497 00f4 00000000 		.word	.LANCHOR20
 1498 00f8 00000000 		.word	.LANCHOR22
 1499 00fc 00000000 		.word	.LANCHOR21
 1500              		.cfi_endproc
 1501              	.LFE83:
 1503              		.section	.text.readCommand,"ax",%progbits
 1504              		.align	1
 1505              		.global	readCommand
 1506              		.syntax unified
 1507              		.thumb
 1508              		.thumb_func
 1509              		.fpu softvfp
 1511              	readCommand:
 1512              	.LFB84:
1047:Src/util.c    **** 
1048:Src/util.c    ****  /*
1049:Src/util.c    ****  * Function to calculate the command to the motors. This function also manages:
1050:Src/util.c    ****  * - timeout detection
1051:Src/util.c    ****  * - MIN/MAX limitations and deadband
1052:Src/util.c    ****  */
1053:Src/util.c    **** void readCommand(void) {
 1513              		.loc 1 1053 24 is_stmt 1 view -0
 1514              		.cfi_startproc
 1515              		@ args = 0, pretend = 0, frame = 0
 1516              		@ frame_needed = 0, uses_anonymous_args = 0
 1517 0000 70B5     		push	{r4, r5, r6, lr}
 1518              	.LCFI12:
 1519              		.cfi_def_cfa_offset 16
 1520              		.cfi_offset 4, -16
 1521              		.cfi_offset 5, -12
 1522              		.cfi_offset 6, -8
 1523              		.cfi_offset 14, -4
1054:Src/util.c    ****     readInputRaw();
 1524              		.loc 1 1054 5 view .LVU397
 1525 0002 FFF7FEFF 		bl	readInputRaw
 1526              	.LVL76:
1055:Src/util.c    **** 
1056:Src/util.c    ****     #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1057:Src/util.c    ****       calcInputCmd(&input1[inIdx], INPUT_MIN, INPUT_MAX);
 1527              		.loc 1 1057 7 view .LVU398
ARM GAS  /tmp/cc14G55i.s 			page 49


 1528              		.loc 1 1057 27 is_stmt 0 view .LVU399
 1529 0006 194E     		ldr	r6, .L106
 1530 0008 3078     		ldrb	r0, [r6]	@ zero_extendqisi2
 1531              		.loc 1 1057 7 view .LVU400
 1532 000a 194D     		ldr	r5, .L106+4
 1533 000c 194C     		ldr	r4, .L106+8
 1534 000e C0EBC000 		rsb	r0, r0, r0, lsl #3
 1535 0012 B5F90020 		ldrsh	r2, [r5]
 1536 0016 B4F90010 		ldrsh	r1, [r4]
 1537 001a 174B     		ldr	r3, .L106+12
 1538 001c 03EB4000 		add	r0, r3, r0, lsl #1
 1539 0020 FFF7FEFF 		bl	calcInputCmd
 1540              	.LVL77:
1058:Src/util.c    ****       #if !defined(VARIANT_SKATEBOARD)
1059:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_MIN, INPUT_MAX);
 1541              		.loc 1 1059 9 is_stmt 1 view .LVU401
 1542              		.loc 1 1059 29 is_stmt 0 view .LVU402
 1543 0024 3078     		ldrb	r0, [r6]	@ zero_extendqisi2
 1544              		.loc 1 1059 9 view .LVU403
 1545 0026 C0EBC000 		rsb	r0, r0, r0, lsl #3
 1546 002a B5F90020 		ldrsh	r2, [r5]
 1547 002e B4F90010 		ldrsh	r1, [r4]
 1548 0032 124B     		ldr	r3, .L106+16
 1549 0034 03EB4000 		add	r0, r3, r0, lsl #1
 1550 0038 FFF7FEFF 		bl	calcInputCmd
 1551              	.LVL78:
1060:Src/util.c    ****       #else
1061:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_BRK, INPUT_MAX);
1062:Src/util.c    ****       #endif
1063:Src/util.c    ****     #endif
1064:Src/util.c    **** 
1065:Src/util.c    ****     handleTimeout();
 1552              		.loc 1 1065 5 is_stmt 1 view .LVU404
 1553 003c FFF7FEFF 		bl	handleTimeout
 1554              	.LVL79:
1066:Src/util.c    **** 
1067:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1068:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
1069:Src/util.c    ****       brakePressed = (uint8_t)(input1[inIdx].cmd > 50);
1070:Src/util.c    ****     }
1071:Src/util.c    ****     else {
1072:Src/util.c    ****       brakePressed = (uint8_t)(input2[inIdx].cmd < -50);
1073:Src/util.c    ****     }
1074:Src/util.c    ****     #endif
1075:Src/util.c    **** 
1076:Src/util.c    ****     #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
1077:Src/util.c    ****       button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
 1555              		.loc 1 1077 7 view .LVU405
 1556              		.loc 1 1077 18 is_stmt 0 view .LVU406
 1557 0040 0F4C     		ldr	r4, .L106+20
 1558 0042 4FF48061 		mov	r1, #1024
 1559 0046 2046     		mov	r0, r4
 1560 0048 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 1561              	.LVL80:
 1562              		.loc 1 1077 17 view .LVU407
 1563 004c B0FA80F0 		clz	r0, r0
 1564 0050 4009     		lsrs	r0, r0, #5
ARM GAS  /tmp/cc14G55i.s 			page 50


 1565              		.loc 1 1077 15 view .LVU408
 1566 0052 0C4B     		ldr	r3, .L106+24
 1567 0054 1870     		strb	r0, [r3]
1078:Src/util.c    ****       button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
 1568              		.loc 1 1078 7 is_stmt 1 view .LVU409
 1569              		.loc 1 1078 18 is_stmt 0 view .LVU410
 1570 0056 4FF40061 		mov	r1, #2048
 1571 005a 2046     		mov	r0, r4
 1572 005c FFF7FEFF 		bl	HAL_GPIO_ReadPin
 1573              	.LVL81:
 1574              		.loc 1 1078 17 view .LVU411
 1575 0060 B0FA80F0 		clz	r0, r0
 1576 0064 4009     		lsrs	r0, r0, #5
 1577              		.loc 1 1078 15 view .LVU412
 1578 0066 084B     		ldr	r3, .L106+28
 1579 0068 1870     		strb	r0, [r3]
1079:Src/util.c    ****     #endif
1080:Src/util.c    **** 
1081:Src/util.c    ****     #if defined(CRUISE_CONTROL_SUPPORT) && (defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEF
1082:Src/util.c    ****         cruiseControl(button1);                                           // Cruise control activat
1083:Src/util.c    ****     #endif
1084:Src/util.c    **** }
 1580              		.loc 1 1084 1 view .LVU413
 1581 006a 70BD     		pop	{r4, r5, r6, pc}
 1582              	.L107:
 1583              		.align	2
 1584              	.L106:
 1585 006c 00000000 		.word	.LANCHOR16
 1586 0070 00000000 		.word	.LANCHOR9
 1587 0074 00000000 		.word	.LANCHOR10
 1588 0078 00000000 		.word	.LANCHOR14
 1589 007c 00000000 		.word	.LANCHOR15
 1590 0080 000C0140 		.word	1073810432
 1591 0084 00000000 		.word	.LANCHOR23
 1592 0088 00000000 		.word	.LANCHOR24
 1593              		.cfi_endproc
 1594              	.LFE84:
 1596              		.section	.text.usart2_rx_check,"ax",%progbits
 1597              		.align	1
 1598              		.global	usart2_rx_check
 1599              		.syntax unified
 1600              		.thumb
 1601              		.thumb_func
 1602              		.fpu softvfp
 1604              	usart2_rx_check:
 1605              	.LFB85:
1085:Src/util.c    **** 
1086:Src/util.c    **** 
1087:Src/util.c    **** /*
1088:Src/util.c    ****  * Check for new data received on USART2 with DMA: refactored function from https://github.com/MaJe
1089:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1090:Src/util.c    ****  */
1091:Src/util.c    **** void usart2_rx_check(void)
1092:Src/util.c    **** {
 1606              		.loc 1 1092 1 is_stmt 1 view -0
 1607              		.cfi_startproc
 1608              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cc14G55i.s 			page 51


 1609              		@ frame_needed = 0, uses_anonymous_args = 0
 1610              		@ link register save eliminated.
1093:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1094:Src/util.c    ****   static uint32_t old_pos;
1095:Src/util.c    ****   uint32_t pos;
1096:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
1097:Src/util.c    ****   #endif
1098:Src/util.c    **** 
1099:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2)
1100:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1101:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1102:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1103:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], pos - old_pos);        // Process data
1104:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1105:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy dat
1106:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1107:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_L_len - old_pos], &rx_buffer_L[0], pos);                       
1108:Src/util.c    ****       }
1109:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_L_len - old_pos + pos);        // Process data
1110:Src/util.c    ****     }
1111:Src/util.c    ****   }
1112:Src/util.c    ****   #endif // DEBUG_SERIAL_USART2
1113:Src/util.c    **** 
1114:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART2
1115:Src/util.c    ****   uint8_t *ptr;	
1116:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1117:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
1118:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
1119:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
1120:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1121:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
1122:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1123:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1124:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1125:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1126:Src/util.c    ****       }
1127:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1128:Src/util.c    ****     }
1129:Src/util.c    ****   }
1130:Src/util.c    ****   #endif // CONTROL_SERIAL_USART2
1131:Src/util.c    **** 
1132:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART2
1133:Src/util.c    ****   uint8_t *ptr;	
1134:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1135:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_L_raw;                                  // Initialize the pointer w
1136:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_L_len) {          // "Linear" buffer mode: ch
1137:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], Sideboard_L_len);              // Copy data. This is possi
1138:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1139:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == Sideboard_L_len) {  // "Overflow" buffer mode: 
1140:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1141:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1142:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1143:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1144:Src/util.c    ****       }
1145:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1146:Src/util.c    ****     }
1147:Src/util.c    ****   }
ARM GAS  /tmp/cc14G55i.s 			page 52


1148:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART2
1149:Src/util.c    **** 
1150:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1151:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1152:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
1153:Src/util.c    ****     old_pos = 0;
1154:Src/util.c    ****   }
1155:Src/util.c    **** 	#endif
1156:Src/util.c    **** }
 1611              		.loc 1 1156 1 view .LVU415
 1612 0000 7047     		bx	lr
 1613              		.cfi_endproc
 1614              	.LFE85:
 1616              		.section	.text.usart3_rx_check,"ax",%progbits
 1617              		.align	1
 1618              		.global	usart3_rx_check
 1619              		.syntax unified
 1620              		.thumb
 1621              		.thumb_func
 1622              		.fpu softvfp
 1624              	usart3_rx_check:
 1625              	.LFB86:
1157:Src/util.c    **** 
1158:Src/util.c    **** 
1159:Src/util.c    **** /*
1160:Src/util.c    ****  * Check for new data received on USART3 with DMA: refactored function from https://github.com/MaJe
1161:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1162:Src/util.c    ****  */
1163:Src/util.c    **** void usart3_rx_check(void)
1164:Src/util.c    **** {
 1626              		.loc 1 1164 1 view -0
 1627              		.cfi_startproc
 1628              		@ args = 0, pretend = 0, frame = 0
 1629              		@ frame_needed = 0, uses_anonymous_args = 0
 1630              		@ link register save eliminated.
1165:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1166:Src/util.c    ****   static uint32_t old_pos;
1167:Src/util.c    ****   uint32_t pos;  
1168:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
1169:Src/util.c    ****   #endif
1170:Src/util.c    **** 
1171:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3)
1172:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1173:Src/util.c    **** 
1174:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1175:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1176:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], pos - old_pos);        // Process data
1177:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1178:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy dat
1179:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1180:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_R_len - old_pos], &rx_buffer_R[0], pos);                       
1181:Src/util.c    ****       }
1182:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_R_len - old_pos + pos);        // Process data
1183:Src/util.c    ****     }
1184:Src/util.c    ****   }
1185:Src/util.c    ****   #endif // DEBUG_SERIAL_USART3
1186:Src/util.c    **** 
ARM GAS  /tmp/cc14G55i.s 			page 53


1187:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART3
1188:Src/util.c    ****   uint8_t *ptr;
1189:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1190:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
1191:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandR_len) {             // "Linear" buffer mode: ch
1192:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
1193:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1194:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == commandR_len) {     // "Overflow" buffer mode: 
1195:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1196:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1197:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1198:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1199:Src/util.c    ****       }
1200:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1201:Src/util.c    ****     }
1202:Src/util.c    ****   }
1203:Src/util.c    ****   #endif // CONTROL_SERIAL_USART3
1204:Src/util.c    **** 
1205:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART3
1206:Src/util.c    ****   uint8_t *ptr;
1207:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1208:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_R_raw;                                  // Initialize the pointer w
1209:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_R_len) {          // "Linear" buffer mode: ch
1210:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], Sideboard_R_len);              // Copy data. This is possi
1211:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1212:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == Sideboard_R_len) {  // "Overflow" buffer mode: 
1213:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1214:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1215:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1216:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1217:Src/util.c    ****       }
1218:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1219:Src/util.c    ****     }
1220:Src/util.c    ****   }
1221:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART3
1222:Src/util.c    **** 
1223:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1224:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1225:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
1226:Src/util.c    ****     old_pos = 0;
1227:Src/util.c    ****   }
1228:Src/util.c    ****   #endif
1229:Src/util.c    **** }
 1631              		.loc 1 1229 1 view .LVU417
 1632 0000 7047     		bx	lr
 1633              		.cfi_endproc
 1634              	.LFE86:
 1636              		.section	.text.sideboardLeds,"ax",%progbits
 1637              		.align	1
 1638              		.global	sideboardLeds
 1639              		.syntax unified
 1640              		.thumb
 1641              		.thumb_func
 1642              		.fpu softvfp
 1644              	sideboardLeds:
 1645              	.LVL82:
 1646              	.LFB87:
ARM GAS  /tmp/cc14G55i.s 			page 54


1230:Src/util.c    **** 
1231:Src/util.c    **** /*
1232:Src/util.c    ****  * Process Rx debug user command input
1233:Src/util.c    ****  */
1234:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1235:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
1236:Src/util.c    **** {
1237:Src/util.c    ****   #ifdef DEBUG_SERIAL_PROTOCOL
1238:Src/util.c    ****     handle_input(userCommand, len);
1239:Src/util.c    ****   #endif
1240:Src/util.c    **** }
1241:Src/util.c    **** 
1242:Src/util.c    **** #endif // SERIAL_DEBUG
1243:Src/util.c    **** 
1244:Src/util.c    **** /*
1245:Src/util.c    ****  * Process command Rx data
1246:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
1247:Src/util.c    ****  */
1248:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
1249:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out, uint8_t usart_idx
1250:Src/util.c    **** {
1251:Src/util.c    ****   #ifdef CONTROL_IBUS
1252:Src/util.c    ****     uint16_t ibus_chksum;
1253:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
1254:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
1255:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
1256:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
1257:Src/util.c    ****       }
1258:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
1259:Src/util.c    ****         *command_out = *command_in;
1260:Src/util.c    ****         if (usart_idx == 2) {             // Sideboard USART2
1261:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART2
1262:Src/util.c    ****           timeoutFlgSerial_L = 0;         // Clear timeout flag
1263:Src/util.c    ****           timeoutCntSerial_L = 0;         // Reset timeout counter
1264:Src/util.c    ****           #endif
1265:Src/util.c    ****         } else if (usart_idx == 3) {      // Sideboard USART3
1266:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART3
1267:Src/util.c    ****           timeoutFlgSerial_R = 0;         // Clear timeout flag
1268:Src/util.c    ****           timeoutCntSerial_R = 0;         // Reset timeout counter
1269:Src/util.c    ****           #endif
1270:Src/util.c    ****         }
1271:Src/util.c    ****       }
1272:Src/util.c    ****     }
1273:Src/util.c    ****   #else
1274:Src/util.c    ****   uint16_t checksum;
1275:Src/util.c    ****   if (command_in->start == SERIAL_START_FRAME) {
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
1278:Src/util.c    ****       *command_out = *command_in;
1279:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1280:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
1281:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1282:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
1283:Src/util.c    ****         #endif
1284:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1285:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
1286:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
ARM GAS  /tmp/cc14G55i.s 			page 55


1287:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1288:Src/util.c    ****         #endif
1289:Src/util.c    ****       }
1290:Src/util.c    ****     }
1291:Src/util.c    ****   }
1292:Src/util.c    ****   #endif
1293:Src/util.c    **** }
1294:Src/util.c    **** #endif
1295:Src/util.c    **** 
1296:Src/util.c    **** /*
1297:Src/util.c    ****  * Process Sideboard Rx data
1298:Src/util.c    ****  * - if the Sideboard_in data is valid (correct START_FRAME and checksum) copy the Sideboard_in to 
1299:Src/util.c    ****  */
1300:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1301:Src/util.c    **** void usart_process_sideboard(SerialSideboard *Sideboard_in, SerialSideboard *Sideboard_out, uint8_t
1302:Src/util.c    **** {
1303:Src/util.c    ****   uint16_t checksum;
1304:Src/util.c    ****   if (Sideboard_in->start == SERIAL_START_FRAME) {
1305:Src/util.c    ****     checksum = (uint16_t)(Sideboard_in->start ^ Sideboard_in->pitch ^ Sideboard_in->dPitch ^ Sidebo
1306:Src/util.c    ****     if (Sideboard_in->checksum == checksum) {
1307:Src/util.c    ****       *Sideboard_out = *Sideboard_in;
1308:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1309:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART2
1310:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1311:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1312:Src/util.c    ****         #endif
1313:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1314:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART3
1315:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1316:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1317:Src/util.c    ****         #endif
1318:Src/util.c    ****       }
1319:Src/util.c    ****     }
1320:Src/util.c    ****   }
1321:Src/util.c    **** }
1322:Src/util.c    **** #endif
1323:Src/util.c    **** 
1324:Src/util.c    **** 
1325:Src/util.c    **** /* =========================== Sideboard Functions =========================== */
1326:Src/util.c    **** 
1327:Src/util.c    **** /*
1328:Src/util.c    ****  * Sideboard LEDs Handling
1329:Src/util.c    ****  * This function manages the leds behavior connected to the sideboard
1330:Src/util.c    ****  */
1331:Src/util.c    **** void sideboardLeds(uint8_t *leds) {
 1647              		.loc 1 1331 35 view -0
 1648              		.cfi_startproc
 1649              		@ args = 0, pretend = 0, frame = 0
 1650              		@ frame_needed = 0, uses_anonymous_args = 0
 1651              		@ link register save eliminated.
1332:Src/util.c    ****   #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1333:Src/util.c    ****     // Enable flag: use LED4 (bottom Blue)
1334:Src/util.c    ****     // enable == 1, turn on led
1335:Src/util.c    ****     // enable == 0, blink led
1336:Src/util.c    ****     if (enable) {
1337:Src/util.c    ****       *leds |= LED4_SET;
1338:Src/util.c    ****     } else if (!enable && (main_loop_counter % 20 == 0)) {
ARM GAS  /tmp/cc14G55i.s 			page 56


1339:Src/util.c    ****       *leds ^= LED4_SET;
1340:Src/util.c    ****     }
1341:Src/util.c    **** 
1342:Src/util.c    ****     // Backward Drive: use LED5 (upper Blue)
1343:Src/util.c    ****     // backwardDrive == 1, blink led
1344:Src/util.c    ****     // backwardDrive == 0, turn off led
1345:Src/util.c    ****     if (backwardDrive && (main_loop_counter % 50 == 0)) {
1346:Src/util.c    ****       *leds ^= LED5_SET;
1347:Src/util.c    ****     }
1348:Src/util.c    **** 
1349:Src/util.c    ****     // Brake: use LED5 (upper Blue)
1350:Src/util.c    ****     // brakePressed == 1, turn on led
1351:Src/util.c    ****     // brakePressed == 0, turn off led
1352:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1353:Src/util.c    ****       if (brakePressed) {
1354:Src/util.c    ****         *leds |= LED5_SET;
1355:Src/util.c    ****       } else if (!brakePressed && !backwardDrive) {
1356:Src/util.c    ****         *leds &= ~LED5_SET;
1357:Src/util.c    ****       }
1358:Src/util.c    ****     #endif
1359:Src/util.c    **** 
1360:Src/util.c    ****     // Battery Level Indicator: use LED1, LED2, LED3
1361:Src/util.c    ****     if (main_loop_counter % BAT_BLINK_INTERVAL == 0) {              //  | RED (LED1) | YELLOW (LED3
1362:Src/util.c    ****       if (batVoltage < BAT_DEAD) {                                  //  |     0      |       0     
1363:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET & ~LED2_SET;
1364:Src/util.c    ****       } else if (batVoltage < BAT_LVL1) {                           //  |     B      |       0     
1365:Src/util.c    ****         *leds ^= LED1_SET;
1366:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1367:Src/util.c    ****       } else if (batVoltage < BAT_LVL2) {                           //  |     1      |       0     
1368:Src/util.c    ****         *leds |= LED1_SET;
1369:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1370:Src/util.c    ****       } else if (batVoltage < BAT_LVL3) {                           //  |     0      |       B     
1371:Src/util.c    ****         *leds ^= LED3_SET;
1372:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1373:Src/util.c    ****       } else if (batVoltage < BAT_LVL4) {                           //  |     0      |       1     
1374:Src/util.c    ****         *leds |= LED3_SET;
1375:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1376:Src/util.c    ****       } else if (batVoltage < BAT_LVL5) {                           //  |     0      |       0     
1377:Src/util.c    ****         *leds ^= LED2_SET;
1378:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1379:Src/util.c    ****       } else {                                                      //  |     0      |       0     
1380:Src/util.c    ****         *leds |= LED2_SET;
1381:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1382:Src/util.c    ****       }
1383:Src/util.c    ****     }
1384:Src/util.c    **** 
1385:Src/util.c    ****     // Error handling
1386:Src/util.c    ****     // Critical error:  LED1 on (RED)     + high pitch beep (hadled in main)
1387:Src/util.c    ****     // Soft error:      LED3 on (YELLOW)  + low  pitch beep (hadled in main)
1388:Src/util.c    ****     if (rtY_Left.z_errCode || rtY_Right.z_errCode) {
1389:Src/util.c    ****       *leds |= LED1_SET;
1390:Src/util.c    ****       *leds &= ~LED3_SET & ~LED2_SET;
1391:Src/util.c    ****     }
1392:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial) {
1393:Src/util.c    ****       *leds |= LED3_SET;
1394:Src/util.c    ****       *leds &= ~LED1_SET & ~LED2_SET;
1395:Src/util.c    ****     }
ARM GAS  /tmp/cc14G55i.s 			page 57


1396:Src/util.c    ****   #endif
1397:Src/util.c    **** }
 1652              		.loc 1 1397 1 view .LVU419
 1653 0000 7047     		bx	lr
 1654              		.cfi_endproc
 1655              	.LFE87:
 1657              		.section	.text.sideboardSensors,"ax",%progbits
 1658              		.align	1
 1659              		.global	sideboardSensors
 1660              		.syntax unified
 1661              		.thumb
 1662              		.thumb_func
 1663              		.fpu softvfp
 1665              	sideboardSensors:
 1666              	.LVL83:
 1667              	.LFB88:
1398:Src/util.c    **** 
1399:Src/util.c    **** /*
1400:Src/util.c    ****  * Sideboard Sensor Handling
1401:Src/util.c    ****  * This function manages the sideboards photo sensors.
1402:Src/util.c    ****  * In non-hoverboard variants, the sensors are used as push buttons.
1403:Src/util.c    ****  */
1404:Src/util.c    **** void sideboardSensors(uint8_t sensors) {
 1668              		.loc 1 1404 40 view -0
 1669              		.cfi_startproc
 1670              		@ args = 0, pretend = 0, frame = 0
 1671              		@ frame_needed = 0, uses_anonymous_args = 0
 1672              		@ link register save eliminated.
1405:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL
1406:Src/util.c    ****     static uint8_t sensor1_index;                                 // holds the press index number f
1407:Src/util.c    ****     static uint8_t sensor1_prev,  sensor2_prev;
1408:Src/util.c    ****     uint8_t sensor1_trig = 0, sensor2_trig = 0;
1409:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
1410:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART2;
1411:Src/util.c    ****     uint16_t sideboardSns = Sideboard_L.sensors;
1412:Src/util.c    ****     #else
1413:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART3;
1414:Src/util.c    ****     uint16_t sideboardSns = Sideboard_R.sensors;
1415:Src/util.c    ****     #endif
1416:Src/util.c    **** 
1417:Src/util.c    ****     if (inIdx == sideboardIdx) {                                  // Use Sideboard data
1418:Src/util.c    ****       sensor1_index = 2 + ((sideboardSns & SWB_SET) >> 9);        // SWB on RC transmitter is used 
1419:Src/util.c    ****       if (sensor1_index == 2) {                                   // FOC control Type
1420:Src/util.c    ****         sensor1_index = (sideboardSns & SWC_SET) >> 11;           // SWC on RC transmitter is used 
1421:Src/util.c    ****       }
1422:Src/util.c    ****       sensor1_trig  = sensor1_index != sensor1_prev;              // rising or falling edge change 
1423:Src/util.c    ****       if (inIdx != inIdx_prev) {                                  // Force one update at Input idx 
1424:Src/util.c    ****         sensor1_trig  = 1;
1425:Src/util.c    ****       }
1426:Src/util.c    ****       sensor1_prev  = sensor1_index;
1427:Src/util.c    ****     } else {                                                      // Use Optical switches
1428:Src/util.c    ****       sensor1_trig  = (sensors & SENSOR1_SET) && !sensor1_prev;   // rising edge detection
1429:Src/util.c    ****       sensor1_prev  =  sensors & SENSOR1_SET;
1430:Src/util.c    ****     }
1431:Src/util.c    **** 
1432:Src/util.c    ****     // Control MODE and Control Type Handling
1433:Src/util.c    ****     if (sensor1_trig) {
ARM GAS  /tmp/cc14G55i.s 			page 58


1434:Src/util.c    ****       switch (sensor1_index) {
1435:Src/util.c    ****         case 0:     // FOC VOLTAGE
1436:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1437:Src/util.c    ****           ctrlModReqRaw         = VLT_MODE;
1438:Src/util.c    ****           break;
1439:Src/util.c    ****         case 1:     // FOC SPEED
1440:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1441:Src/util.c    ****           ctrlModReqRaw         = SPD_MODE;
1442:Src/util.c    ****           break;
1443:Src/util.c    ****         case 2:     // FOC TORQUE
1444:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1445:Src/util.c    ****           ctrlModReqRaw         = TRQ_MODE;
1446:Src/util.c    ****           break;
1447:Src/util.c    ****         case 3:     // SINUSOIDAL
1448:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = SIN_CTRL;
1449:Src/util.c    ****           break;
1450:Src/util.c    ****         case 4:     // COMMUTATION
1451:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = COM_CTRL;
1452:Src/util.c    ****           break;
1453:Src/util.c    ****       }
1454:Src/util.c    ****       if (inIdx == inIdx_prev) { beepShortMany(sensor1_index + 1, 1); }
1455:Src/util.c    ****       if (++sensor1_index > 4) { sensor1_index = 0; }
1456:Src/util.c    ****     }
1457:Src/util.c    **** 
1458:Src/util.c    ****                                                              // Field Weakening Activation/Deactiva
1459:Src/util.c    ****       static uint8_t  sensor2_index = 1;                          // holds the press index number f
1460:Src/util.c    **** 
1461:Src/util.c    ****       // Override in case the Sideboard control is Active
1462:Src/util.c    ****       if (inIdx == sideboardIdx) {                                // Use Sideboard data
1463:Src/util.c    ****         sensor2_index = (sideboardSns & SWD_SET) >> 13;           // SWD on RC transmitter is used 
1464:Src/util.c    ****         sensor2_trig  = sensor2_index != sensor2_prev;            // rising or falling edge change 
1465:Src/util.c    ****         if (inIdx != inIdx_prev) {                                // Force one update at Input idx 
1466:Src/util.c    ****           sensor2_trig  = 1;
1467:Src/util.c    ****         }
1468:Src/util.c    ****         sensor2_prev  = sensor2_index;
1469:Src/util.c    ****       }else{
1470:Src/util.c    ****         sensor2_trig  = (sensors & SENSOR2_SET) && !sensor2_prev;   // rising edge detection
1471:Src/util.c    ****         sensor2_prev  =  sensors & SENSOR2_SET;
1472:Src/util.c    ****       }
1473:Src/util.c    **** 
1474:Src/util.c    ****       #ifdef CRUISE_CONTROL_SUPPORT                                 // Cruise Control Activation/De
1475:Src/util.c    ****         if (sensor2_trig) {
1476:Src/util.c    ****           cruiseControl(sensor2_trig);
1477:Src/util.c    ****         }
1478:Src/util.c    ****       #else
1479:Src/util.c    ****         if (sensor2_trig) {
1480:Src/util.c    ****           switch (sensor2_index) {
1481:Src/util.c    ****             case 0:     // FW Disabled
1482:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 0; 
1483:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 0;
1484:Src/util.c    ****               Input_Lim_Init();
1485:Src/util.c    ****               break;
1486:Src/util.c    ****             case 1:     // FW Enabled
1487:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 1; 
1488:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 1;
1489:Src/util.c    ****               Input_Lim_Init();
1490:Src/util.c    ****               break; 
ARM GAS  /tmp/cc14G55i.s 			page 59


1491:Src/util.c    ****           }
1492:Src/util.c    ****           if (inIdx == inIdx_prev) { beepShortMany(sensor2_index + 1, 1); }
1493:Src/util.c    ****           if (++sensor2_index > 1) { sensor2_index = 0; }
1494:Src/util.c    ****         }
1495:Src/util.c    ****       #endif  // CRUISE_CONTROL_SUPPORT
1496:Src/util.c    ****   #endif
1497:Src/util.c    **** }
 1673              		.loc 1 1497 1 view .LVU421
 1674 0000 7047     		bx	lr
 1675              		.cfi_endproc
 1676              	.LFE88:
 1678              		.section	.text.saveConfig,"ax",%progbits
 1679              		.align	1
 1680              		.global	saveConfig
 1681              		.syntax unified
 1682              		.thumb
 1683              		.thumb_func
 1684              		.fpu softvfp
 1686              	saveConfig:
 1687              	.LFB89:
1498:Src/util.c    **** 
1499:Src/util.c    **** 
1500:Src/util.c    **** 
1501:Src/util.c    **** /* =========================== Poweroff Functions =========================== */
1502:Src/util.c    **** 
1503:Src/util.c    ****  /*
1504:Src/util.c    ****  * Save Configuration to Flash
1505:Src/util.c    ****  * This function makes sure data is not lost after power-off
1506:Src/util.c    ****  */
1507:Src/util.c    **** void saveConfig() {
 1688              		.loc 1 1507 19 view -0
 1689              		.cfi_startproc
 1690              		@ args = 0, pretend = 0, frame = 0
 1691              		@ frame_needed = 0, uses_anonymous_args = 0
 1692 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1693              	.LCFI13:
 1694              		.cfi_def_cfa_offset 32
 1695              		.cfi_offset 3, -32
 1696              		.cfi_offset 4, -28
 1697              		.cfi_offset 5, -24
 1698              		.cfi_offset 6, -20
 1699              		.cfi_offset 7, -16
 1700              		.cfi_offset 8, -12
 1701              		.cfi_offset 9, -8
 1702              		.cfi_offset 14, -4
1508:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
1509:Src/util.c    ****     if (saveValue_valid) {
1510:Src/util.c    ****       HAL_FLASH_Unlock();
1511:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], saveValue);
1512:Src/util.c    ****       HAL_FLASH_Lock();
1513:Src/util.c    ****     }
1514:Src/util.c    ****   #endif
1515:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1516:Src/util.c    ****     if (inp_cal_valid || cur_spd_valid) {
 1703              		.loc 1 1516 5 view .LVU423
 1704              		.loc 1 1516 9 is_stmt 0 view .LVU424
 1705 0004 374B     		ldr	r3, .L118
ARM GAS  /tmp/cc14G55i.s 			page 60


 1706 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1707              		.loc 1 1516 8 view .LVU425
 1708 0008 13B9     		cbnz	r3, .L113
 1709              		.loc 1 1516 23 discriminator 1 view .LVU426
 1710 000a 374B     		ldr	r3, .L118+4
 1711 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1712 000e C3B1     		cbz	r3, .L112
 1713              	.L113:
1517:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1518:Src/util.c    ****         printf("Saving configuration to EEprom\r\n");
1519:Src/util.c    ****       #endif
1520:Src/util.c    **** 
1521:Src/util.c    ****       HAL_FLASH_Unlock();
 1714              		.loc 1 1521 7 is_stmt 1 view .LVU427
 1715 0010 FFF7FEFF 		bl	HAL_FLASH_Unlock
 1716              	.LVL84:
1522:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0] , (uint16_t)FLASH_WRITE_KEY);
 1717              		.loc 1 1522 7 view .LVU428
 1718 0014 354C     		ldr	r4, .L118+8
 1719 0016 41F20101 		movw	r1, #4097
 1720 001a 2088     		ldrh	r0, [r4]
 1721 001c FFF7FEFF 		bl	EE_WriteVariable
 1722              	.LVL85:
1523:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[1] , (uint16_t)rtP_Left.i_max);
 1723              		.loc 1 1523 7 view .LVU429
 1724              		.loc 1 1523 61 is_stmt 0 view .LVU430
 1725 0020 334D     		ldr	r5, .L118+12
 1726 0022 B5F9CE10 		ldrsh	r1, [r5, #206]
 1727              		.loc 1 1523 7 view .LVU431
 1728 0026 89B2     		uxth	r1, r1
 1729 0028 6088     		ldrh	r0, [r4, #2]
 1730 002a FFF7FEFF 		bl	EE_WriteVariable
 1731              	.LVL86:
1524:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[2] , (uint16_t)rtP_Left.n_max);
 1732              		.loc 1 1524 7 is_stmt 1 view .LVU432
 1733              		.loc 1 1524 61 is_stmt 0 view .LVU433
 1734 002e B5F9DA10 		ldrsh	r1, [r5, #218]
 1735              		.loc 1 1524 7 view .LVU434
 1736 0032 89B2     		uxth	r1, r1
 1737 0034 A088     		ldrh	r0, [r4, #4]
 1738 0036 FFF7FEFF 		bl	EE_WriteVariable
 1739              	.LVL87:
1525:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 1740              		.loc 1 1525 7 is_stmt 1 view .LVU435
 1741              	.LBB9:
 1742              		.loc 1 1525 12 view .LVU436
 1743              		.loc 1 1525 20 is_stmt 0 view .LVU437
 1744 003a 0025     		movs	r5, #0
 1745              	.LVL88:
 1746              	.L115:
 1747              		.loc 1 1525 25 is_stmt 1 discriminator 1 view .LVU438
 1748              		.loc 1 1525 7 is_stmt 0 discriminator 1 view .LVU439
 1749 003c 1DB1     		cbz	r5, .L116
 1750              	.LBE9:
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 4+8*i] , (uint16_t)input1[i].min);
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
ARM GAS  /tmp/cc14G55i.s 			page 61


1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
1534:Src/util.c    ****       }
1535:Src/util.c    ****       HAL_FLASH_Lock();
 1751              		.loc 1 1535 7 is_stmt 1 view .LVU440
 1752 003e FFF7FEFF 		bl	HAL_FLASH_Lock
 1753              	.LVL89:
 1754              	.L112:
1536:Src/util.c    ****     }
1537:Src/util.c    ****   #endif 
1538:Src/util.c    **** }
 1755              		.loc 1 1538 1 is_stmt 0 view .LVU441
 1756 0042 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1757              	.LVL90:
 1758              	.L116:
 1759              	.LBB10:
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1760              		.loc 1 1526 9 is_stmt 1 discriminator 3 view .LVU442
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1761              		.loc 1 1526 44 is_stmt 0 discriminator 3 view .LVU443
 1762 0046 EC00     		lsls	r4, r5, #3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1763              		.loc 1 1526 42 discriminator 3 view .LVU444
 1764 0048 E01C     		adds	r0, r4, #3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1765              		.loc 1 1526 69 discriminator 3 view .LVU445
 1766 004a 621B     		subs	r2, r4, r5
 1767 004c 5300     		lsls	r3, r2, #1
 1768 004e 294F     		ldr	r7, .L118+16
 1769 0050 1F44     		add	r7, r7, r3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1770              		.loc 1 1526 9 discriminator 3 view .LVU446
 1771 0052 264E     		ldr	r6, .L118+8
 1772 0054 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1773 0056 36F81000 		ldrh	r0, [r6, r0, lsl #1]
 1774 005a FFF7FEFF 		bl	EE_WriteVariable
 1775              	.LVL91:
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1776              		.loc 1 1527 9 is_stmt 1 discriminator 3 view .LVU447
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1777              		.loc 1 1527 42 is_stmt 0 discriminator 3 view .LVU448
 1778 005e 231D     		adds	r3, r4, #4
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1779              		.loc 1 1527 69 discriminator 3 view .LVU449
 1780 0060 B7F90610 		ldrsh	r1, [r7, #6]
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1781              		.loc 1 1527 9 discriminator 3 view .LVU450
 1782 0064 89B2     		uxth	r1, r1
 1783 0066 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1784 006a FFF7FEFF 		bl	EE_WriteVariable
 1785              	.LVL92:
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1786              		.loc 1 1528 9 is_stmt 1 discriminator 3 view .LVU451
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
ARM GAS  /tmp/cc14G55i.s 			page 62


 1787              		.loc 1 1528 42 is_stmt 0 discriminator 3 view .LVU452
 1788 006e 631D     		adds	r3, r4, #5
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1789              		.loc 1 1528 69 discriminator 3 view .LVU453
 1790 0070 B7F90810 		ldrsh	r1, [r7, #8]
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1791              		.loc 1 1528 9 discriminator 3 view .LVU454
 1792 0074 89B2     		uxth	r1, r1
 1793 0076 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1794 007a FFF7FEFF 		bl	EE_WriteVariable
 1795              	.LVL93:
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1796              		.loc 1 1529 9 is_stmt 1 discriminator 3 view .LVU455
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1797              		.loc 1 1529 42 is_stmt 0 discriminator 3 view .LVU456
 1798 007e A31D     		adds	r3, r4, #6
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1799              		.loc 1 1529 69 discriminator 3 view .LVU457
 1800 0080 B7F90A10 		ldrsh	r1, [r7, #10]
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1801              		.loc 1 1529 9 discriminator 3 view .LVU458
 1802 0084 89B2     		uxth	r1, r1
 1803 0086 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1804 008a FFF7FEFF 		bl	EE_WriteVariable
 1805              	.LVL94:
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1806              		.loc 1 1530 9 is_stmt 1 discriminator 3 view .LVU459
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1807              		.loc 1 1530 42 is_stmt 0 discriminator 3 view .LVU460
 1808 008e E21D     		adds	r2, r4, #7
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1809              		.loc 1 1530 69 discriminator 3 view .LVU461
 1810 0090 DFF86480 		ldr	r8, .L118+20
 1811 0094 631B     		subs	r3, r4, r5
 1812 0096 5F00     		lsls	r7, r3, #1
 1813 0098 4744     		add	r7, r7, r8
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1814              		.loc 1 1530 9 discriminator 3 view .LVU462
 1815 009a 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1816 009c 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 1817 00a0 FFF7FEFF 		bl	EE_WriteVariable
 1818              	.LVL95:
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1819              		.loc 1 1531 9 is_stmt 1 discriminator 3 view .LVU463
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1820              		.loc 1 1531 42 is_stmt 0 discriminator 3 view .LVU464
 1821 00a4 05F10109 		add	r9, r5, #1
 1822 00a8 4FEAC903 		lsl	r3, r9, #3
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1823              		.loc 1 1531 69 discriminator 3 view .LVU465
 1824 00ac B7F90610 		ldrsh	r1, [r7, #6]
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1825              		.loc 1 1531 9 discriminator 3 view .LVU466
 1826 00b0 89B2     		uxth	r1, r1
 1827 00b2 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1828 00b6 FFF7FEFF 		bl	EE_WriteVariable
 1829              	.LVL96:
ARM GAS  /tmp/cc14G55i.s 			page 63


1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1830              		.loc 1 1532 9 is_stmt 1 discriminator 3 view .LVU467
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1831              		.loc 1 1532 42 is_stmt 0 discriminator 3 view .LVU468
 1832 00ba 04F10903 		add	r3, r4, #9
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1833              		.loc 1 1532 69 discriminator 3 view .LVU469
 1834 00be B7F90810 		ldrsh	r1, [r7, #8]
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1835              		.loc 1 1532 9 discriminator 3 view .LVU470
 1836 00c2 89B2     		uxth	r1, r1
 1837 00c4 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1838 00c8 FFF7FEFF 		bl	EE_WriteVariable
 1839              	.LVL97:
1533:Src/util.c    ****       }
 1840              		.loc 1 1533 9 is_stmt 1 discriminator 3 view .LVU471
1533:Src/util.c    ****       }
 1841              		.loc 1 1533 42 is_stmt 0 discriminator 3 view .LVU472
 1842 00cc 04F10A02 		add	r2, r4, #10
1533:Src/util.c    ****       }
 1843              		.loc 1 1533 69 discriminator 3 view .LVU473
 1844 00d0 B7F90A10 		ldrsh	r1, [r7, #10]
1533:Src/util.c    ****       }
 1845              		.loc 1 1533 9 discriminator 3 view .LVU474
 1846 00d4 89B2     		uxth	r1, r1
 1847 00d6 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 1848 00da FFF7FEFF 		bl	EE_WriteVariable
 1849              	.LVL98:
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1850              		.loc 1 1525 38 is_stmt 1 discriminator 3 view .LVU475
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1851              		.loc 1 1525 39 is_stmt 0 discriminator 3 view .LVU476
 1852 00de 5FFA89F5 		uxtb	r5, r9
 1853              	.LVL99:
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1854              		.loc 1 1525 39 discriminator 3 view .LVU477
 1855 00e2 ABE7     		b	.L115
 1856              	.L119:
 1857              		.align	2
 1858              	.L118:
 1859 00e4 00000000 		.word	.LANCHOR25
 1860 00e8 00000000 		.word	.LANCHOR26
 1861 00ec 00000000 		.word	.LANCHOR13
 1862 00f0 00000000 		.word	rtP_Left
 1863 00f4 00000000 		.word	.LANCHOR14
 1864 00f8 00000000 		.word	.LANCHOR15
 1865              	.LBE10:
 1866              		.cfi_endproc
 1867              	.LFE89:
 1869              		.section	.text.poweroff,"ax",%progbits
 1870              		.align	1
 1871              		.global	poweroff
 1872              		.syntax unified
 1873              		.thumb
 1874              		.thumb_func
 1875              		.fpu softvfp
 1877              	poweroff:
ARM GAS  /tmp/cc14G55i.s 			page 64


 1878              	.LFB90:
1539:Src/util.c    **** 
1540:Src/util.c    **** 
1541:Src/util.c    **** void poweroff(void) {
 1879              		.loc 1 1541 21 is_stmt 1 view -0
 1880              		.cfi_startproc
 1881              		@ args = 0, pretend = 0, frame = 0
 1882              		@ frame_needed = 0, uses_anonymous_args = 0
 1883 0000 10B5     		push	{r4, lr}
 1884              	.LCFI14:
 1885              		.cfi_def_cfa_offset 8
 1886              		.cfi_offset 4, -8
 1887              		.cfi_offset 14, -4
1542:Src/util.c    ****   enable = 0;
 1888              		.loc 1 1542 3 view .LVU479
 1889              		.loc 1 1542 10 is_stmt 0 view .LVU480
 1890 0002 0024     		movs	r4, #0
 1891 0004 0B4B     		ldr	r3, .L125
 1892 0006 1C70     		strb	r4, [r3]
1543:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1544:Src/util.c    ****   printf("-- Motors disabled --\r\n");
1545:Src/util.c    ****   #endif
1546:Src/util.c    ****   buzzerCount = 0;  // prevent interraction with beep counter
 1893              		.loc 1 1546 3 is_stmt 1 view .LVU481
 1894              		.loc 1 1546 15 is_stmt 0 view .LVU482
 1895 0008 0B4B     		ldr	r3, .L125+4
 1896 000a 1C70     		strb	r4, [r3]
1547:Src/util.c    ****   buzzerPattern = 0;
 1897              		.loc 1 1547 3 is_stmt 1 view .LVU483
 1898              		.loc 1 1547 17 is_stmt 0 view .LVU484
 1899 000c 0B4B     		ldr	r3, .L125+8
 1900 000e 1C70     		strb	r4, [r3]
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1901              		.loc 1 1548 3 is_stmt 1 view .LVU485
 1902              	.LBB11:
 1903              		.loc 1 1548 8 view .LVU486
 1904              	.LVL100:
 1905              		.loc 1 1548 3 is_stmt 0 view .LVU487
 1906 0010 05E0     		b	.L121
 1907              	.LVL101:
 1908              	.L122:
1549:Src/util.c    ****     buzzerFreq = (uint8_t)i;
 1909              		.loc 1 1549 5 is_stmt 1 discriminator 3 view .LVU488
 1910              		.loc 1 1549 16 is_stmt 0 discriminator 3 view .LVU489
 1911 0012 0B4B     		ldr	r3, .L125+12
 1912 0014 1C70     		strb	r4, [r3]
1550:Src/util.c    ****     HAL_Delay(100);
 1913              		.loc 1 1550 5 is_stmt 1 discriminator 3 view .LVU490
 1914 0016 6420     		movs	r0, #100
 1915 0018 FFF7FEFF 		bl	HAL_Delay
 1916              	.LVL102:
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1917              		.loc 1 1548 26 discriminator 3 view .LVU491
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1918              		.loc 1 1548 27 is_stmt 0 discriminator 3 view .LVU492
 1919 001c 0134     		adds	r4, r4, #1
 1920              	.LVL103:
ARM GAS  /tmp/cc14G55i.s 			page 65


 1921              	.L121:
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1922              		.loc 1 1548 19 is_stmt 1 discriminator 1 view .LVU493
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1923              		.loc 1 1548 3 is_stmt 0 discriminator 1 view .LVU494
 1924 001e 072C     		cmp	r4, #7
 1925 0020 F7DD     		ble	.L122
 1926              	.LBE11:
1551:Src/util.c    ****   }
1552:Src/util.c    ****   saveConfig();
 1927              		.loc 1 1552 3 is_stmt 1 view .LVU495
 1928 0022 FFF7FEFF 		bl	saveConfig
 1929              	.LVL104:
1553:Src/util.c    ****   HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_RESET);
 1930              		.loc 1 1553 3 view .LVU496
 1931 0026 0022     		movs	r2, #0
 1932 0028 2021     		movs	r1, #32
 1933 002a 0648     		ldr	r0, .L125+16
 1934 002c FFF7FEFF 		bl	HAL_GPIO_WritePin
 1935              	.LVL105:
 1936              	.L123:
1554:Src/util.c    ****   while(1) {}
 1937              		.loc 1 1554 3 discriminator 1 view .LVU497
 1938              		.loc 1 1554 13 discriminator 1 view .LVU498
 1939              		.loc 1 1554 8 discriminator 1 view .LVU499
 1940 0030 FEE7     		b	.L123
 1941              	.L126:
 1942 0032 00BF     		.align	2
 1943              	.L125:
 1944 0034 00000000 		.word	enable
 1945 0038 00000000 		.word	buzzerCount
 1946 003c 00000000 		.word	buzzerPattern
 1947 0040 00000000 		.word	buzzerFreq
 1948 0044 00080140 		.word	1073809408
 1949              		.cfi_endproc
 1950              	.LFE90:
 1952              		.section	.text.filtLowPass32,"ax",%progbits
 1953              		.align	1
 1954              		.global	filtLowPass32
 1955              		.syntax unified
 1956              		.thumb
 1957              		.thumb_func
 1958              		.fpu softvfp
 1960              	filtLowPass32:
 1961              	.LVL106:
 1962              	.LFB92:
1555:Src/util.c    **** }
1556:Src/util.c    **** 
1557:Src/util.c    **** 
1558:Src/util.c    **** void poweroffPressCheck(void) {
1559:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1560:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1561:Src/util.c    ****       uint16_t cnt_press = 0;
1562:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1563:Src/util.c    ****         HAL_Delay(10);
1564:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
1565:Src/util.c    ****       }
ARM GAS  /tmp/cc14G55i.s 			page 66


1566:Src/util.c    **** 
1567:Src/util.c    ****       if (cnt_press > 8) enable = 0;
1568:Src/util.c    **** 
1569:Src/util.c    ****       if (cnt_press >= 5 * 100) {                         // Check if press is more than 5 sec
1570:Src/util.c    ****         HAL_Delay(1000);
1571:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
1572:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1573:Src/util.c    ****           beepLong(8);
1574:Src/util.c    ****           updateCurSpdLim();
1575:Src/util.c    ****           beepShort(5);
1576:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
1577:Src/util.c    ****           #ifdef AUTO_CALIBRATION_ENA
1578:Src/util.c    ****           beepLong(16); 
1579:Src/util.c    ****           adcCalibLim();
1580:Src/util.c    ****           beepShort(5);
1581:Src/util.c    ****           #endif
1582:Src/util.c    ****         }
1583:Src/util.c    ****       } else if (cnt_press > 8) {                         // Short press: power off (80 ms debounce
1584:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1585:Src/util.c    ****           printf("Powering off, button has been pressed\r\n");
1586:Src/util.c    ****         #endif
1587:Src/util.c    ****       poweroff();
1588:Src/util.c    ****       }
1589:Src/util.c    ****     }
1590:Src/util.c    ****   #elif defined(VARIANT_TRANSPOTTER)
1591:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1592:Src/util.c    ****       enable = 0;
1593:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1594:Src/util.c    ****       beepShort(5);
1595:Src/util.c    ****       HAL_Delay(300);
1596:Src/util.c    ****       if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1597:Src/util.c    ****         while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1598:Src/util.c    ****         beepLong(5);
1599:Src/util.c    ****         HAL_Delay(350);
1600:Src/util.c    ****         poweroff();
1601:Src/util.c    ****       } else {
1602:Src/util.c    ****         setDistance += 0.25;
1603:Src/util.c    ****         if (setDistance > 2.6) {
1604:Src/util.c    ****           setDistance = 0.5;
1605:Src/util.c    ****         }
1606:Src/util.c    ****         beepShort(setDistance / 0.25);
1607:Src/util.c    ****         saveValue = setDistance * 1000;
1608:Src/util.c    ****         saveValue_valid = 1;
1609:Src/util.c    ****       }
1610:Src/util.c    ****     }
1611:Src/util.c    ****   #else
1612:Src/util.c    ****     if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1613:Src/util.c    ****       enable = 0;                                             // disable motors
1614:Src/util.c    ****       while (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {}    // wait until button is released
1615:Src/util.c    ****       poweroff();                                             // release power-latch
1616:Src/util.c    ****     }
1617:Src/util.c    ****   #endif
1618:Src/util.c    **** }
1619:Src/util.c    **** 
1620:Src/util.c    **** 
1621:Src/util.c    **** 
1622:Src/util.c    **** /* =========================== Filtering Functions =========================== */
ARM GAS  /tmp/cc14G55i.s 			page 67


1623:Src/util.c    **** 
1624:Src/util.c    ****   /* Low pass filter fixed-point 32 bits: fixdt(1,32,16)
1625:Src/util.c    ****   * Max:  32767.99998474121
1626:Src/util.c    ****   * Min: -32768
1627:Src/util.c    ****   * Res:  1.52587890625e-05
1628:Src/util.c    ****   * 
1629:Src/util.c    ****   * Inputs:       u     = int16 or int32
1630:Src/util.c    ****   * Outputs:      y     = fixdt(1,32,16)
1631:Src/util.c    ****   * Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1632:Src/util.c    ****   * 
1633:Src/util.c    ****   * Example: 
1634:Src/util.c    ****   * If coef = 0.8 (in floating point), then coef = 0.8 * 2^16 = 52429 (in fixed-point)
1635:Src/util.c    ****   * filtLowPass16(u, 52429, &y);
1636:Src/util.c    ****   * yint = (int16_t)(y >> 16); // the integer output is the fixed-point ouput shifted by 16 bits
1637:Src/util.c    ****   */
1638:Src/util.c    **** void filtLowPass32(int32_t u, uint16_t coef, int32_t *y) {
 1963              		.loc 1 1638 58 view -0
 1964              		.cfi_startproc
 1965              		@ args = 0, pretend = 0, frame = 0
 1966              		@ frame_needed = 0, uses_anonymous_args = 0
 1967              		@ link register save eliminated.
 1968              		.loc 1 1638 58 is_stmt 0 view .LVU501
 1969 0000 10B4     		push	{r4}
 1970              	.LCFI15:
 1971              		.cfi_def_cfa_offset 4
 1972              		.cfi_offset 4, -4
1639:Src/util.c    ****   int64_t tmp;  
 1973              		.loc 1 1639 3 is_stmt 1 view .LVU502
1640:Src/util.c    ****   tmp = ((int64_t)((u << 4) - (*y >> 12)) * coef) >> 4;
 1974              		.loc 1 1640 3 view .LVU503
 1975              		.loc 1 1640 32 is_stmt 0 view .LVU504
 1976 0002 1468     		ldr	r4, [r2]
 1977              		.loc 1 1640 35 view .LVU505
 1978 0004 2313     		asrs	r3, r4, #12
 1979              		.loc 1 1640 29 view .LVU506
 1980 0006 C3EB0010 		rsb	r0, r3, r0, lsl #4
 1981              	.LVL107:
 1982              		.loc 1 1640 10 view .LVU507
 1983 000a 4FEAE07C 		asr	ip, r0, #31
 1984              		.loc 1 1640 43 view .LVU508
 1985 000e A1FB0003 		umull	r0, r3, r1, r0
 1986 0012 01FB0C31 		mla	r1, r1, ip, r3
 1987              	.LVL108:
 1988              		.loc 1 1640 7 view .LVU509
 1989 0016 0009     		lsrs	r0, r0, #4
 1990 0018 40EA0170 		orr	r0, r0, r1, lsl #28
 1991 001c 0911     		asrs	r1, r1, #4
 1992              	.LVL109:
1641:Src/util.c    ****   tmp = CLAMP(tmp, -2147483648LL, 2147483647LL);  // Overflow protection: 2147483647LL = 2^31 - 1
 1993              		.loc 1 1641 3 is_stmt 1 view .LVU510
 1994              		.loc 1 1641 9 is_stmt 0 view .LVU511
 1995 001e B0F1004F 		cmp	r0, #-2147483648
 1996 0022 71F10003 		sbcs	r3, r1, #0
 1997 0026 08DA     		bge	.L130
 1998              		.loc 1 1641 9 discriminator 1 view .LVU512
 1999 0028 0346     		mov	r3, r0
 2000 002a B0F1004F 		cmp	r0, #-2147483648
ARM GAS  /tmp/cc14G55i.s 			page 68


 2001 002e 71F1FF31 		sbcs	r1, r1, #-1
 2002              	.LVL110:
 2003              		.loc 1 1641 9 discriminator 1 view .LVU513
 2004 0032 04DA     		bge	.L128
 2005 0034 4FF00043 		mov	r3, #-2147483648
 2006 0038 01E0     		b	.L128
 2007              	.LVL111:
 2008              	.L130:
 2009              		.loc 1 1641 9 view .LVU514
 2010 003a 6FF00043 		mvn	r3, #-2147483648
 2011              	.LVL112:
 2012              	.L128:
1642:Src/util.c    ****   *y = (int32_t)tmp + (*y);
 2013              		.loc 1 1642 3 is_stmt 1 discriminator 4 view .LVU515
 2014              		.loc 1 1642 21 is_stmt 0 discriminator 4 view .LVU516
 2015 003e 1C44     		add	r4, r4, r3
 2016              		.loc 1 1642 6 discriminator 4 view .LVU517
 2017 0040 1460     		str	r4, [r2]
1643:Src/util.c    **** }
 2018              		.loc 1 1643 1 discriminator 4 view .LVU518
 2019 0042 10BC     		pop	{r4}
 2020              	.LCFI16:
 2021              		.cfi_restore 4
 2022              		.cfi_def_cfa_offset 0
 2023 0044 7047     		bx	lr
 2024              		.cfi_endproc
 2025              	.LFE92:
 2027              		.section	.text.adcCalibLim,"ax",%progbits
 2028              		.align	1
 2029              		.global	adcCalibLim
 2030              		.syntax unified
 2031              		.thumb
 2032              		.thumb_func
 2033              		.fpu softvfp
 2035              	adcCalibLim:
 2036              	.LFB75:
 500:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 2037              		.loc 1 500 24 is_stmt 1 view -0
 2038              		.cfi_startproc
 2039              		@ args = 0, pretend = 0, frame = 16
 2040              		@ frame_needed = 0, uses_anonymous_args = 0
 2041 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2042              	.LCFI17:
 2043              		.cfi_def_cfa_offset 36
 2044              		.cfi_offset 4, -36
 2045              		.cfi_offset 5, -32
 2046              		.cfi_offset 6, -28
 2047              		.cfi_offset 7, -24
 2048              		.cfi_offset 8, -20
 2049              		.cfi_offset 9, -16
 2050              		.cfi_offset 10, -12
 2051              		.cfi_offset 11, -8
 2052              		.cfi_offset 14, -4
 2053 0004 85B0     		sub	sp, sp, #20
 2054              	.LCFI18:
 2055              		.cfi_def_cfa_offset 56
 502:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
ARM GAS  /tmp/cc14G55i.s 			page 69


 2056              		.loc 1 502 3 view .LVU520
 2057 0006 FFF7FEFF 		bl	calcAvgSpeed
 2058              	.LVL113:
 503:Src/util.c    ****     return;
 2059              		.loc 1 503 3 view .LVU521
 503:Src/util.c    ****     return;
 2060              		.loc 1 503 19 is_stmt 0 view .LVU522
 2061 000a 564B     		ldr	r3, .L150
 2062 000c B3F90030 		ldrsh	r3, [r3]
 503:Src/util.c    ****     return;
 2063              		.loc 1 503 6 view .LVU523
 2064 0010 052B     		cmp	r3, #5
 2065 0012 02DD     		ble	.L149
 2066              	.L132:
 604:Src/util.c    ****  /*
 2067              		.loc 1 604 1 view .LVU524
 2068 0014 05B0     		add	sp, sp, #20
 2069              	.LCFI19:
 2070              		.cfi_remember_state
 2071              		.cfi_def_cfa_offset 36
 2072              		@ sp needed
 2073 0016 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2074              	.L149:
 2075              	.LCFI20:
 2076              		.cfi_restore_state
 513:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 2077              		.loc 1 513 3 is_stmt 1 view .LVU525
 2078 001a FFF7FEFF 		bl	readInputRaw
 2079              	.LVL114:
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2080              		.loc 1 515 3 view .LVU526
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2081              		.loc 1 515 40 is_stmt 0 view .LVU527
 2082 001e 524B     		ldr	r3, .L150+4
 2083 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2084 0022 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2085 0026 514A     		ldr	r2, .L150+8
 2086 0028 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2087              		.loc 1 515 45 view .LVU528
 2088 002c 1204     		lsls	r2, r2, #16
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2089              		.loc 1 515 12 view .LVU529
 2090 002e 0392     		str	r2, [sp, #12]
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2091              		.loc 1 516 3 is_stmt 1 view .LVU530
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2092              		.loc 1 516 40 is_stmt 0 view .LVU531
 2093 0030 4F4A     		ldr	r2, .L150+12
 2094 0032 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2095              		.loc 1 516 45 view .LVU532
 2096 0036 1204     		lsls	r2, r2, #16
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2097              		.loc 1 516 12 view .LVU533
 2098 0038 0292     		str	r2, [sp, #8]
 517:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
ARM GAS  /tmp/cc14G55i.s 			page 70


 2099              		.loc 1 517 3 is_stmt 1 view .LVU534
 2100              	.LVL115:
 518:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 2101              		.loc 1 518 3 view .LVU535
 519:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 2102              		.loc 1 519 3 view .LVU536
 520:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 2103              		.loc 1 520 3 view .LVU537
 521:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 2104              		.loc 1 521 3 view .LVU538
 522:Src/util.c    ****   int16_t  input_margin    = 0;
 2105              		.loc 1 522 3 view .LVU539
 523:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2106              		.loc 1 523 3 view .LVU540
 524:Src/util.c    ****   
 2107              		.loc 1 524 3 view .LVU541
 527:Src/util.c    ****     input_margin = ADC_MARGIN;
 2108              		.loc 1 527 3 view .LVU542
 527:Src/util.c    ****     input_margin = ADC_MARGIN;
 2109              		.loc 1 527 6 is_stmt 0 view .LVU543
 2110 003a 002B     		cmp	r3, #0
 2111 003c 00F08E80 		beq	.L144
 523:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2112              		.loc 1 523 12 view .LVU544
 2113 0040 0023     		movs	r3, #0
 2114 0042 0193     		str	r3, [sp, #4]
 2115              	.L135:
 2116              	.LVL116:
 523:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2117              		.loc 1 523 12 view .LVU545
 2118 0044 0025     		movs	r5, #0
 2119 0046 DFF82C81 		ldr	r8, .L150+16
 2120 004a 2E46     		mov	r6, r5
 2121 004c 47F6FF79 		movw	r9, #32767
 2122 0050 C246     		mov	r10, r8
 2123 0052 2F46     		mov	r7, r5
 2124 0054 CB46     		mov	fp, r9
 2125 0056 2CE0     		b	.L137
 2126              	.LVL117:
 2127              	.L139:
 534:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2128              		.loc 1 534 5 is_stmt 1 view .LVU546
 2129 0058 FFF7FEFF 		bl	readInputRaw
 2130              	.LVL118:
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2131              		.loc 1 535 5 view .LVU547
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2132              		.loc 1 535 32 is_stmt 0 view .LVU548
 2133 005c 424D     		ldr	r5, .L150+4
 2134 005e 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2135 0060 C3EBC303 		rsb	r3, r3, r3, lsl #3
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2136              		.loc 1 535 5 view .LVU549
 2137 0064 03AA     		add	r2, sp, #12
 2138 0066 41F69911 		movw	r1, #6553
 2139 006a 4048     		ldr	r0, .L150+8
 2140 006c 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
ARM GAS  /tmp/cc14G55i.s 			page 71


 2141 0070 FFF7FEFF 		bl	filtLowPass32
 2142              	.LVL119:
 536:Src/util.c    ****     
 2143              		.loc 1 536 5 is_stmt 1 view .LVU550
 536:Src/util.c    ****     
 2144              		.loc 1 536 32 is_stmt 0 view .LVU551
 2145 0074 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2146 0076 C3EBC303 		rsb	r3, r3, r3, lsl #3
 536:Src/util.c    ****     
 2147              		.loc 1 536 5 view .LVU552
 2148 007a 02AA     		add	r2, sp, #8
 2149 007c 41F69911 		movw	r1, #6553
 2150 0080 3B48     		ldr	r0, .L150+12
 2151 0082 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2152 0086 FFF7FEFF 		bl	filtLowPass32
 2153              	.LVL120:
 538:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2154              		.loc 1 538 5 is_stmt 1 view .LVU553
 538:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2155              		.loc 1 538 21 is_stmt 0 view .LVU554
 2156 008a BDF90E70 		ldrsh	r7, [sp, #14]
 2157              	.LVL121:
 539:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2158              		.loc 1 539 5 is_stmt 1 view .LVU555
 539:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2159              		.loc 1 539 21 is_stmt 0 view .LVU556
 2160 008e BDF90A60 		ldrsh	r6, [sp, #10]
 2161              	.LVL122:
 540:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2162              		.loc 1 540 5 is_stmt 1 view .LVU557
 540:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2163              		.loc 1 540 21 is_stmt 0 view .LVU558
 2164 0092 BB45     		cmp	fp, r7
 2165 0094 A8BF     		it	ge
 2166 0096 BB46     		movge	fp, r7
 2167              	.LVL123:
 541:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2168              		.loc 1 541 5 is_stmt 1 view .LVU559
 541:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2169              		.loc 1 541 21 is_stmt 0 view .LVU560
 2170 0098 BA45     		cmp	r10, r7
 2171 009a B8BF     		it	lt
 2172 009c BA46     		movlt	r10, r7
 2173              	.LVL124:
 542:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2174              		.loc 1 542 5 is_stmt 1 view .LVU561
 542:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2175              		.loc 1 542 21 is_stmt 0 view .LVU562
 2176 009e B145     		cmp	r9, r6
 2177 00a0 A8BF     		it	ge
 2178 00a2 B146     		movge	r9, r6
 2179              	.LVL125:
 543:Src/util.c    ****     HAL_Delay(5);
 2180              		.loc 1 543 5 is_stmt 1 view .LVU563
 543:Src/util.c    ****     HAL_Delay(5);
 2181              		.loc 1 543 21 is_stmt 0 view .LVU564
 2182 00a4 B045     		cmp	r8, r6
ARM GAS  /tmp/cc14G55i.s 			page 72


 2183 00a6 B8BF     		it	lt
 2184 00a8 B046     		movlt	r8, r6
 2185              	.LVL126:
 544:Src/util.c    ****   }
 2186              		.loc 1 544 5 is_stmt 1 view .LVU565
 2187 00aa 0520     		movs	r0, #5
 2188 00ac FFF7FEFF 		bl	HAL_Delay
 2189              	.LVL127:
 533:Src/util.c    ****     readInputRaw();
 2190              		.loc 1 533 73 is_stmt 0 view .LVU566
 2191 00b0 2546     		mov	r5, r4
 2192              	.LVL128:
 2193              	.L137:
 533:Src/util.c    ****     readInputRaw();
 2194              		.loc 1 533 9 is_stmt 1 view .LVU567
 533:Src/util.c    ****     readInputRaw();
 2195              		.loc 1 533 11 is_stmt 0 view .LVU568
 2196 00b2 0221     		movs	r1, #2
 2197 00b4 3048     		ldr	r0, .L150+20
 2198 00b6 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2199              	.LVL129:
 533:Src/util.c    ****     readInputRaw();
 2200              		.loc 1 533 9 view .LVU569
 2201 00ba 20B9     		cbnz	r0, .L138
 533:Src/util.c    ****     readInputRaw();
 2202              		.loc 1 533 73 discriminator 1 view .LVU570
 2203 00bc 6C1C     		adds	r4, r5, #1
 2204 00be A4B2     		uxth	r4, r4
 2205              	.LVL130:
 533:Src/util.c    ****     readInputRaw();
 2206              		.loc 1 533 53 discriminator 1 view .LVU571
 2207 00c0 B5F57A6F 		cmp	r5, #4000
 2208 00c4 C8D3     		bcc	.L139
 2209              	.LVL131:
 2210              	.L138:
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2211              		.loc 1 550 3 is_stmt 1 view .LVU572
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2212              		.loc 1 550 27 is_stmt 0 view .LVU573
 2213 00c6 5246     		mov	r2, r10
 2214 00c8 3946     		mov	r1, r7
 2215 00ca 5846     		mov	r0, fp
 2216 00cc FFF7FEFF 		bl	checkInputType
 2217              	.LVL132:
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2218              		.loc 1 550 11 view .LVU574
 2219 00d0 C4B2     		uxtb	r4, r0
 2220              	.LVL133:
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2221              		.loc 1 551 3 is_stmt 1 view .LVU575
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2222              		.loc 1 551 37 is_stmt 0 view .LVU576
 2223 00d2 254B     		ldr	r3, .L150+4
 2224 00d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2225 00d6 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2226 00da 244A     		ldr	r2, .L150+8
 2227 00dc 02EB4303 		add	r3, r2, r3, lsl #1
ARM GAS  /tmp/cc14G55i.s 			page 73


 2228 00e0 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2229              		.loc 1 551 6 view .LVU577
 2230 00e2 A342     		cmp	r3, r4
 2231 00e4 02D0     		beq	.L140
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2232              		.loc 1 551 45 discriminator 1 view .LVU578
 2233 00e6 032B     		cmp	r3, #3
 2234 00e8 00D0     		beq	.L140
 556:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2235              		.loc 1 556 19 view .LVU579
 2236 00ea 0024     		movs	r4, #0
 2237              	.LVL134:
 2238              	.L140:
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2239              		.loc 1 565 3 is_stmt 1 view .LVU580
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2240              		.loc 1 565 27 is_stmt 0 view .LVU581
 2241 00ec 4246     		mov	r2, r8
 2242 00ee 3146     		mov	r1, r6
 2243 00f0 4846     		mov	r0, r9
 2244 00f2 FFF7FEFF 		bl	checkInputType
 2245              	.LVL135:
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2246              		.loc 1 565 11 view .LVU582
 2247 00f6 C0B2     		uxtb	r0, r0
 2248              	.LVL136:
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2249              		.loc 1 566 3 is_stmt 1 view .LVU583
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2250              		.loc 1 566 37 is_stmt 0 view .LVU584
 2251 00f8 1B4B     		ldr	r3, .L150+4
 2252 00fa 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2253 00fc C3EBC301 		rsb	r1, r3, r3, lsl #3
 2254 0100 1B4A     		ldr	r2, .L150+12
 2255 0102 02EB4102 		add	r2, r2, r1, lsl #1
 2256 0106 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2257              		.loc 1 566 6 view .LVU585
 2258 0108 8242     		cmp	r2, r0
 2259 010a 02D0     		beq	.L141
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2260              		.loc 1 566 45 discriminator 1 view .LVU586
 2261 010c 032A     		cmp	r2, #3
 2262 010e 00D0     		beq	.L141
 571:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2263              		.loc 1 571 19 view .LVU587
 2264 0110 0020     		movs	r0, #0
 2265              	.LVL137:
 2266              	.L141:
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2267              		.loc 1 579 3 is_stmt 1 view .LVU588
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2268              		.loc 1 579 6 is_stmt 0 view .LVU589
 2269 0112 14B9     		cbnz	r4, .L142
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2270              		.loc 1 579 26 discriminator 1 view .LVU590
ARM GAS  /tmp/cc14G55i.s 			page 74


 2271 0114 0028     		cmp	r0, #0
 2272 0116 3FF47DAF 		beq	.L132
 2273              	.L142:
 580:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2274              		.loc 1 580 5 is_stmt 1 view .LVU591
 580:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2275              		.loc 1 580 23 is_stmt 0 view .LVU592
 2276 011a C3EBC301 		rsb	r1, r3, r3, lsl #3
 2277 011e 134A     		ldr	r2, .L150+8
 2278 0120 02EB4102 		add	r2, r2, r1, lsl #1
 2279 0124 1471     		strb	r4, [r2, #4]
 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2280              		.loc 1 581 5 is_stmt 1 view .LVU593
 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2281              		.loc 1 581 41 is_stmt 0 view .LVU594
 2282 0126 019C     		ldr	r4, [sp, #4]
 2283              	.LVL138:
 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2284              		.loc 1 581 41 view .LVU595
 2285 0128 A344     		add	fp, fp, r4
 2286              	.LVL139:
 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2287              		.loc 1 581 23 view .LVU596
 2288 012a A2F806B0 		strh	fp, [r2, #6]	@ movhi
 582:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2289              		.loc 1 582 5 is_stmt 1 view .LVU597
 582:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2290              		.loc 1 582 23 is_stmt 0 view .LVU598
 2291 012e 1781     		strh	r7, [r2, #8]	@ movhi
 583:Src/util.c    **** 
 2292              		.loc 1 583 5 is_stmt 1 view .LVU599
 583:Src/util.c    **** 
 2293              		.loc 1 583 41 is_stmt 0 view .LVU600
 2294 0130 AAEB040A 		sub	r10, r10, r4
 2295              	.LVL140:
 583:Src/util.c    **** 
 2296              		.loc 1 583 23 view .LVU601
 2297 0134 A2F80AA0 		strh	r10, [r2, #10]	@ movhi
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2298              		.loc 1 585 5 is_stmt 1 view .LVU602
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2299              		.loc 1 585 23 is_stmt 0 view .LVU603
 2300 0138 0D49     		ldr	r1, .L150+12
 2301 013a C3EBC302 		rsb	r2, r3, r3, lsl #3
 2302              	.LVL141:
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2303              		.loc 1 585 23 view .LVU604
 2304 013e 01EB4202 		add	r2, r1, r2, lsl #1
 2305              	.LVL142:
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2306              		.loc 1 585 23 view .LVU605
 2307 0142 1071     		strb	r0, [r2, #4]
 586:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2308              		.loc 1 586 5 is_stmt 1 view .LVU606
 586:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2309              		.loc 1 586 41 is_stmt 0 view .LVU607
 2310 0144 A144     		add	r9, r9, r4
ARM GAS  /tmp/cc14G55i.s 			page 75


 2311              	.LVL143:
 586:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2312              		.loc 1 586 23 view .LVU608
 2313 0146 A2F80690 		strh	r9, [r2, #6]	@ movhi
 587:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2314              		.loc 1 587 5 is_stmt 1 view .LVU609
 587:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2315              		.loc 1 587 23 is_stmt 0 view .LVU610
 2316 014a 1681     		strh	r6, [r2, #8]	@ movhi
 588:Src/util.c    **** 
 2317              		.loc 1 588 5 is_stmt 1 view .LVU611
 588:Src/util.c    **** 
 2318              		.loc 1 588 41 is_stmt 0 view .LVU612
 2319 014c A8EB0408 		sub	r8, r8, r4
 2320              	.LVL144:
 588:Src/util.c    **** 
 2321              		.loc 1 588 23 view .LVU613
 2322 0150 A2F80A80 		strh	r8, [r2, #10]	@ movhi
 590:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2323              		.loc 1 590 5 is_stmt 1 view .LVU614
 590:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2324              		.loc 1 590 19 is_stmt 0 view .LVU615
 2325 0154 094B     		ldr	r3, .L150+24
 2326              	.LVL145:
 590:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2327              		.loc 1 590 19 view .LVU616
 2328 0156 0122     		movs	r2, #1
 2329 0158 1A70     		strb	r2, [r3]
 2330 015a 5BE7     		b	.L132
 2331              	.LVL146:
 2332              	.L144:
 528:Src/util.c    ****   }
 2333              		.loc 1 528 18 view .LVU617
 2334 015c 6423     		movs	r3, #100
 2335 015e 0193     		str	r3, [sp, #4]
 2336 0160 70E7     		b	.L135
 2337              	.L151:
 2338 0162 00BF     		.align	2
 2339              	.L150:
 2340 0164 00000000 		.word	.LANCHOR12
 2341 0168 00000000 		.word	.LANCHOR16
 2342 016c 00000000 		.word	.LANCHOR14
 2343 0170 00000000 		.word	.LANCHOR15
 2344 0174 0080FFFF 		.word	-32768
 2345 0178 00080140 		.word	1073809408
 2346 017c 00000000 		.word	.LANCHOR25
 2347              		.cfi_endproc
 2348              	.LFE75:
 2350              		.section	.text.updateCurSpdLim,"ax",%progbits
 2351              		.align	1
 2352              		.global	updateCurSpdLim
 2353              		.syntax unified
 2354              		.thumb
 2355              		.thumb_func
 2356              		.fpu softvfp
 2358              	updateCurSpdLim:
 2359              	.LFB76:
ARM GAS  /tmp/cc14G55i.s 			page 76


 612:Src/util.c    ****   calcAvgSpeed();
 2360              		.loc 1 612 28 is_stmt 1 view -0
 2361              		.cfi_startproc
 2362              		@ args = 0, pretend = 0, frame = 8
 2363              		@ frame_needed = 0, uses_anonymous_args = 0
 2364 0000 30B5     		push	{r4, r5, lr}
 2365              	.LCFI21:
 2366              		.cfi_def_cfa_offset 12
 2367              		.cfi_offset 4, -12
 2368              		.cfi_offset 5, -8
 2369              		.cfi_offset 14, -4
 2370 0002 83B0     		sub	sp, sp, #12
 2371              	.LCFI22:
 2372              		.cfi_def_cfa_offset 24
 613:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2373              		.loc 1 613 3 view .LVU619
 2374 0004 FFF7FEFF 		bl	calcAvgSpeed
 2375              	.LVL147:
 614:Src/util.c    ****     return;
 2376              		.loc 1 614 3 view .LVU620
 614:Src/util.c    ****     return;
 2377              		.loc 1 614 19 is_stmt 0 view .LVU621
 2378 0008 514B     		ldr	r3, .L165
 2379 000a B3F90030 		ldrsh	r3, [r3]
 614:Src/util.c    ****     return;
 2380              		.loc 1 614 6 view .LVU622
 2381 000e 052B     		cmp	r3, #5
 2382 0010 00F39680 		bgt	.L152
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2383              		.loc 1 624 3 is_stmt 1 view .LVU623
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2384              		.loc 1 624 40 is_stmt 0 view .LVU624
 2385 0014 4F4B     		ldr	r3, .L165+4
 2386 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2387 0018 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2388 001c 4E4A     		ldr	r2, .L165+8
 2389 001e 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2390              		.loc 1 624 45 view .LVU625
 2391 0022 1204     		lsls	r2, r2, #16
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2392              		.loc 1 624 12 view .LVU626
 2393 0024 0192     		str	r2, [sp, #4]
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2394              		.loc 1 625 3 is_stmt 1 view .LVU627
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2395              		.loc 1 625 40 is_stmt 0 view .LVU628
 2396 0026 4D4A     		ldr	r2, .L165+12
 2397 0028 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2398              		.loc 1 625 45 view .LVU629
 2399 002c 1B04     		lsls	r3, r3, #16
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2400              		.loc 1 625 12 view .LVU630
 2401 002e 0093     		str	r3, [sp]
 626:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 2402              		.loc 1 626 3 is_stmt 1 view .LVU631
ARM GAS  /tmp/cc14G55i.s 			page 77


 627:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 2403              		.loc 1 627 3 view .LVU632
 628:Src/util.c    ****   cur_spd_valid = 0;
 2404              		.loc 1 628 3 view .LVU633
 2405              	.LVL148:
 629:Src/util.c    **** 
 2406              		.loc 1 629 3 view .LVU634
 629:Src/util.c    **** 
 2407              		.loc 1 629 17 is_stmt 0 view .LVU635
 2408 0030 0024     		movs	r4, #0
 2409 0032 4B4B     		ldr	r3, .L165+16
 2410 0034 1C70     		strb	r4, [r3]
 632:Src/util.c    ****     readInputRaw();
 2411              		.loc 1 632 3 is_stmt 1 view .LVU636
 632:Src/util.c    ****     readInputRaw();
 2412              		.loc 1 632 9 is_stmt 0 view .LVU637
 2413 0036 1CE0     		b	.L155
 2414              	.LVL149:
 2415              	.L157:
 633:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2416              		.loc 1 633 5 is_stmt 1 view .LVU638
 2417 0038 FFF7FEFF 		bl	readInputRaw
 2418              	.LVL150:
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2419              		.loc 1 634 5 view .LVU639
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2420              		.loc 1 634 32 is_stmt 0 view .LVU640
 2421 003c 454C     		ldr	r4, .L165+4
 2422 003e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2423 0040 C3EBC303 		rsb	r3, r3, r3, lsl #3
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2424              		.loc 1 634 5 view .LVU641
 2425 0044 01AA     		add	r2, sp, #4
 2426 0046 41F69911 		movw	r1, #6553
 2427 004a 4348     		ldr	r0, .L165+8
 2428 004c 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2429 0050 FFF7FEFF 		bl	filtLowPass32
 2430              	.LVL151:
 635:Src/util.c    ****     HAL_Delay(5);
 2431              		.loc 1 635 5 is_stmt 1 view .LVU642
 635:Src/util.c    ****     HAL_Delay(5);
 2432              		.loc 1 635 32 is_stmt 0 view .LVU643
 2433 0054 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2434 0056 C3EBC303 		rsb	r3, r3, r3, lsl #3
 635:Src/util.c    ****     HAL_Delay(5);
 2435              		.loc 1 635 5 view .LVU644
 2436 005a 6A46     		mov	r2, sp
 2437 005c 41F69911 		movw	r1, #6553
 2438 0060 3E48     		ldr	r0, .L165+12
 2439 0062 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2440 0066 FFF7FEFF 		bl	filtLowPass32
 2441              	.LVL152:
 636:Src/util.c    ****   }
 2442              		.loc 1 636 5 is_stmt 1 view .LVU645
 2443 006a 0520     		movs	r0, #5
 2444 006c FFF7FEFF 		bl	HAL_Delay
 2445              	.LVL153:
ARM GAS  /tmp/cc14G55i.s 			page 78


 632:Src/util.c    ****     readInputRaw();
 2446              		.loc 1 632 71 is_stmt 0 view .LVU646
 2447 0070 2C46     		mov	r4, r5
 2448              	.LVL154:
 2449              	.L155:
 632:Src/util.c    ****     readInputRaw();
 2450              		.loc 1 632 9 is_stmt 1 view .LVU647
 632:Src/util.c    ****     readInputRaw();
 2451              		.loc 1 632 11 is_stmt 0 view .LVU648
 2452 0072 0221     		movs	r1, #2
 2453 0074 3B48     		ldr	r0, .L165+20
 2454 0076 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2455              	.LVL155:
 632:Src/util.c    ****     readInputRaw();
 2456              		.loc 1 632 9 view .LVU649
 2457 007a 20B9     		cbnz	r0, .L156
 632:Src/util.c    ****     readInputRaw();
 2458              		.loc 1 632 71 discriminator 1 view .LVU650
 2459 007c 631C     		adds	r3, r4, #1
 2460 007e 9DB2     		uxth	r5, r3
 2461              	.LVL156:
 632:Src/util.c    ****     readInputRaw();
 2462              		.loc 1 632 53 discriminator 1 view .LVU651
 2463 0080 B4F5FA6F 		cmp	r4, #2000
 2464 0084 D8D3     		bcc	.L157
 2465              	.LVL157:
 2466              	.L156:
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2467              		.loc 1 639 3 is_stmt 1 view .LVU652
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2468              		.loc 1 639 16 is_stmt 0 view .LVU653
 2469 0086 334B     		ldr	r3, .L165+4
 2470 0088 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2471 008a C3EBC302 		rsb	r2, r3, r3, lsl #3
 2472 008e 3249     		ldr	r1, .L165+8
 2473 0090 01EB4201 		add	r1, r1, r2, lsl #1
 2474 0094 B1F90600 		ldrsh	r0, [r1, #6]
 2475 0098 019A     		ldr	r2, [sp, #4]
 2476 009a A2EB0042 		sub	r2, r2, r0, lsl #16
 2477 009e B1F90A10 		ldrsh	r1, [r1, #10]
 2478 00a2 091A     		subs	r1, r1, r0
 2479 00a4 92FBF1F2 		sdiv	r2, r2, r1
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2480              		.loc 1 639 14 view .LVU654
 2481 00a8 B2F5803F 		cmp	r2, #65536
 2482 00ac 4ADA     		bge	.L162
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2483              		.loc 1 639 16 discriminator 1 view .LVU655
 2484 00ae 41F69911 		movw	r1, #6553
 2485 00b2 8A42     		cmp	r2, r1
 2486 00b4 B8BF     		it	lt
 2487 00b6 0A46     		movlt	r2, r1
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2488              		.loc 1 639 14 discriminator 1 view .LVU656
 2489 00b8 94B2     		uxth	r4, r2
 2490              	.L158:
 2491              	.LVL158:
ARM GAS  /tmp/cc14G55i.s 			page 79


 640:Src/util.c    ****       
 2492              		.loc 1 640 3 is_stmt 1 discriminator 4 view .LVU657
 640:Src/util.c    ****       
 2493              		.loc 1 640 16 is_stmt 0 discriminator 4 view .LVU658
 2494 00ba C3EBC301 		rsb	r1, r3, r3, lsl #3
 2495 00be 2748     		ldr	r0, .L165+12
 2496 00c0 00EB4101 		add	r1, r0, r1, lsl #1
 2497 00c4 B1F90600 		ldrsh	r0, [r1, #6]
 2498 00c8 009A     		ldr	r2, [sp]
 2499 00ca A2EB0042 		sub	r2, r2, r0, lsl #16
 2500 00ce B1F90A10 		ldrsh	r1, [r1, #10]
 2501 00d2 091A     		subs	r1, r1, r0
 2502 00d4 92FBF1F2 		sdiv	r2, r2, r1
 640:Src/util.c    ****       
 2503              		.loc 1 640 14 discriminator 4 view .LVU659
 2504 00d8 B2F5803F 		cmp	r2, #65536
 2505 00dc 35DA     		bge	.L163
 640:Src/util.c    ****       
 2506              		.loc 1 640 16 discriminator 1 view .LVU660
 2507 00de 40F6CC41 		movw	r1, #3276
 2508 00e2 8A42     		cmp	r2, r1
 2509 00e4 B8BF     		it	lt
 2510 00e6 0A46     		movlt	r2, r1
 640:Src/util.c    ****       
 2511              		.loc 1 640 14 discriminator 1 view .LVU661
 2512 00e8 91B2     		uxth	r1, r2
 2513              	.L159:
 2514              	.LVL159:
 642:Src/util.c    ****     // Update current limit
 2515              		.loc 1 642 3 is_stmt 1 discriminator 4 view .LVU662
 642:Src/util.c    ****     // Update current limit
 2516              		.loc 1 642 20 is_stmt 0 discriminator 4 view .LVU663
 2517 00ea C3EBC302 		rsb	r2, r3, r3, lsl #3
 2518 00ee 1A48     		ldr	r0, .L165+8
 2519 00f0 00EB4202 		add	r2, r0, r2, lsl #1
 2520 00f4 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 642:Src/util.c    ****     // Update current limit
 2521              		.loc 1 642 6 discriminator 4 view .LVU664
 2522 00f6 6AB1     		cbz	r2, .L160
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2523              		.loc 1 644 5 is_stmt 1 view .LVU665
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2524              		.loc 1 644 75 is_stmt 0 view .LVU666
 2525 00f8 40F2EE22 		movw	r2, #750
 2526 00fc 04FB02F2 		mul	r2, r4, r2
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2527              		.loc 1 644 41 view .LVU667
 2528 0100 1213     		asrs	r2, r2, #12
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2529              		.loc 1 644 39 view .LVU668
 2530 0102 1948     		ldr	r0, .L165+24
 2531 0104 A0F8CE20 		strh	r2, [r0, #206]	@ movhi
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2532              		.loc 1 644 20 view .LVU669
 2533 0108 1848     		ldr	r0, .L165+28
 2534 010a A0F8CE20 		strh	r2, [r0, #206]	@ movhi
 645:Src/util.c    ****   }
ARM GAS  /tmp/cc14G55i.s 			page 80


 2535              		.loc 1 645 5 is_stmt 1 view .LVU670
 645:Src/util.c    ****   }
 2536              		.loc 1 645 21 is_stmt 0 view .LVU671
 2537 010e 144A     		ldr	r2, .L165+16
 2538 0110 0120     		movs	r0, #1
 2539 0112 1070     		strb	r0, [r2]
 2540              	.L160:
 648:Src/util.c    ****     // Update speed limit
 2541              		.loc 1 648 3 is_stmt 1 view .LVU672
 648:Src/util.c    ****     // Update speed limit
 2542              		.loc 1 648 20 is_stmt 0 view .LVU673
 2543 0114 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2544 0118 104A     		ldr	r2, .L165+12
 2545 011a 02EB4303 		add	r3, r2, r3, lsl #1
 2546 011e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 648:Src/util.c    ****     // Update speed limit
 2547              		.loc 1 648 6 view .LVU674
 2548 0120 73B1     		cbz	r3, .L152
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2549              		.loc 1 650 5 is_stmt 1 view .LVU675
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2550              		.loc 1 650 62 is_stmt 0 view .LVU676
 2551 0122 4FF47A73 		mov	r3, #1000
 2552 0126 03FB01F2 		mul	r2, r3, r1
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2553              		.loc 1 650 41 view .LVU677
 2554 012a 1313     		asrs	r3, r2, #12
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2555              		.loc 1 650 39 view .LVU678
 2556 012c 0E4A     		ldr	r2, .L165+24
 2557 012e A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2558              		.loc 1 650 20 view .LVU679
 2559 0132 0E4A     		ldr	r2, .L165+28
 2560 0134 A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 651:Src/util.c    ****   }
 2561              		.loc 1 651 5 is_stmt 1 view .LVU680
 651:Src/util.c    ****   }
 2562              		.loc 1 651 20 is_stmt 0 view .LVU681
 2563 0138 094A     		ldr	r2, .L165+16
 2564 013a 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 2565 013c 0233     		adds	r3, r3, #2
 2566 013e 1370     		strb	r3, [r2]
 2567              	.LVL160:
 2568              	.L152:
 661:Src/util.c    **** 
 2569              		.loc 1 661 1 view .LVU682
 2570 0140 03B0     		add	sp, sp, #12
 2571              	.LCFI23:
 2572              		.cfi_remember_state
 2573              		.cfi_def_cfa_offset 12
 2574              		@ sp needed
 2575 0142 30BD     		pop	{r4, r5, pc}
 2576              	.L162:
 2577              	.LCFI24:
 2578              		.cfi_restore_state
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
ARM GAS  /tmp/cc14G55i.s 			page 81


 2579              		.loc 1 639 14 view .LVU683
 2580 0144 4FF6FF74 		movw	r4, #65535
 2581 0148 B7E7     		b	.L158
 2582              	.LVL161:
 2583              	.L163:
 640:Src/util.c    ****       
 2584              		.loc 1 640 14 view .LVU684
 2585 014a 4FF6FF71 		movw	r1, #65535
 2586 014e CCE7     		b	.L159
 2587              	.L166:
 2588              		.align	2
 2589              	.L165:
 2590 0150 00000000 		.word	.LANCHOR12
 2591 0154 00000000 		.word	.LANCHOR16
 2592 0158 00000000 		.word	.LANCHOR14
 2593 015c 00000000 		.word	.LANCHOR15
 2594 0160 00000000 		.word	.LANCHOR26
 2595 0164 00080140 		.word	1073809408
 2596 0168 00000000 		.word	.LANCHOR0
 2597 016c 00000000 		.word	rtP_Left
 2598              		.cfi_endproc
 2599              	.LFE76:
 2601              		.section	.text.poweroffPressCheck,"ax",%progbits
 2602              		.align	1
 2603              		.global	poweroffPressCheck
 2604              		.syntax unified
 2605              		.thumb
 2606              		.thumb_func
 2607              		.fpu softvfp
 2609              	poweroffPressCheck:
 2610              	.LFB91:
1558:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2611              		.loc 1 1558 31 is_stmt 1 view -0
 2612              		.cfi_startproc
 2613              		@ args = 0, pretend = 0, frame = 0
 2614              		@ frame_needed = 0, uses_anonymous_args = 0
 2615 0000 38B5     		push	{r3, r4, r5, lr}
 2616              	.LCFI25:
 2617              		.cfi_def_cfa_offset 16
 2618              		.cfi_offset 3, -16
 2619              		.cfi_offset 4, -12
 2620              		.cfi_offset 5, -8
 2621              		.cfi_offset 14, -4
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2622              		.loc 1 1560 5 view .LVU686
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2623              		.loc 1 1560 8 is_stmt 0 view .LVU687
 2624 0002 0221     		movs	r1, #2
 2625 0004 2448     		ldr	r0, .L182
 2626 0006 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2627              	.LVL162:
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2628              		.loc 1 1560 7 view .LVU688
 2629 000a 90B9     		cbnz	r0, .L177
 2630              	.L167:
1618:Src/util.c    **** 
 2631              		.loc 1 1618 1 view .LVU689
ARM GAS  /tmp/cc14G55i.s 			page 82


 2632 000c 38BD     		pop	{r3, r4, r5, pc}
 2633              	.LVL163:
 2634              	.L170:
1558:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2635              		.loc 1 1558 31 view .LVU690
 2636 000e 2546     		mov	r5, r4
 2637              	.LVL164:
 2638              	.L168:
 2639              	.LBB12:
1562:Src/util.c    ****         HAL_Delay(10);
 2640              		.loc 1 1562 12 is_stmt 1 view .LVU691
1562:Src/util.c    ****         HAL_Delay(10);
 2641              		.loc 1 1562 13 is_stmt 0 view .LVU692
 2642 0010 0221     		movs	r1, #2
 2643 0012 2148     		ldr	r0, .L182
 2644 0014 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2645              	.LVL165:
1562:Src/util.c    ****         HAL_Delay(10);
 2646              		.loc 1 1562 12 view .LVU693
 2647 0018 68B1     		cbz	r0, .L180
1563:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
 2648              		.loc 1 1563 9 is_stmt 1 view .LVU694
 2649 001a 0A20     		movs	r0, #10
 2650 001c FFF7FEFF 		bl	HAL_Delay
 2651              	.LVL166:
1564:Src/util.c    ****       }
 2652              		.loc 1 1564 9 view .LVU695
1564:Src/util.c    ****       }
 2653              		.loc 1 1564 22 is_stmt 0 view .LVU696
 2654 0020 6C1C     		adds	r4, r5, #1
 2655 0022 A4B2     		uxth	r4, r4
 2656              	.LVL167:
1564:Src/util.c    ****       }
 2657              		.loc 1 1564 12 view .LVU697
 2658 0024 B5F5FA7F 		cmp	r5, #500
 2659 0028 F1D1     		bne	.L170
1564:Src/util.c    ****       }
 2660              		.loc 1 1564 39 is_stmt 1 discriminator 1 view .LVU698
 2661 002a 0520     		movs	r0, #5
 2662 002c FFF7FEFF 		bl	beepShort
 2663              	.LVL168:
 2664 0030 EDE7     		b	.L170
 2665              	.LVL169:
 2666              	.L177:
1561:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 2667              		.loc 1 1561 16 is_stmt 0 view .LVU699
 2668 0032 0025     		movs	r5, #0
 2669 0034 ECE7     		b	.L168
 2670              	.LVL170:
 2671              	.L180:
1567:Src/util.c    **** 
 2672              		.loc 1 1567 7 is_stmt 1 view .LVU700
1567:Src/util.c    **** 
 2673              		.loc 1 1567 10 is_stmt 0 view .LVU701
 2674 0036 082D     		cmp	r5, #8
 2675 0038 02D9     		bls	.L172
1567:Src/util.c    **** 
ARM GAS  /tmp/cc14G55i.s 			page 83


 2676              		.loc 1 1567 26 is_stmt 1 discriminator 1 view .LVU702
1567:Src/util.c    **** 
 2677              		.loc 1 1567 33 is_stmt 0 discriminator 1 view .LVU703
 2678 003a 184B     		ldr	r3, .L182+4
 2679 003c 0022     		movs	r2, #0
 2680 003e 1A70     		strb	r2, [r3]
 2681              	.L172:
1569:Src/util.c    ****         HAL_Delay(1000);
 2682              		.loc 1 1569 7 is_stmt 1 view .LVU704
1569:Src/util.c    ****         HAL_Delay(1000);
 2683              		.loc 1 1569 10 is_stmt 0 view .LVU705
 2684 0040 B5F5FA7F 		cmp	r5, #500
 2685 0044 03D2     		bcs	.L181
1583:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2686              		.loc 1 1583 14 is_stmt 1 view .LVU706
1583:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2687              		.loc 1 1583 17 is_stmt 0 view .LVU707
 2688 0046 082D     		cmp	r5, #8
 2689 0048 E0D9     		bls	.L167
1587:Src/util.c    ****       }
 2690              		.loc 1 1587 7 is_stmt 1 view .LVU708
 2691 004a FFF7FEFF 		bl	poweroff
 2692              	.LVL171:
 2693              	.L181:
1570:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
 2694              		.loc 1 1570 9 view .LVU709
 2695 004e 4FF47A70 		mov	r0, #1000
 2696 0052 FFF7FEFF 		bl	HAL_Delay
 2697              	.LVL172:
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2698              		.loc 1 1571 9 view .LVU710
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2699              		.loc 1 1571 13 is_stmt 0 view .LVU711
 2700 0056 0221     		movs	r1, #2
 2701 0058 0F48     		ldr	r0, .L182
 2702 005a FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2703              	.LVL173:
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2704              		.loc 1 1571 12 view .LVU712
 2705 005e 58B9     		cbnz	r0, .L174
1578:Src/util.c    ****           adcCalibLim();
 2706              		.loc 1 1578 11 is_stmt 1 view .LVU713
 2707 0060 1020     		movs	r0, #16
 2708 0062 FFF7FEFF 		bl	beepLong
 2709              	.LVL174:
1579:Src/util.c    ****           beepShort(5);
 2710              		.loc 1 1579 11 view .LVU714
 2711 0066 FFF7FEFF 		bl	adcCalibLim
 2712              	.LVL175:
1580:Src/util.c    ****           #endif
 2713              		.loc 1 1580 11 view .LVU715
 2714 006a 0520     		movs	r0, #5
 2715 006c FFF7FEFF 		bl	beepShort
 2716              	.LVL176:
 2717 0070 CCE7     		b	.L167
 2718              	.L176:
1572:Src/util.c    ****           beepLong(8);
ARM GAS  /tmp/cc14G55i.s 			page 84


 2719              		.loc 1 1572 62 discriminator 2 view .LVU716
 2720 0072 0A20     		movs	r0, #10
 2721 0074 FFF7FEFF 		bl	HAL_Delay
 2722              	.LVL177:
 2723              	.L174:
1572:Src/util.c    ****           beepLong(8);
 2724              		.loc 1 1572 16 discriminator 1 view .LVU717
1572:Src/util.c    ****           beepLong(8);
 2725              		.loc 1 1572 17 is_stmt 0 discriminator 1 view .LVU718
 2726 0078 0221     		movs	r1, #2
 2727 007a 0748     		ldr	r0, .L182
 2728 007c FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2729              	.LVL178:
1572:Src/util.c    ****           beepLong(8);
 2730              		.loc 1 1572 16 discriminator 1 view .LVU719
 2731 0080 0028     		cmp	r0, #0
 2732 0082 F6D1     		bne	.L176
1573:Src/util.c    ****           updateCurSpdLim();
 2733              		.loc 1 1573 11 is_stmt 1 view .LVU720
 2734 0084 0820     		movs	r0, #8
 2735 0086 FFF7FEFF 		bl	beepLong
 2736              	.LVL179:
1574:Src/util.c    ****           beepShort(5);
 2737              		.loc 1 1574 11 view .LVU721
 2738 008a FFF7FEFF 		bl	updateCurSpdLim
 2739              	.LVL180:
1575:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
 2740              		.loc 1 1575 11 view .LVU722
 2741 008e 0520     		movs	r0, #5
 2742 0090 FFF7FEFF 		bl	beepShort
 2743              	.LVL181:
 2744 0094 BAE7     		b	.L167
 2745              	.L183:
 2746 0096 00BF     		.align	2
 2747              	.L182:
 2748 0098 00080140 		.word	1073809408
 2749 009c 00000000 		.word	enable
 2750              	.LBE12:
 2751              		.cfi_endproc
 2752              	.LFE91:
 2754              		.section	.text.rateLimiter16,"ax",%progbits
 2755              		.align	1
 2756              		.global	rateLimiter16
 2757              		.syntax unified
 2758              		.thumb
 2759              		.thumb_func
 2760              		.fpu softvfp
 2762              	rateLimiter16:
 2763              	.LVL182:
 2764              	.LFB93:
1644:Src/util.c    ****   // Old filter
1645:Src/util.c    ****   // Inputs:       u     = int16
1646:Src/util.c    ****   // Outputs:      y     = fixdt(1,32,20)
1647:Src/util.c    ****   // Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1648:Src/util.c    ****   // yint = (int16_t)(y >> 20); // the integer output is the fixed-point ouput shifted by 20 bits
1649:Src/util.c    ****   // void filtLowPass32(int16_t u, uint16_t coef, int32_t *y) {
1650:Src/util.c    ****   //   int32_t tmp;  
ARM GAS  /tmp/cc14G55i.s 			page 85


1651:Src/util.c    ****   //   tmp = (int16_t)(u << 4) - (*y >> 16);  
1652:Src/util.c    ****   //   tmp = CLAMP(tmp, -32768, 32767);  // Overflow protection  
1653:Src/util.c    ****   //   *y  = coef * tmp + (*y);
1654:Src/util.c    ****   // }
1655:Src/util.c    **** 
1656:Src/util.c    **** 
1657:Src/util.c    ****   /* rateLimiter16(int16_t u, int16_t rate, int16_t *y);
1658:Src/util.c    ****   * Inputs:       u     = int16
1659:Src/util.c    ****   * Outputs:      y     = fixdt(1,16,4)
1660:Src/util.c    ****   * Parameters:   rate  = fixdt(1,16,4) = [0, 32767] Do NOT make rate negative (>32767)
1661:Src/util.c    ****   */
1662:Src/util.c    **** void rateLimiter16(int16_t u, int16_t rate, int16_t *y) {
 2765              		.loc 1 1662 57 view -0
 2766              		.cfi_startproc
 2767              		@ args = 0, pretend = 0, frame = 0
 2768              		@ frame_needed = 0, uses_anonymous_args = 0
 2769              		@ link register save eliminated.
1663:Src/util.c    ****   int16_t q0;
 2770              		.loc 1 1663 3 view .LVU724
1664:Src/util.c    ****   int16_t q1;
 2771              		.loc 1 1664 3 view .LVU725
1665:Src/util.c    **** 
1666:Src/util.c    ****   q0 = (u << 4)  - *y;
 2772              		.loc 1 1666 3 view .LVU726
 2773              		.loc 1 1666 11 is_stmt 0 view .LVU727
 2774 0000 0301     		lsls	r3, r0, #4
 2775 0002 9BB2     		uxth	r3, r3
 2776              		.loc 1 1666 20 view .LVU728
 2777 0004 1088     		ldrh	r0, [r2]
 2778              	.LVL183:
 2779              		.loc 1 1666 18 view .LVU729
 2780 0006 1B1A     		subs	r3, r3, r0
 2781              		.loc 1 1666 6 view .LVU730
 2782 0008 1BB2     		sxth	r3, r3
 2783              	.LVL184:
1667:Src/util.c    **** 
1668:Src/util.c    ****   if (q0 > rate) {
 2784              		.loc 1 1668 3 is_stmt 1 view .LVU731
 2785              		.loc 1 1668 6 is_stmt 0 view .LVU732
 2786 000a 8B42     		cmp	r3, r1
 2787 000c 04DC     		bgt	.L185
1669:Src/util.c    ****     q0 = rate;
1670:Src/util.c    ****   } else {
1671:Src/util.c    ****     q1 = -rate;
 2788              		.loc 1 1671 5 is_stmt 1 view .LVU733
 2789              		.loc 1 1671 8 is_stmt 0 view .LVU734
 2790 000e 4942     		rsbs	r1, r1, #0
 2791              	.LVL185:
 2792              		.loc 1 1671 8 view .LVU735
 2793 0010 09B2     		sxth	r1, r1
 2794              	.LVL186:
1672:Src/util.c    ****     if (q0 < q1) {
 2795              		.loc 1 1672 5 is_stmt 1 view .LVU736
 2796              		.loc 1 1672 8 is_stmt 0 view .LVU737
 2797 0012 8B42     		cmp	r3, r1
 2798 0014 00DB     		blt	.L185
1666:Src/util.c    **** 
ARM GAS  /tmp/cc14G55i.s 			page 86


 2799              		.loc 1 1666 6 view .LVU738
 2800 0016 1946     		mov	r1, r3
 2801              	.LVL187:
 2802              	.L185:
1673:Src/util.c    ****       q0 = q1;
1674:Src/util.c    ****     }
1675:Src/util.c    ****   }
1676:Src/util.c    **** 
1677:Src/util.c    ****   *y = q0 + *y;
 2803              		.loc 1 1677 3 is_stmt 1 view .LVU739
 2804              		.loc 1 1677 11 is_stmt 0 view .LVU740
 2805 0018 0144     		add	r1, r1, r0
 2806              	.LVL188:
 2807              		.loc 1 1677 6 view .LVU741
 2808 001a 1180     		strh	r1, [r2]	@ movhi
1678:Src/util.c    **** }
 2809              		.loc 1 1678 1 view .LVU742
 2810 001c 7047     		bx	lr
 2811              		.cfi_endproc
 2812              	.LFE93:
 2814              		.section	.text.mixerFcn,"ax",%progbits
 2815              		.align	1
 2816              		.global	mixerFcn
 2817              		.syntax unified
 2818              		.thumb
 2819              		.thumb_func
 2820              		.fpu softvfp
 2822              	mixerFcn:
 2823              	.LVL189:
 2824              	.LFB94:
1679:Src/util.c    **** 
1680:Src/util.c    **** 
1681:Src/util.c    ****   /* mixerFcn(rtu_speed, rtu_steer, &rty_speedR, &rty_speedL); 
1682:Src/util.c    ****   * Inputs:       rtu_speed, rtu_steer                  = fixdt(1,16,4)
1683:Src/util.c    ****   * Outputs:      rty_speedR, rty_speedL                = int16_t
1684:Src/util.c    ****   * Parameters:   SPEED_COEFFICIENT, STEER_COEFFICIENT  = fixdt(0,16,14)
1685:Src/util.c    ****   */
1686:Src/util.c    **** void mixerFcn(int16_t rtu_speed, int16_t rtu_steer, int16_t *rty_speedR, int16_t *rty_speedL) {
 2825              		.loc 1 1686 95 is_stmt 1 view -0
 2826              		.cfi_startproc
 2827              		@ args = 0, pretend = 0, frame = 0
 2828              		@ frame_needed = 0, uses_anonymous_args = 0
 2829              		.loc 1 1686 95 is_stmt 0 view .LVU744
 2830 0000 10B5     		push	{r4, lr}
 2831              	.LCFI26:
 2832              		.cfi_def_cfa_offset 8
 2833              		.cfi_offset 4, -8
 2834              		.cfi_offset 14, -4
1687:Src/util.c    ****     int16_t prodSpeed;
 2835              		.loc 1 1687 5 is_stmt 1 view .LVU745
1688:Src/util.c    ****     int16_t prodSteer;
 2836              		.loc 1 1688 5 view .LVU746
1689:Src/util.c    ****     int32_t tmp;
 2837              		.loc 1 1689 5 view .LVU747
1690:Src/util.c    **** 
1691:Src/util.c    ****     prodSpeed   = (int16_t)((rtu_speed * (int16_t)SPEED_COEFFICIENT) >> 14);
 2838              		.loc 1 1691 5 view .LVU748
ARM GAS  /tmp/cc14G55i.s 			page 87


 2839              	.LVL190:
1692:Src/util.c    ****     prodSteer   = (int16_t)((rtu_steer * (int16_t)STEER_COEFFICIENT) >> 14);
 2840              		.loc 1 1692 5 view .LVU749
 2841              		.loc 1 1692 17 is_stmt 0 view .LVU750
 2842 0002 4FEA610E 		asr	lr, r1, #1
 2843              	.LVL191:
1693:Src/util.c    **** 
1694:Src/util.c    ****     tmp         = prodSpeed - prodSteer;  
 2844              		.loc 1 1694 5 is_stmt 1 view .LVU751
 2845              		.loc 1 1694 17 is_stmt 0 view .LVU752
 2846 0006 A0EB6101 		sub	r1, r0, r1, asr #1
 2847              	.LVL192:
1695:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2848              		.loc 1 1695 5 is_stmt 1 view .LVU753
 2849              		.loc 1 1695 19 is_stmt 0 view .LVU754
 2850 000a B1F5004F 		cmp	r1, #32768
 2851 000e 26DA     		bge	.L191
 2852              		.loc 1 1695 19 discriminator 1 view .LVU755
 2853 0010 174C     		ldr	r4, .L195
 2854 0012 A142     		cmp	r1, r4
 2855 0014 B8BF     		it	lt
 2856 0016 2146     		movlt	r1, r4
 2857              	.LVL193:
 2858              	.L187:
1696:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2859              		.loc 1 1696 5 is_stmt 1 discriminator 4 view .LVU756
 2860              		.loc 1 1696 19 is_stmt 0 discriminator 4 view .LVU757
 2861 0018 0911     		asrs	r1, r1, #4
 2862              	.LVL194:
 2863              		.loc 1 1696 17 discriminator 4 view .LVU758
 2864 001a 1180     		strh	r1, [r2]	@ movhi
1697:Src/util.c    ****     *rty_speedR = CLAMP(*rty_speedR, INPUT_MIN, INPUT_MAX);
 2865              		.loc 1 1697 5 is_stmt 1 discriminator 4 view .LVU759
 2866              		.loc 1 1697 19 is_stmt 0 discriminator 4 view .LVU760
 2867 001c 154C     		ldr	r4, .L195+4
 2868 001e B4F900C0 		ldrsh	ip, [r4]
 2869              		.loc 1 1697 17 discriminator 4 view .LVU761
 2870 0022 6145     		cmp	r1, ip
 2871 0024 1EDC     		bgt	.L192
 2872              		.loc 1 1697 19 discriminator 1 view .LVU762
 2873 0026 144C     		ldr	r4, .L195+8
 2874 0028 B4F90040 		ldrsh	r4, [r4]
 2875              		.loc 1 1697 17 discriminator 1 view .LVU763
 2876 002c A142     		cmp	r1, r4
 2877 002e B8BF     		it	lt
 2878 0030 2146     		movlt	r1, r4
 2879              	.L188:
 2880              		.loc 1 1697 17 discriminator 4 view .LVU764
 2881 0032 1180     		strh	r1, [r2]	@ movhi
1698:Src/util.c    **** 
1699:Src/util.c    ****     tmp         = prodSpeed + prodSteer;
 2882              		.loc 1 1699 5 is_stmt 1 discriminator 4 view .LVU765
 2883              		.loc 1 1699 17 is_stmt 0 discriminator 4 view .LVU766
 2884 0034 7044     		add	r0, r0, lr
 2885              	.LVL195:
1700:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2886              		.loc 1 1700 5 is_stmt 1 discriminator 4 view .LVU767
ARM GAS  /tmp/cc14G55i.s 			page 88


 2887              		.loc 1 1700 19 is_stmt 0 discriminator 4 view .LVU768
 2888 0036 B0F5004F 		cmp	r0, #32768
 2889 003a 15DA     		bge	.L193
 2890              		.loc 1 1700 19 discriminator 1 view .LVU769
 2891 003c 0C4A     		ldr	r2, .L195
 2892              	.LVL196:
 2893              		.loc 1 1700 19 discriminator 1 view .LVU770
 2894 003e 9042     		cmp	r0, r2
 2895 0040 B8BF     		it	lt
 2896 0042 1046     		movlt	r0, r2
 2897              	.LVL197:
 2898              	.L189:
1701:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 2899              		.loc 1 1701 5 is_stmt 1 discriminator 4 view .LVU771
 2900              		.loc 1 1701 19 is_stmt 0 discriminator 4 view .LVU772
 2901 0044 0211     		asrs	r2, r0, #4
 2902              		.loc 1 1701 17 discriminator 4 view .LVU773
 2903 0046 1A80     		strh	r2, [r3]	@ movhi
1702:Src/util.c    ****     *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 2904              		.loc 1 1702 5 is_stmt 1 discriminator 4 view .LVU774
 2905              		.loc 1 1702 17 is_stmt 0 discriminator 4 view .LVU775
 2906 0048 9445     		cmp	ip, r2
 2907 004a 05DB     		blt	.L190
 2908              		.loc 1 1702 19 discriminator 1 view .LVU776
 2909 004c 0A49     		ldr	r1, .L195+8
 2910 004e B1F900C0 		ldrsh	ip, [r1]
 2911              		.loc 1 1702 17 discriminator 1 view .LVU777
 2912 0052 9445     		cmp	ip, r2
 2913 0054 B8BF     		it	lt
 2914 0056 9446     		movlt	ip, r2
 2915              	.L190:
 2916              		.loc 1 1702 17 discriminator 4 view .LVU778
 2917 0058 A3F800C0 		strh	ip, [r3]	@ movhi
1703:Src/util.c    **** }
 2918              		.loc 1 1703 1 discriminator 4 view .LVU779
 2919 005c 10BD     		pop	{r4, pc}
 2920              	.LVL198:
 2921              	.L191:
1695:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2922              		.loc 1 1695 19 view .LVU780
 2923 005e 47F6FF71 		movw	r1, #32767
 2924              	.LVL199:
1695:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2925              		.loc 1 1695 19 view .LVU781
 2926 0062 D9E7     		b	.L187
 2927              	.L192:
1697:Src/util.c    **** 
 2928              		.loc 1 1697 17 view .LVU782
 2929 0064 6146     		mov	r1, ip
 2930 0066 E4E7     		b	.L188
 2931              	.LVL200:
 2932              	.L193:
1700:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 2933              		.loc 1 1700 19 view .LVU783
 2934 0068 47F6FF70 		movw	r0, #32767
 2935              	.LVL201:
1700:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
ARM GAS  /tmp/cc14G55i.s 			page 89


 2936              		.loc 1 1700 19 view .LVU784
 2937 006c EAE7     		b	.L189
 2938              	.L196:
 2939 006e 00BF     		.align	2
 2940              	.L195:
 2941 0070 0080FFFF 		.word	-32768
 2942 0074 00000000 		.word	.LANCHOR9
 2943 0078 00000000 		.word	.LANCHOR10
 2944              		.cfi_endproc
 2945              	.LFE94:
 2947              		.section	.text.multipleTapDet,"ax",%progbits
 2948              		.align	1
 2949              		.global	multipleTapDet
 2950              		.syntax unified
 2951              		.thumb
 2952              		.thumb_func
 2953              		.fpu softvfp
 2955              	multipleTapDet:
 2956              	.LVL202:
 2957              	.LFB95:
1704:Src/util.c    **** 
1705:Src/util.c    **** 
1706:Src/util.c    **** 
1707:Src/util.c    **** /* =========================== Multiple Tap Function =========================== */
1708:Src/util.c    **** 
1709:Src/util.c    ****   /* multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x)
1710:Src/util.c    ****   * This function detects multiple tap presses, such as double tapping, triple tapping, etc.
1711:Src/util.c    ****   * Inputs:       u = int16_t (input signal); timeNow = uint32_t (current time)  
1712:Src/util.c    ****   * Outputs:      x->b_multipleTap (get the output here)
1713:Src/util.c    ****   */
1714:Src/util.c    **** void multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x) {
 2958              		.loc 1 1714 66 is_stmt 1 view -0
 2959              		.cfi_startproc
 2960              		@ args = 0, pretend = 0, frame = 0
 2961              		@ frame_needed = 0, uses_anonymous_args = 0
 2962              		@ link register save eliminated.
 2963              		.loc 1 1714 66 is_stmt 0 view .LVU786
 2964 0000 30B4     		push	{r4, r5}
 2965              	.LCFI27:
 2966              		.cfi_def_cfa_offset 8
 2967              		.cfi_offset 4, -8
 2968              		.cfi_offset 5, -4
1715:Src/util.c    ****   uint8_t 	b_timeout;
 2969              		.loc 1 1715 3 is_stmt 1 view .LVU787
1716:Src/util.c    ****   uint8_t 	b_hyst;
 2970              		.loc 1 1716 3 view .LVU788
1717:Src/util.c    ****   uint8_t 	b_pulse;
 2971              		.loc 1 1717 3 view .LVU789
1718:Src/util.c    ****   uint8_t 	z_pulseCnt;
 2972              		.loc 1 1718 3 view .LVU790
1719:Src/util.c    ****   uint8_t   z_pulseCntRst;
 2973              		.loc 1 1719 3 view .LVU791
1720:Src/util.c    ****   uint32_t 	t_time; 
 2974              		.loc 1 1720 3 view .LVU792
1721:Src/util.c    **** 
1722:Src/util.c    ****   // Detect hysteresis
1723:Src/util.c    ****   if (x->b_hysteresis) {
ARM GAS  /tmp/cc14G55i.s 			page 90


 2975              		.loc 1 1723 3 view .LVU793
 2976              		.loc 1 1723 8 is_stmt 0 view .LVU794
 2977 0002 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 2978              		.loc 1 1723 6 view .LVU795
 2979 0004 E4B1     		cbz	r4, .L198
1724:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_LO);
 2980              		.loc 1 1724 5 is_stmt 1 view .LVU796
 2981              		.loc 1 1724 17 is_stmt 0 view .LVU797
 2982 0006 C828     		cmp	r0, #200
 2983 0008 D4BF     		ite	le
 2984 000a 0020     		movle	r0, #0
 2985              	.LVL203:
 2986              		.loc 1 1724 17 view .LVU798
 2987 000c 0120     		movgt	r0, #1
 2988              	.LVL204:
 2989              	.L199:
1725:Src/util.c    ****   } else {
1726:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_HI);
1727:Src/util.c    ****   }
1728:Src/util.c    **** 
1729:Src/util.c    ****   // Detect pulse
1730:Src/util.c    ****   b_pulse = (b_hyst != x->b_hysteresis);
 2990              		.loc 1 1730 3 is_stmt 1 view .LVU799
 2991              		.loc 1 1730 21 is_stmt 0 view .LVU800
 2992 000e 231A     		subs	r3, r4, r0
 2993 0010 18BF     		it	ne
 2994 0012 0123     		movne	r3, #1
 2995              	.LVL205:
1731:Src/util.c    **** 
1732:Src/util.c    ****   // Save time when first pulse is detected
1733:Src/util.c    ****   if (b_hyst && b_pulse && (x->z_pulseCntPrev == 0)) {
 2996              		.loc 1 1733 3 is_stmt 1 view .LVU801
 2997              		.loc 1 1733 6 is_stmt 0 view .LVU802
 2998 0014 18B1     		cbz	r0, .L200
 2999              		.loc 1 1733 14 discriminator 1 view .LVU803
 3000 0016 8442     		cmp	r4, r0
 3001 0018 01D0     		beq	.L200
 3002              		.loc 1 1733 30 discriminator 2 view .LVU804
 3003 001a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 3004              		.loc 1 1733 25 discriminator 2 view .LVU805
 3005 001c B4B1     		cbz	r4, .L205
 3006              	.L200:
1734:Src/util.c    ****     t_time = timeNow;
1735:Src/util.c    ****   } else {
1736:Src/util.c    ****     t_time = x->t_timePrev;
 3007              		.loc 1 1736 5 is_stmt 1 view .LVU806
 3008              		.loc 1 1736 12 is_stmt 0 view .LVU807
 3009 001e 1468     		ldr	r4, [r2]
 3010              	.LVL206:
 3011              	.L201:
1737:Src/util.c    ****   }
1738:Src/util.c    **** 
1739:Src/util.c    ****   // Create timeout boolean
1740:Src/util.c    ****   b_timeout = (timeNow - t_time > MULTIPLE_TAP_TIMEOUT);
 3012              		.loc 1 1740 3 is_stmt 1 view .LVU808
 3013              		.loc 1 1740 24 is_stmt 0 view .LVU809
 3014 0020 091B     		subs	r1, r1, r4
ARM GAS  /tmp/cc14G55i.s 			page 91


 3015              	.LVL207:
1741:Src/util.c    **** 
1742:Src/util.c    ****   // Create pulse counter
1743:Src/util.c    ****   if ((!b_hyst) && (x->z_pulseCntPrev == 0)) {
 3016              		.loc 1 1743 3 is_stmt 1 view .LVU810
 3017              		.loc 1 1743 6 is_stmt 0 view .LVU811
 3018 0022 10B9     		cbnz	r0, .L202
 3019              		.loc 1 1743 22 discriminator 1 view .LVU812
 3020 0024 1579     		ldrb	r5, [r2, #4]	@ zero_extendqisi2
 3021              		.loc 1 1743 17 discriminator 1 view .LVU813
 3022 0026 05B9     		cbnz	r5, .L202
1744:Src/util.c    ****     z_pulseCnt = 0U;
 3023              		.loc 1 1744 16 view .LVU814
 3024 0028 2B46     		mov	r3, r5
 3025              	.LVL208:
 3026              	.L202:
1745:Src/util.c    ****   } else {
1746:Src/util.c    ****     z_pulseCnt = b_pulse;
1747:Src/util.c    ****   }
1748:Src/util.c    **** 
1749:Src/util.c    ****   // Reset counter if we detected complete tap presses OR there is a timeout
1750:Src/util.c    ****   if ((x->z_pulseCntPrev >= MULTIPLE_TAP_NR) || b_timeout) {
 3027              		.loc 1 1750 3 is_stmt 1 view .LVU815
 3028              		.loc 1 1750 9 is_stmt 0 view .LVU816
 3029 002a 92F804C0 		ldrb	ip, [r2, #4]	@ zero_extendqisi2
 3030              		.loc 1 1750 6 view .LVU817
 3031 002e BCF1030F 		cmp	ip, #3
 3032 0032 0DD8     		bhi	.L207
 3033              		.loc 1 1750 46 discriminator 1 view .LVU818
 3034 0034 B1F5FA6F 		cmp	r1, #2000
 3035 0038 0CD9     		bls	.L203
1751:Src/util.c    ****     z_pulseCntRst = 0U;
 3036              		.loc 1 1751 19 view .LVU819
 3037 003a 4FF0000C 		mov	ip, #0
 3038 003e 09E0     		b	.L203
 3039              	.LVL209:
 3040              	.L198:
1726:Src/util.c    ****   }
 3041              		.loc 1 1726 5 is_stmt 1 view .LVU820
1726:Src/util.c    ****   }
 3042              		.loc 1 1726 17 is_stmt 0 view .LVU821
 3043 0040 B0F5167F 		cmp	r0, #600
 3044 0044 D4BF     		ite	le
 3045 0046 0020     		movle	r0, #0
 3046              	.LVL210:
1726:Src/util.c    ****   }
 3047              		.loc 1 1726 17 view .LVU822
 3048 0048 0120     		movgt	r0, #1
 3049              	.LVL211:
1726:Src/util.c    ****   }
 3050              		.loc 1 1726 17 view .LVU823
 3051 004a E0E7     		b	.L199
 3052              	.LVL212:
 3053              	.L205:
1734:Src/util.c    ****   } else {
 3054              		.loc 1 1734 12 view .LVU824
 3055 004c 0C46     		mov	r4, r1
ARM GAS  /tmp/cc14G55i.s 			page 92


 3056 004e E7E7     		b	.L201
 3057              	.LVL213:
 3058              	.L207:
 3059              		.loc 1 1751 19 view .LVU825
 3060 0050 4FF0000C 		mov	ip, #0
 3061              	.L203:
 3062              	.LVL214:
1752:Src/util.c    ****   } else {
1753:Src/util.c    ****     z_pulseCntRst = x->z_pulseCntPrev;
1754:Src/util.c    ****   }
1755:Src/util.c    ****   z_pulseCnt = z_pulseCnt + z_pulseCntRst;
 3063              		.loc 1 1755 3 is_stmt 1 view .LVU826
 3064              		.loc 1 1755 14 is_stmt 0 view .LVU827
 3065 0054 6344     		add	r3, r3, ip
 3066              	.LVL215:
 3067              		.loc 1 1755 14 view .LVU828
 3068 0056 DBB2     		uxtb	r3, r3
 3069              	.LVL216:
1756:Src/util.c    **** 
1757:Src/util.c    ****   // Check if complete tap presses are detected AND no timeout
1758:Src/util.c    ****   if ((z_pulseCnt >= MULTIPLE_TAP_NR) && (!b_timeout)) {
 3070              		.loc 1 1758 3 is_stmt 1 view .LVU829
 3071              		.loc 1 1758 6 is_stmt 0 view .LVU830
 3072 0058 032B     		cmp	r3, #3
 3073 005a 07D9     		bls	.L204
 3074              		.loc 1 1758 39 discriminator 1 view .LVU831
 3075 005c B1F5FA6F 		cmp	r1, #2000
 3076 0060 04D8     		bhi	.L204
1759:Src/util.c    ****     x->b_multipleTap = !x->b_multipleTap;	// Toggle output
 3077              		.loc 1 1759 5 is_stmt 1 view .LVU832
 3078              		.loc 1 1759 26 is_stmt 0 view .LVU833
 3079 0062 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3080              	.LVL217:
 3081              		.loc 1 1759 24 view .LVU834
 3082 0064 B1FA81F1 		clz	r1, r1
 3083 0068 4909     		lsrs	r1, r1, #5
 3084              		.loc 1 1759 22 view .LVU835
 3085 006a 9171     		strb	r1, [r2, #6]
 3086              	.L204:
1760:Src/util.c    ****   }
1761:Src/util.c    **** 
1762:Src/util.c    ****   // Update states
1763:Src/util.c    ****   x->z_pulseCntPrev = z_pulseCnt;
 3087              		.loc 1 1763 3 is_stmt 1 view .LVU836
 3088              		.loc 1 1763 21 is_stmt 0 view .LVU837
 3089 006c 1371     		strb	r3, [r2, #4]
1764:Src/util.c    ****   x->b_hysteresis 	= b_hyst;
 3090              		.loc 1 1764 3 is_stmt 1 view .LVU838
 3091              		.loc 1 1764 20 is_stmt 0 view .LVU839
 3092 006e 5071     		strb	r0, [r2, #5]
 3093              	.LVL218:
1765:Src/util.c    ****   x->t_timePrev 	  = t_time;
 3094              		.loc 1 1765 3 is_stmt 1 view .LVU840
 3095              		.loc 1 1765 20 is_stmt 0 view .LVU841
 3096 0070 1460     		str	r4, [r2]
1766:Src/util.c    **** }
 3097              		.loc 1 1766 1 view .LVU842
ARM GAS  /tmp/cc14G55i.s 			page 93


 3098 0072 30BC     		pop	{r4, r5}
 3099              	.LCFI28:
 3100              		.cfi_restore 5
 3101              		.cfi_restore 4
 3102              		.cfi_def_cfa_offset 0
 3103              	.LVL219:
 3104              		.loc 1 1766 1 view .LVU843
 3105 0074 7047     		bx	lr
 3106              		.cfi_endproc
 3107              	.LFE95:
 3109              		.global	VirtAddVarTab
 3110              		.global	ctrlModReq
 3111              		.global	ctrlModReqRaw
 3112              		.global	timeoutFlgSerial
 3113              		.global	timeoutFlgADC
 3114              		.global	speedAvgAbs
 3115              		.global	speedAvg
 3116              		.global	input2
 3117              		.global	input1
 3118              		.global	inIdx_prev
 3119              		.global	inIdx
 3120              		.global	rtY_Right
 3121              		.global	rtU_Right
 3122              		.global	rtDW_Right
 3123              		.global	rtP_Right
 3124              		.global	rtY_Left
 3125              		.global	rtU_Left
 3126              		.global	rtDW_Left
 3127              		.global	rtM_Right
 3128              		.global	rtM_Left
 3129              		.global	rtM_Right_
 3130              		.global	rtM_Left_
 3131              		.section	.bss.INPUT_MAX,"aw",%nobits
 3132              		.align	1
 3133              		.set	.LANCHOR9,. + 0
 3136              	INPUT_MAX:
 3137 0000 0000     		.space	2
 3138              		.section	.bss.INPUT_MIN,"aw",%nobits
 3139              		.align	1
 3140              		.set	.LANCHOR10,. + 0
 3143              	INPUT_MIN:
 3144 0000 0000     		.space	2
 3145              		.section	.bss.button1,"aw",%nobits
 3146              		.set	.LANCHOR23,. + 0
 3149              	button1:
 3150 0000 00       		.space	1
 3151              		.section	.bss.button2,"aw",%nobits
 3152              		.set	.LANCHOR24,. + 0
 3155              	button2:
 3156 0000 00       		.space	1
 3157              		.section	.bss.cur_spd_valid,"aw",%nobits
 3158              		.set	.LANCHOR26,. + 0
 3161              	cur_spd_valid:
 3162 0000 00       		.space	1
 3163              		.section	.bss.inIdx,"aw",%nobits
 3164              		.set	.LANCHOR16,. + 0
 3167              	inIdx:
ARM GAS  /tmp/cc14G55i.s 			page 94


 3168 0000 00       		.space	1
 3169              		.section	.bss.inIdx_prev,"aw",%nobits
 3170              		.set	.LANCHOR22,. + 0
 3173              	inIdx_prev:
 3174 0000 00       		.space	1
 3175              		.section	.bss.inp_cal_valid,"aw",%nobits
 3176              		.set	.LANCHOR25,. + 0
 3179              	inp_cal_valid:
 3180 0000 00       		.space	1
 3181              		.section	.bss.rtDW_Left,"aw",%nobits
 3182              		.align	2
 3183              		.set	.LANCHOR2,. + 0
 3186              	rtDW_Left:
 3187 0000 00000000 		.space	172
 3187      00000000 
 3187      00000000 
 3187      00000000 
 3187      00000000 
 3188              		.section	.bss.rtDW_Right,"aw",%nobits
 3189              		.align	2
 3190              		.set	.LANCHOR6,. + 0
 3193              	rtDW_Right:
 3194 0000 00000000 		.space	172
 3194      00000000 
 3194      00000000 
 3194      00000000 
 3194      00000000 
 3195              		.section	.bss.rtM_Left_,"aw",%nobits
 3196              		.align	2
 3197              		.set	.LANCHOR1,. + 0
 3200              	rtM_Left_:
 3201 0000 00000000 		.space	16
 3201      00000000 
 3201      00000000 
 3201      00000000 
 3202              		.section	.bss.rtM_Right_,"aw",%nobits
 3203              		.align	2
 3204              		.set	.LANCHOR5,. + 0
 3207              	rtM_Right_:
 3208 0000 00000000 		.space	16
 3208      00000000 
 3208      00000000 
 3208      00000000 
 3209              		.section	.bss.rtP_Right,"aw",%nobits
 3210              		.align	2
 3211              		.set	.LANCHOR0,. + 0
 3214              	rtP_Right:
 3215 0000 00000000 		.space	256
 3215      00000000 
 3215      00000000 
 3215      00000000 
 3215      00000000 
 3216              		.section	.bss.rtU_Left,"aw",%nobits
 3217              		.align	2
 3218              		.set	.LANCHOR3,. + 0
 3221              	rtU_Left:
 3222 0000 00000000 		.space	16
ARM GAS  /tmp/cc14G55i.s 			page 95


 3222      00000000 
 3222      00000000 
 3222      00000000 
 3223              		.section	.bss.rtU_Right,"aw",%nobits
 3224              		.align	2
 3225              		.set	.LANCHOR7,. + 0
 3228              	rtU_Right:
 3229 0000 00000000 		.space	16
 3229      00000000 
 3229      00000000 
 3229      00000000 
 3230              		.section	.bss.rtY_Left,"aw",%nobits
 3231              		.align	2
 3232              		.set	.LANCHOR4,. + 0
 3235              	rtY_Left:
 3236 0000 00000000 		.space	16
 3236      00000000 
 3236      00000000 
 3236      00000000 
 3237              		.section	.bss.rtY_Right,"aw",%nobits
 3238              		.align	2
 3239              		.set	.LANCHOR8,. + 0
 3242              	rtY_Right:
 3243 0000 00000000 		.space	16
 3243      00000000 
 3243      00000000 
 3243      00000000 
 3244              		.section	.bss.speedAvg,"aw",%nobits
 3245              		.align	1
 3246              		.set	.LANCHOR11,. + 0
 3249              	speedAvg:
 3250 0000 0000     		.space	2
 3251              		.section	.bss.speedAvgAbs,"aw",%nobits
 3252              		.align	1
 3253              		.set	.LANCHOR12,. + 0
 3256              	speedAvgAbs:
 3257 0000 0000     		.space	2
 3258              		.section	.bss.timeoutFlgADC,"aw",%nobits
 3259              		.set	.LANCHOR17,. + 0
 3262              	timeoutFlgADC:
 3263 0000 00       		.space	1
 3264              		.section	.bss.timeoutFlgSerial,"aw",%nobits
 3265              		.set	.LANCHOR19,. + 0
 3268              	timeoutFlgSerial:
 3269 0000 00       		.space	1
 3270              		.section	.data.VirtAddVarTab,"aw"
 3271              		.align	2
 3272              		.set	.LANCHOR13,. + 0
 3275              	VirtAddVarTab:
 3276 0000 E803     		.short	1000
 3277 0002 E903     		.short	1001
 3278 0004 EA03     		.short	1002
 3279 0006 EB03     		.short	1003
 3280 0008 EC03     		.short	1004
 3281 000a ED03     		.short	1005
 3282 000c EE03     		.short	1006
 3283 000e EF03     		.short	1007
ARM GAS  /tmp/cc14G55i.s 			page 96


 3284 0010 F003     		.short	1008
 3285 0012 F103     		.short	1009
 3286 0014 F203     		.short	1010
 3287 0016 F303     		.short	1011
 3288 0018 F403     		.short	1012
 3289 001a F503     		.short	1013
 3290 001c F603     		.short	1014
 3291 001e F703     		.short	1015
 3292 0020 F803     		.short	1016
 3293 0022 F903     		.short	1017
 3294 0024 FA03     		.short	1018
 3295              		.section	.data.ctrlModReq,"aw"
 3296              		.set	.LANCHOR20,. + 0
 3299              	ctrlModReq:
 3300 0000 02       		.byte	2
 3301              		.section	.data.ctrlModReqRaw,"aw"
 3302              		.set	.LANCHOR21,. + 0
 3305              	ctrlModReqRaw:
 3306 0000 02       		.byte	2
 3307              		.section	.data.input1,"aw"
 3308              		.align	2
 3309              		.set	.LANCHOR14,. + 0
 3312              	input1:
 3313 0000 0000     		.short	0
 3314 0002 0000     		.short	0
 3315 0004 00       		.byte	0
 3316 0005 03       		.byte	3
 3317 0006 0000     		.short	0
 3318 0008 0000     		.short	0
 3319 000a FF0F     		.short	4095
 3320 000c 0000     		.short	0
 3321              		.section	.data.input2,"aw"
 3322              		.align	2
 3323              		.set	.LANCHOR15,. + 0
 3326              	input2:
 3327 0000 0000     		.short	0
 3328 0002 0000     		.short	0
 3329 0004 00       		.byte	0
 3330 0005 03       		.byte	3
 3331 0006 0000     		.short	0
 3332 0008 0000     		.short	0
 3333 000a FF0F     		.short	4095
 3334 000c 0000     		.short	0
 3335              		.section	.data.timeoutCntADC,"aw"
 3336              		.align	1
 3337              		.set	.LANCHOR18,. + 0
 3340              	timeoutCntADC:
 3341 0000 6400     		.short	100
 3342              		.section	.rodata.rtM_Left,"a"
 3343              		.align	2
 3346              	rtM_Left:
 3347 0000 00000000 		.word	rtM_Left_
 3348              		.section	.rodata.rtM_Right,"a"
 3349              		.align	2
 3352              	rtM_Right:
 3353 0000 00000000 		.word	rtM_Right_
 3354              		.text
ARM GAS  /tmp/cc14G55i.s 			page 97


 3355              	.Letext0:
 3356              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 3357              		.file 3 "/usr/include/newlib/sys/_stdint.h"
 3358              		.file 4 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 3359              		.file 5 "Inc/defines.h"
 3360              		.file 6 "Inc/util.h"
 3361              		.file 7 "Inc/rtwtypes.h"
 3362              		.file 8 "Inc/BLDC_controller.h"
 3363              		.file 9 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 3364              		.file 10 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 3365              		.file 11 "Inc/eeprom.h"
 3366              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_flash.h"
 3367              		.file 13 "/usr/include/newlib/stdio.h"
 3368              		.file 14 "<built-in>"
ARM GAS  /tmp/cc14G55i.s 			page 98


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/cc14G55i.s:16     .text.BLDC_Init:0000000000000000 $t
     /tmp/cc14G55i.s:24     .text.BLDC_Init:0000000000000000 BLDC_Init
     /tmp/cc14G55i.s:134    .text.BLDC_Init:0000000000000084 $d
     /tmp/cc14G55i.s:148    .text.Input_Lim_Init:0000000000000000 $t
     /tmp/cc14G55i.s:155    .text.Input_Lim_Init:0000000000000000 Input_Lim_Init
     /tmp/cc14G55i.s:201    .text.Input_Lim_Init:0000000000000034 $d
     /tmp/cc14G55i.s:209    .text.poweronMelody:0000000000000000 $t
     /tmp/cc14G55i.s:216    .text.poweronMelody:0000000000000000 poweronMelody
     /tmp/cc14G55i.s:272    .text.poweronMelody:0000000000000024 $d
     /tmp/cc14G55i.s:278    .text.beepCount:0000000000000000 $t
     /tmp/cc14G55i.s:285    .text.beepCount:0000000000000000 beepCount
     /tmp/cc14G55i.s:310    .text.beepCount:0000000000000010 $d
     /tmp/cc14G55i.s:317    .text.beepLong:0000000000000000 $t
     /tmp/cc14G55i.s:324    .text.beepLong:0000000000000000 beepLong
     /tmp/cc14G55i.s:362    .text.beepLong:0000000000000018 $d
     /tmp/cc14G55i.s:368    .text.beepShort:0000000000000000 $t
     /tmp/cc14G55i.s:375    .text.beepShort:0000000000000000 beepShort
     /tmp/cc14G55i.s:413    .text.beepShort:0000000000000018 $d
     /tmp/cc14G55i.s:419    .text.beepShortMany:0000000000000000 $t
     /tmp/cc14G55i.s:426    .text.beepShortMany:0000000000000000 beepShortMany
     /tmp/cc14G55i.s:511    .text.calcAvgSpeed:0000000000000000 $t
     /tmp/cc14G55i.s:518    .text.calcAvgSpeed:0000000000000000 calcAvgSpeed
     /tmp/cc14G55i.s:564    .text.calcAvgSpeed:0000000000000030 $d
     /tmp/cc14G55i.s:572    .text.standstillHold:0000000000000000 $t
     /tmp/cc14G55i.s:579    .text.standstillHold:0000000000000000 standstillHold
     /tmp/cc14G55i.s:592    .text.electricBrake:0000000000000000 $t
     /tmp/cc14G55i.s:599    .text.electricBrake:0000000000000000 electricBrake
     /tmp/cc14G55i.s:613    .text.cruiseControl:0000000000000000 $t
     /tmp/cc14G55i.s:620    .text.cruiseControl:0000000000000000 cruiseControl
     /tmp/cc14G55i.s:634    .text.checkInputType:0000000000000000 $t
     /tmp/cc14G55i.s:641    .text.checkInputType:0000000000000000 checkInputType
     /tmp/cc14G55i.s:737    .text.checkInputType:000000000000006c $d
     /tmp/cc14G55i.s:742    .rodata.Input_Init.str1.4:0000000000000000 $d
     /tmp/cc14G55i.s:747    .text.Input_Init:0000000000000000 $t
     /tmp/cc14G55i.s:754    .text.Input_Init:0000000000000000 Input_Init
     /tmp/cc14G55i.s:1108   .text.Input_Init:0000000000000208 $d
     /tmp/cc14G55i.s:1119   .text.calcInputCmd:0000000000000000 $t
     /tmp/cc14G55i.s:1126   .text.calcInputCmd:0000000000000000 calcInputCmd
     /tmp/cc14G55i.s:1266   .text.readInputRaw:0000000000000000 $t
     /tmp/cc14G55i.s:1273   .text.readInputRaw:0000000000000000 readInputRaw
     /tmp/cc14G55i.s:1309   .text.readInputRaw:0000000000000028 $d
     /tmp/cc14G55i.s:1317   .text.handleTimeout:0000000000000000 $t
     /tmp/cc14G55i.s:1324   .text.handleTimeout:0000000000000000 handleTimeout
     /tmp/cc14G55i.s:1490   .text.handleTimeout:00000000000000d8 $d
     /tmp/cc14G55i.s:1504   .text.readCommand:0000000000000000 $t
     /tmp/cc14G55i.s:1511   .text.readCommand:0000000000000000 readCommand
     /tmp/cc14G55i.s:1585   .text.readCommand:000000000000006c $d
     /tmp/cc14G55i.s:1597   .text.usart2_rx_check:0000000000000000 $t
     /tmp/cc14G55i.s:1604   .text.usart2_rx_check:0000000000000000 usart2_rx_check
     /tmp/cc14G55i.s:1617   .text.usart3_rx_check:0000000000000000 $t
     /tmp/cc14G55i.s:1624   .text.usart3_rx_check:0000000000000000 usart3_rx_check
     /tmp/cc14G55i.s:1637   .text.sideboardLeds:0000000000000000 $t
     /tmp/cc14G55i.s:1644   .text.sideboardLeds:0000000000000000 sideboardLeds
     /tmp/cc14G55i.s:1658   .text.sideboardSensors:0000000000000000 $t
     /tmp/cc14G55i.s:1665   .text.sideboardSensors:0000000000000000 sideboardSensors
ARM GAS  /tmp/cc14G55i.s 			page 99


     /tmp/cc14G55i.s:1679   .text.saveConfig:0000000000000000 $t
     /tmp/cc14G55i.s:1686   .text.saveConfig:0000000000000000 saveConfig
     /tmp/cc14G55i.s:1859   .text.saveConfig:00000000000000e4 $d
     /tmp/cc14G55i.s:1870   .text.poweroff:0000000000000000 $t
     /tmp/cc14G55i.s:1877   .text.poweroff:0000000000000000 poweroff
     /tmp/cc14G55i.s:1944   .text.poweroff:0000000000000034 $d
     /tmp/cc14G55i.s:1953   .text.filtLowPass32:0000000000000000 $t
     /tmp/cc14G55i.s:1960   .text.filtLowPass32:0000000000000000 filtLowPass32
     /tmp/cc14G55i.s:2028   .text.adcCalibLim:0000000000000000 $t
     /tmp/cc14G55i.s:2035   .text.adcCalibLim:0000000000000000 adcCalibLim
     /tmp/cc14G55i.s:2340   .text.adcCalibLim:0000000000000164 $d
     /tmp/cc14G55i.s:2351   .text.updateCurSpdLim:0000000000000000 $t
     /tmp/cc14G55i.s:2358   .text.updateCurSpdLim:0000000000000000 updateCurSpdLim
     /tmp/cc14G55i.s:2590   .text.updateCurSpdLim:0000000000000150 $d
     /tmp/cc14G55i.s:2602   .text.poweroffPressCheck:0000000000000000 $t
     /tmp/cc14G55i.s:2609   .text.poweroffPressCheck:0000000000000000 poweroffPressCheck
     /tmp/cc14G55i.s:2748   .text.poweroffPressCheck:0000000000000098 $d
     /tmp/cc14G55i.s:2755   .text.rateLimiter16:0000000000000000 $t
     /tmp/cc14G55i.s:2762   .text.rateLimiter16:0000000000000000 rateLimiter16
     /tmp/cc14G55i.s:2815   .text.mixerFcn:0000000000000000 $t
     /tmp/cc14G55i.s:2822   .text.mixerFcn:0000000000000000 mixerFcn
     /tmp/cc14G55i.s:2941   .text.mixerFcn:0000000000000070 $d
     /tmp/cc14G55i.s:2948   .text.multipleTapDet:0000000000000000 $t
     /tmp/cc14G55i.s:2955   .text.multipleTapDet:0000000000000000 multipleTapDet
     /tmp/cc14G55i.s:3275   .data.VirtAddVarTab:0000000000000000 VirtAddVarTab
     /tmp/cc14G55i.s:3299   .data.ctrlModReq:0000000000000000 ctrlModReq
     /tmp/cc14G55i.s:3305   .data.ctrlModReqRaw:0000000000000000 ctrlModReqRaw
     /tmp/cc14G55i.s:3268   .bss.timeoutFlgSerial:0000000000000000 timeoutFlgSerial
     /tmp/cc14G55i.s:3262   .bss.timeoutFlgADC:0000000000000000 timeoutFlgADC
     /tmp/cc14G55i.s:3256   .bss.speedAvgAbs:0000000000000000 speedAvgAbs
     /tmp/cc14G55i.s:3249   .bss.speedAvg:0000000000000000 speedAvg
     /tmp/cc14G55i.s:3326   .data.input2:0000000000000000 input2
     /tmp/cc14G55i.s:3312   .data.input1:0000000000000000 input1
     /tmp/cc14G55i.s:3173   .bss.inIdx_prev:0000000000000000 inIdx_prev
     /tmp/cc14G55i.s:3167   .bss.inIdx:0000000000000000 inIdx
     /tmp/cc14G55i.s:3242   .bss.rtY_Right:0000000000000000 rtY_Right
     /tmp/cc14G55i.s:3228   .bss.rtU_Right:0000000000000000 rtU_Right
     /tmp/cc14G55i.s:3193   .bss.rtDW_Right:0000000000000000 rtDW_Right
     /tmp/cc14G55i.s:3214   .bss.rtP_Right:0000000000000000 rtP_Right
     /tmp/cc14G55i.s:3235   .bss.rtY_Left:0000000000000000 rtY_Left
     /tmp/cc14G55i.s:3221   .bss.rtU_Left:0000000000000000 rtU_Left
     /tmp/cc14G55i.s:3186   .bss.rtDW_Left:0000000000000000 rtDW_Left
     /tmp/cc14G55i.s:3352   .rodata.rtM_Right:0000000000000000 rtM_Right
     /tmp/cc14G55i.s:3346   .rodata.rtM_Left:0000000000000000 rtM_Left
     /tmp/cc14G55i.s:3207   .bss.rtM_Right_:0000000000000000 rtM_Right_
     /tmp/cc14G55i.s:3200   .bss.rtM_Left_:0000000000000000 rtM_Left_
     /tmp/cc14G55i.s:3132   .bss.INPUT_MAX:0000000000000000 $d
     /tmp/cc14G55i.s:3136   .bss.INPUT_MAX:0000000000000000 INPUT_MAX
     /tmp/cc14G55i.s:3139   .bss.INPUT_MIN:0000000000000000 $d
     /tmp/cc14G55i.s:3143   .bss.INPUT_MIN:0000000000000000 INPUT_MIN
     /tmp/cc14G55i.s:3149   .bss.button1:0000000000000000 button1
     /tmp/cc14G55i.s:3150   .bss.button1:0000000000000000 $d
     /tmp/cc14G55i.s:3155   .bss.button2:0000000000000000 button2
     /tmp/cc14G55i.s:3156   .bss.button2:0000000000000000 $d
     /tmp/cc14G55i.s:3161   .bss.cur_spd_valid:0000000000000000 cur_spd_valid
     /tmp/cc14G55i.s:3162   .bss.cur_spd_valid:0000000000000000 $d
     /tmp/cc14G55i.s:3168   .bss.inIdx:0000000000000000 $d
ARM GAS  /tmp/cc14G55i.s 			page 100


     /tmp/cc14G55i.s:3174   .bss.inIdx_prev:0000000000000000 $d
     /tmp/cc14G55i.s:3179   .bss.inp_cal_valid:0000000000000000 inp_cal_valid
     /tmp/cc14G55i.s:3180   .bss.inp_cal_valid:0000000000000000 $d
     /tmp/cc14G55i.s:3182   .bss.rtDW_Left:0000000000000000 $d
     /tmp/cc14G55i.s:3189   .bss.rtDW_Right:0000000000000000 $d
     /tmp/cc14G55i.s:3196   .bss.rtM_Left_:0000000000000000 $d
     /tmp/cc14G55i.s:3203   .bss.rtM_Right_:0000000000000000 $d
     /tmp/cc14G55i.s:3210   .bss.rtP_Right:0000000000000000 $d
     /tmp/cc14G55i.s:3217   .bss.rtU_Left:0000000000000000 $d
     /tmp/cc14G55i.s:3224   .bss.rtU_Right:0000000000000000 $d
     /tmp/cc14G55i.s:3231   .bss.rtY_Left:0000000000000000 $d
     /tmp/cc14G55i.s:3238   .bss.rtY_Right:0000000000000000 $d
     /tmp/cc14G55i.s:3245   .bss.speedAvg:0000000000000000 $d
     /tmp/cc14G55i.s:3252   .bss.speedAvgAbs:0000000000000000 $d
     /tmp/cc14G55i.s:3263   .bss.timeoutFlgADC:0000000000000000 $d
     /tmp/cc14G55i.s:3269   .bss.timeoutFlgSerial:0000000000000000 $d
     /tmp/cc14G55i.s:3271   .data.VirtAddVarTab:0000000000000000 $d
     /tmp/cc14G55i.s:3308   .data.input1:0000000000000000 $d
     /tmp/cc14G55i.s:3322   .data.input2:0000000000000000 $d
     /tmp/cc14G55i.s:3336   .data.timeoutCntADC:0000000000000000 $d
     /tmp/cc14G55i.s:3340   .data.timeoutCntADC:0000000000000000 timeoutCntADC
     /tmp/cc14G55i.s:3343   .rodata.rtM_Left:0000000000000000 $d
     /tmp/cc14G55i.s:3349   .rodata.rtM_Right:0000000000000000 $d

UNDEFINED SYMBOLS
memcpy
BLDC_controller_initialize
rtP_Left
HAL_Delay
buzzerCount
buzzerFreq
buzzerPattern
HAL_FLASH_Unlock
EE_Init
EE_ReadVariable
printf
HAL_FLASH_Lock
adc_buffer
timeoutFlgGen
HAL_GPIO_ReadPin
EE_WriteVariable
HAL_GPIO_WritePin
enable
