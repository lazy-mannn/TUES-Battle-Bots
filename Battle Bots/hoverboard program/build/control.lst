ARM GAS  /tmp/cczfimbn.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"control.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.Nunchuk_tx,"ax",%progbits
  16              		.align	1
  17              		.global	Nunchuk_tx
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	Nunchuk_tx:
  25              	.LVL0:
  26              	.LFB66:
  27              		.file 1 "Src/control.c"
   1:Src/control.c **** 
   2:Src/control.c **** #include <stdbool.h>
   3:Src/control.c **** #include <string.h>
   4:Src/control.c **** #include "stm32f1xx_hal.h"
   5:Src/control.c **** #include "defines.h"
   6:Src/control.c **** #include "setup.h"
   7:Src/control.c **** #include "config.h"
   8:Src/control.c **** 
   9:Src/control.c **** #define NUNCHUK_I2C_ADDRESS 0xA4
  10:Src/control.c **** 
  11:Src/control.c **** TIM_HandleTypeDef TimHandle;
  12:Src/control.c **** TIM_HandleTypeDef TimHandle2;
  13:Src/control.c **** uint8_t  ppm_count = 0;
  14:Src/control.c **** uint8_t  pwm_count = 0;
  15:Src/control.c **** uint32_t timeoutCntGen = TIMEOUT;
  16:Src/control.c **** uint8_t  timeoutFlgGen = 0;
  17:Src/control.c **** uint8_t  nunchuk_data[6] = {0};
  18:Src/control.c **** 
  19:Src/control.c **** uint8_t i2cBuffer[2];
  20:Src/control.c **** nunchuk_state nunchukState = NUNCHUK_CONNECTING;
  21:Src/control.c **** 
  22:Src/control.c **** extern I2C_HandleTypeDef hi2c2;
  23:Src/control.c **** extern DMA_HandleTypeDef hdma_i2c2_rx;
  24:Src/control.c **** extern DMA_HandleTypeDef hdma_i2c2_tx;
  25:Src/control.c **** 
  26:Src/control.c **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  27:Src/control.c **** uint16_t ppm_captured_value[PPM_NUM_CHANNELS + 1] = {500, 500};
  28:Src/control.c **** uint16_t ppm_captured_value_buffer[PPM_NUM_CHANNELS+1] = {500, 500};
  29:Src/control.c **** uint32_t ppm_timeout = 0;
  30:Src/control.c **** 
  31:Src/control.c **** bool ppm_valid = true;
ARM GAS  /tmp/cczfimbn.s 			page 2


  32:Src/control.c **** 
  33:Src/control.c **** void PPM_ISR_Callback(void) {
  34:Src/control.c ****   // Dummy loop with 16 bit count wrap around
  35:Src/control.c ****   uint16_t rc_delay = TIM2->CNT;
  36:Src/control.c ****   TIM2->CNT = 0;
  37:Src/control.c **** 
  38:Src/control.c ****   if (rc_delay > 3000) {
  39:Src/control.c ****     if (ppm_valid && ppm_count == PPM_NUM_CHANNELS) {
  40:Src/control.c ****       ppm_timeout = 0;
  41:Src/control.c ****       timeoutCntGen = 0;
  42:Src/control.c ****       timeoutFlgGen = 0;
  43:Src/control.c ****       memcpy(ppm_captured_value, ppm_captured_value_buffer, sizeof(ppm_captured_value));
  44:Src/control.c ****     }
  45:Src/control.c ****     ppm_valid = true;
  46:Src/control.c ****     ppm_count = 0;
  47:Src/control.c ****   }
  48:Src/control.c ****   else if (ppm_count < PPM_NUM_CHANNELS && IN_RANGE(rc_delay, 900, 2100)){
  49:Src/control.c ****     ppm_captured_value_buffer[ppm_count++] = CLAMP(rc_delay, 1000, 2000) - 1000;
  50:Src/control.c ****   } else {
  51:Src/control.c ****     ppm_valid = false;
  52:Src/control.c ****   }
  53:Src/control.c **** }
  54:Src/control.c **** 
  55:Src/control.c **** // SysTick executes once each ms
  56:Src/control.c **** void PPM_SysTick_Callback(void) {
  57:Src/control.c ****   ppm_timeout++;
  58:Src/control.c ****   // Stop after 500 ms without PPM signal
  59:Src/control.c ****   if(ppm_timeout > 500) {
  60:Src/control.c ****     int i;
  61:Src/control.c ****     for(i = 0; i < PPM_NUM_CHANNELS; i++) {
  62:Src/control.c ****       ppm_captured_value[i] = 500;
  63:Src/control.c ****     }
  64:Src/control.c ****     ppm_timeout = 0;
  65:Src/control.c ****   }
  66:Src/control.c **** }
  67:Src/control.c **** 
  68:Src/control.c **** void PPM_Init(void) {
  69:Src/control.c ****   GPIO_InitTypeDef GPIO_InitStruct = {0};
  70:Src/control.c ****   /*Configure GPIO pin : PA3 */
  71:Src/control.c ****   GPIO_InitStruct.Pin = PPM_PIN;
  72:Src/control.c ****   GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  73:Src/control.c ****   GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  74:Src/control.c ****   GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  75:Src/control.c ****   HAL_GPIO_Init(PPM_PORT, &GPIO_InitStruct);
  76:Src/control.c **** 
  77:Src/control.c ****   __HAL_RCC_TIM2_CLK_ENABLE();
  78:Src/control.c ****   TimHandle.Instance = TIM2;
  79:Src/control.c ****   TimHandle.Init.Period = UINT16_MAX;
  80:Src/control.c ****   TimHandle.Init.Prescaler = (SystemCoreClock/DELAY_TIM_FREQUENCY_US)-1;;
  81:Src/control.c ****   TimHandle.Init.ClockDivision = 0;
  82:Src/control.c ****   TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
  83:Src/control.c ****   HAL_TIM_Base_Init(&TimHandle);
  84:Src/control.c **** 
  85:Src/control.c ****   #if defined(CONTROL_PPM_LEFT)  
  86:Src/control.c ****   /* EXTI interrupt init*/
  87:Src/control.c ****   HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);
  88:Src/control.c ****   HAL_NVIC_EnableIRQ(EXTI3_IRQn);
ARM GAS  /tmp/cczfimbn.s 			page 3


  89:Src/control.c ****   #endif
  90:Src/control.c **** 
  91:Src/control.c ****   #if defined(CONTROL_PPM_RIGHT)  
  92:Src/control.c ****   /* EXTI interrupt init*/
  93:Src/control.c ****   HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
  94:Src/control.c ****   HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
  95:Src/control.c ****   #endif
  96:Src/control.c **** 
  97:Src/control.c ****   HAL_TIM_Base_Start(&TimHandle);
  98:Src/control.c **** }
  99:Src/control.c **** #endif
 100:Src/control.c **** 
 101:Src/control.c **** 
 102:Src/control.c **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 103:Src/control.c ****  /*
 104:Src/control.c ****   * Illustration of the PWM functionality
 105:Src/control.c ****   * CH1 ________|‾‾‾‾‾‾‾‾‾‾|________
 106:Src/control.c ****   * CH2 ______________|‾‾‾‾‾‾‾‾‾‾‾|________
 107:Src/control.c ****   *             ↑     ↑    ↑      ↑
 108:Src/control.c ****   * TIM2       RST  SAVE RC_CH1 RC_CH1
 109:Src/control.c ****  */
 110:Src/control.c **** 
 111:Src/control.c **** uint16_t pwm_captured_ch1_value = 500;
 112:Src/control.c **** uint16_t pwm_captured_ch2_value = 500;
 113:Src/control.c **** uint16_t pwm_CNT_prev_ch1 = 0;
 114:Src/control.c **** uint16_t pwm_CNT_prev_ch2 = 0;
 115:Src/control.c **** uint32_t pwm_timeout_ch1 = 0;
 116:Src/control.c **** uint32_t pwm_timeout_ch2 = 0;
 117:Src/control.c **** 
 118:Src/control.c **** void PWM_ISR_CH1_Callback(void) {
 119:Src/control.c ****   // Dummy loop with 16 bit count wrap around
 120:Src/control.c ****   if(HAL_GPIO_ReadPin(PWM_PORT_CH1, PWM_PIN_CH1)) {   // Rising  Edge interrupt -> save timer value
 121:Src/control.c ****     if (HAL_GPIO_ReadPin(PWM_PORT_CH2, PWM_PIN_CH2)) {
 122:Src/control.c ****       pwm_CNT_prev_ch1 = TIM2->CNT;
 123:Src/control.c ****     } else {
 124:Src/control.c ****       TIM2->CNT = 0;
 125:Src/control.c ****       pwm_CNT_prev_ch1 = 0;
 126:Src/control.c ****     }
 127:Src/control.c ****   } else {                                    // Falling Edge interrupt -> measure pulse duration
 128:Src/control.c ****     uint16_t rc_signal = TIM2->CNT - pwm_CNT_prev_ch1;
 129:Src/control.c ****     if (IN_RANGE(rc_signal, 900, 2100)){
 130:Src/control.c ****       timeoutCntGen = 0;
 131:Src/control.c ****       timeoutFlgGen = 0;
 132:Src/control.c ****       pwm_timeout_ch1 = 0;
 133:Src/control.c ****       pwm_captured_ch1_value = CLAMP(rc_signal, 1000, 2000) - 1000;
 134:Src/control.c ****     }
 135:Src/control.c ****   }
 136:Src/control.c **** }
 137:Src/control.c **** 
 138:Src/control.c **** void PWM_ISR_CH2_Callback(void) {
 139:Src/control.c ****   // Dummy loop with 16 bit count wrap around
 140:Src/control.c ****   if(HAL_GPIO_ReadPin(PWM_PORT_CH2, PWM_PIN_CH2)) {   // Rising  Edge interrupt -> save timer value
 141:Src/control.c ****     if (HAL_GPIO_ReadPin(PWM_PORT_CH1, PWM_PIN_CH1)) {
 142:Src/control.c ****       pwm_CNT_prev_ch2 = TIM2->CNT;
 143:Src/control.c ****     } else {
 144:Src/control.c ****       TIM2->CNT = 0;
 145:Src/control.c ****       pwm_CNT_prev_ch2 = 0;
ARM GAS  /tmp/cczfimbn.s 			page 4


 146:Src/control.c ****     }
 147:Src/control.c ****   } else {                                    // Falling Edge interrupt -> measure pulse duration
 148:Src/control.c ****     uint16_t rc_signal = TIM2->CNT - pwm_CNT_prev_ch2;
 149:Src/control.c ****     if (IN_RANGE(rc_signal, 900, 2100)){
 150:Src/control.c ****       timeoutCntGen = 0;
 151:Src/control.c ****       timeoutFlgGen = 0;
 152:Src/control.c ****       pwm_timeout_ch2 = 0;
 153:Src/control.c ****       pwm_captured_ch2_value = CLAMP(rc_signal, 1000, 2000) - 1000;
 154:Src/control.c ****     }
 155:Src/control.c ****   }
 156:Src/control.c **** }
 157:Src/control.c **** 
 158:Src/control.c **** // SysTick executes once each ms
 159:Src/control.c **** void PWM_SysTick_Callback(void) {
 160:Src/control.c ****   pwm_timeout_ch1++;
 161:Src/control.c ****   pwm_timeout_ch2++;
 162:Src/control.c ****   // Stop after 500 ms without PWM signal
 163:Src/control.c ****   if(pwm_timeout_ch1 > 500) {
 164:Src/control.c ****     pwm_captured_ch1_value = 500;
 165:Src/control.c ****     pwm_timeout_ch1 = 0;
 166:Src/control.c ****   }
 167:Src/control.c ****   if(pwm_timeout_ch2 > 500) {
 168:Src/control.c ****     pwm_captured_ch2_value = 500;
 169:Src/control.c ****     pwm_timeout_ch2 = 0;
 170:Src/control.c ****   }
 171:Src/control.c **** }
 172:Src/control.c **** 
 173:Src/control.c **** void PWM_Init(void) {
 174:Src/control.c ****   // PWM Timer (TIM2)
 175:Src/control.c ****   __HAL_RCC_TIM2_CLK_ENABLE();
 176:Src/control.c ****   TimHandle.Instance            = TIM2;
 177:Src/control.c ****   TimHandle.Init.Period         = UINT16_MAX;
 178:Src/control.c ****   TimHandle.Init.Prescaler      = (SystemCoreClock/DELAY_TIM_FREQUENCY_US)-1;;
 179:Src/control.c ****   TimHandle.Init.ClockDivision  = 0;
 180:Src/control.c ****   TimHandle.Init.CounterMode    = TIM_COUNTERMODE_UP;
 181:Src/control.c ****   HAL_TIM_Base_Init(&TimHandle);  
 182:Src/control.c ****   
 183:Src/control.c ****   // Channel 1 (steering)
 184:Src/control.c ****   GPIO_InitTypeDef GPIO_InitStruct1 = {0};
 185:Src/control.c ****   // Configure GPIO pin : PA2 (Left) or PB10 (Right)
 186:Src/control.c ****   GPIO_InitStruct1.Pin          = PWM_PIN_CH1;
 187:Src/control.c ****   GPIO_InitStruct1.Mode         = GPIO_MODE_IT_RISING_FALLING;
 188:Src/control.c ****   GPIO_InitStruct1.Speed        = GPIO_SPEED_FREQ_HIGH;
 189:Src/control.c ****   GPIO_InitStruct1.Pull         = GPIO_PULLDOWN;
 190:Src/control.c ****   HAL_GPIO_Init(PWM_PORT_CH1, &GPIO_InitStruct1);
 191:Src/control.c **** 
 192:Src/control.c ****   // Channel 2 (speed)
 193:Src/control.c ****   GPIO_InitTypeDef GPIO_InitStruct2 = {0};
 194:Src/control.c ****   /*Configure GPIO pin : PA3 (Left) or PB11 (Right) */
 195:Src/control.c ****   GPIO_InitStruct2.Pin          = PWM_PIN_CH2;
 196:Src/control.c ****   GPIO_InitStruct2.Mode         = GPIO_MODE_IT_RISING_FALLING;
 197:Src/control.c ****   GPIO_InitStruct2.Speed        = GPIO_SPEED_FREQ_HIGH;
 198:Src/control.c ****   GPIO_InitStruct2.Pull         = GPIO_PULLDOWN;
 199:Src/control.c ****   HAL_GPIO_Init(PWM_PORT_CH2, &GPIO_InitStruct2);
 200:Src/control.c **** 
 201:Src/control.c ****   #ifdef CONTROL_PWM_LEFT
 202:Src/control.c ****   /* EXTI interrupt init*/
ARM GAS  /tmp/cczfimbn.s 			page 5


 203:Src/control.c ****   HAL_NVIC_SetPriority(EXTI2_IRQn, 0, 0);
 204:Src/control.c ****   HAL_NVIC_EnableIRQ(EXTI2_IRQn);
 205:Src/control.c ****   HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);
 206:Src/control.c ****   HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 207:Src/control.c ****   #endif
 208:Src/control.c **** 
 209:Src/control.c ****   #ifdef CONTROL_PWM_RIGHT
 210:Src/control.c ****   /* EXTI interrupt init*/
 211:Src/control.c ****   HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
 212:Src/control.c ****   HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 213:Src/control.c ****   #endif
 214:Src/control.c **** 
 215:Src/control.c ****   // Start timer
 216:Src/control.c ****   HAL_TIM_Base_Start(&TimHandle);
 217:Src/control.c **** }
 218:Src/control.c **** #endif
 219:Src/control.c **** 
 220:Src/control.c **** uint8_t Nunchuk_tx(uint8_t i2cBuffer[], uint8_t i2cBufferLength) {
  28              		.loc 1 220 66 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		.loc 1 220 66 is_stmt 0 view .LVU1
  33 0000 00B5     		push	{lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 4
  36              		.cfi_offset 14, -4
  37 0002 83B0     		sub	sp, sp, #12
  38              	.LCFI1:
  39              		.cfi_def_cfa_offset 16
  40 0004 0246     		mov	r2, r0
  41 0006 0B46     		mov	r3, r1
 221:Src/control.c ****   if(HAL_I2C_Master_Transmit(&hi2c2,NUNCHUK_I2C_ADDRESS,(uint8_t*)i2cBuffer, i2cBufferLength, 100) 
  42              		.loc 1 221 3 is_stmt 1 view .LVU2
  43              		.loc 1 221 6 is_stmt 0 view .LVU3
  44 0008 6421     		movs	r1, #100
  45              	.LVL1:
  46              		.loc 1 221 6 view .LVU4
  47 000a 0091     		str	r1, [sp]
  48 000c A421     		movs	r1, #164
  49 000e 0548     		ldr	r0, .L5
  50              	.LVL2:
  51              		.loc 1 221 6 view .LVU5
  52 0010 FFF7FEFF 		bl	HAL_I2C_Master_Transmit
  53              	.LVL3:
  54              		.loc 1 221 5 view .LVU6
  55 0014 18B1     		cbz	r0, .L3
 222:Src/control.c ****     return true;
 223:Src/control.c ****   }
 224:Src/control.c ****   return false;
  56              		.loc 1 224 10 view .LVU7
  57 0016 0020     		movs	r0, #0
  58              	.L2:
 225:Src/control.c **** }
  59              		.loc 1 225 1 view .LVU8
  60 0018 03B0     		add	sp, sp, #12
  61              	.LCFI2:
ARM GAS  /tmp/cczfimbn.s 			page 6


  62              		.cfi_remember_state
  63              		.cfi_def_cfa_offset 4
  64              		@ sp needed
  65 001a 5DF804FB 		ldr	pc, [sp], #4
  66              	.L3:
  67              	.LCFI3:
  68              		.cfi_restore_state
 222:Src/control.c ****     return true;
  69              		.loc 1 222 12 view .LVU9
  70 001e 0120     		movs	r0, #1
  71 0020 FAE7     		b	.L2
  72              	.L6:
  73 0022 00BF     		.align	2
  74              	.L5:
  75 0024 00000000 		.word	hi2c2
  76              		.cfi_endproc
  77              	.LFE66:
  79              		.section	.text.Nunchuk_rx,"ax",%progbits
  80              		.align	1
  81              		.global	Nunchuk_rx
  82              		.syntax unified
  83              		.thumb
  84              		.thumb_func
  85              		.fpu softvfp
  87              	Nunchuk_rx:
  88              	.LVL4:
  89              	.LFB67:
 226:Src/control.c **** 
 227:Src/control.c **** uint8_t Nunchuk_rx(uint8_t i2cBuffer[], uint8_t i2cBufferLength) {
  90              		.loc 1 227 66 is_stmt 1 view -0
  91              		.cfi_startproc
  92              		@ args = 0, pretend = 0, frame = 0
  93              		@ frame_needed = 0, uses_anonymous_args = 0
  94              		.loc 1 227 66 is_stmt 0 view .LVU11
  95 0000 00B5     		push	{lr}
  96              	.LCFI4:
  97              		.cfi_def_cfa_offset 4
  98              		.cfi_offset 14, -4
  99 0002 83B0     		sub	sp, sp, #12
 100              	.LCFI5:
 101              		.cfi_def_cfa_offset 16
 102 0004 0246     		mov	r2, r0
 103 0006 0B46     		mov	r3, r1
 228:Src/control.c ****   if(HAL_I2C_Master_Receive(&hi2c2,NUNCHUK_I2C_ADDRESS,(uint8_t*)i2cBuffer, i2cBufferLength, 100) =
 104              		.loc 1 228 3 is_stmt 1 view .LVU12
 105              		.loc 1 228 6 is_stmt 0 view .LVU13
 106 0008 6421     		movs	r1, #100
 107              	.LVL5:
 108              		.loc 1 228 6 view .LVU14
 109 000a 0091     		str	r1, [sp]
 110 000c A421     		movs	r1, #164
 111 000e 0548     		ldr	r0, .L11
 112              	.LVL6:
 113              		.loc 1 228 6 view .LVU15
 114 0010 FFF7FEFF 		bl	HAL_I2C_Master_Receive
 115              	.LVL7:
 116              		.loc 1 228 5 view .LVU16
ARM GAS  /tmp/cczfimbn.s 			page 7


 117 0014 18B1     		cbz	r0, .L9
 229:Src/control.c ****     return true;
 230:Src/control.c ****   }
 231:Src/control.c ****   return false;
 118              		.loc 1 231 10 view .LVU17
 119 0016 0020     		movs	r0, #0
 120              	.L8:
 232:Src/control.c **** }
 121              		.loc 1 232 1 view .LVU18
 122 0018 03B0     		add	sp, sp, #12
 123              	.LCFI6:
 124              		.cfi_remember_state
 125              		.cfi_def_cfa_offset 4
 126              		@ sp needed
 127 001a 5DF804FB 		ldr	pc, [sp], #4
 128              	.L9:
 129              	.LCFI7:
 130              		.cfi_restore_state
 229:Src/control.c ****     return true;
 131              		.loc 1 229 12 view .LVU19
 132 001e 0120     		movs	r0, #1
 133 0020 FAE7     		b	.L8
 134              	.L12:
 135 0022 00BF     		.align	2
 136              	.L11:
 137 0024 00000000 		.word	hi2c2
 138              		.cfi_endproc
 139              	.LFE67:
 141              		.section	.text.Nunchuk_Init,"ax",%progbits
 142              		.align	1
 143              		.global	Nunchuk_Init
 144              		.syntax unified
 145              		.thumb
 146              		.thumb_func
 147              		.fpu softvfp
 149              	Nunchuk_Init:
 150              	.LFB68:
 233:Src/control.c **** 
 234:Src/control.c **** uint8_t Nunchuk_Init(void) {
 151              		.loc 1 234 28 is_stmt 1 view -0
 152              		.cfi_startproc
 153              		@ args = 0, pretend = 0, frame = 0
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 155 0000 08B5     		push	{r3, lr}
 156              	.LCFI8:
 157              		.cfi_def_cfa_offset 8
 158              		.cfi_offset 3, -8
 159              		.cfi_offset 14, -4
 235:Src/control.c ****   //-- START -- init WiiNunchuk
 236:Src/control.c ****   i2cBuffer[0] = 0xF0;
 160              		.loc 1 236 3 view .LVU21
 161              		.loc 1 236 16 is_stmt 0 view .LVU22
 162 0002 0E48     		ldr	r0, .L17
 163 0004 F023     		movs	r3, #240
 164 0006 0370     		strb	r3, [r0]
 237:Src/control.c ****   i2cBuffer[1] = 0x55;
 165              		.loc 1 237 3 is_stmt 1 view .LVU23
ARM GAS  /tmp/cczfimbn.s 			page 8


 166              		.loc 1 237 16 is_stmt 0 view .LVU24
 167 0008 5523     		movs	r3, #85
 168 000a 4370     		strb	r3, [r0, #1]
 238:Src/control.c **** 
 239:Src/control.c ****   if(Nunchuk_tx(i2cBuffer, 2) == false) {
 169              		.loc 1 239 3 is_stmt 1 view .LVU25
 170              		.loc 1 239 6 is_stmt 0 view .LVU26
 171 000c 0221     		movs	r1, #2
 172 000e FFF7FEFF 		bl	Nunchuk_tx
 173              	.LVL8:
 174              		.loc 1 239 5 view .LVU27
 175 0012 00B9     		cbnz	r0, .L16
 176              	.L14:
 240:Src/control.c ****     return false;
 241:Src/control.c ****   }
 242:Src/control.c ****   HAL_Delay(10);
 243:Src/control.c **** 
 244:Src/control.c ****   i2cBuffer[0] = 0xFB;
 245:Src/control.c ****   i2cBuffer[1] = 0x00;
 246:Src/control.c **** 
 247:Src/control.c ****   if(Nunchuk_tx(i2cBuffer, 2) == false) {
 248:Src/control.c ****     return false;
 249:Src/control.c ****   }
 250:Src/control.c ****   HAL_Delay(10);
 251:Src/control.c **** 
 252:Src/control.c ****   return true;
 253:Src/control.c **** }
 177              		.loc 1 253 1 view .LVU28
 178 0014 08BD     		pop	{r3, pc}
 179              	.L16:
 242:Src/control.c **** 
 180              		.loc 1 242 3 is_stmt 1 view .LVU29
 181 0016 0A20     		movs	r0, #10
 182 0018 FFF7FEFF 		bl	HAL_Delay
 183              	.LVL9:
 244:Src/control.c ****   i2cBuffer[1] = 0x00;
 184              		.loc 1 244 3 view .LVU30
 244:Src/control.c ****   i2cBuffer[1] = 0x00;
 185              		.loc 1 244 16 is_stmt 0 view .LVU31
 186 001c 0748     		ldr	r0, .L17
 187 001e FB23     		movs	r3, #251
 188 0020 0370     		strb	r3, [r0]
 245:Src/control.c **** 
 189              		.loc 1 245 3 is_stmt 1 view .LVU32
 245:Src/control.c **** 
 190              		.loc 1 245 16 is_stmt 0 view .LVU33
 191 0022 0023     		movs	r3, #0
 192 0024 4370     		strb	r3, [r0, #1]
 247:Src/control.c ****     return false;
 193              		.loc 1 247 3 is_stmt 1 view .LVU34
 247:Src/control.c ****     return false;
 194              		.loc 1 247 6 is_stmt 0 view .LVU35
 195 0026 0221     		movs	r1, #2
 196 0028 FFF7FEFF 		bl	Nunchuk_tx
 197              	.LVL10:
 247:Src/control.c ****     return false;
 198              		.loc 1 247 5 view .LVU36
ARM GAS  /tmp/cczfimbn.s 			page 9


 199 002c 0028     		cmp	r0, #0
 200 002e F1D0     		beq	.L14
 250:Src/control.c **** 
 201              		.loc 1 250 3 is_stmt 1 view .LVU37
 202 0030 0A20     		movs	r0, #10
 203 0032 FFF7FEFF 		bl	HAL_Delay
 204              	.LVL11:
 252:Src/control.c **** }
 205              		.loc 1 252 3 view .LVU38
 252:Src/control.c **** }
 206              		.loc 1 252 10 is_stmt 0 view .LVU39
 207 0036 0120     		movs	r0, #1
 208 0038 ECE7     		b	.L14
 209              	.L18:
 210 003a 00BF     		.align	2
 211              	.L17:
 212 003c 00000000 		.word	.LANCHOR0
 213              		.cfi_endproc
 214              	.LFE68:
 216              		.section	.text.Nunchuk_Connect,"ax",%progbits
 217              		.align	1
 218              		.global	Nunchuk_Connect
 219              		.syntax unified
 220              		.thumb
 221              		.thumb_func
 222              		.fpu softvfp
 224              	Nunchuk_Connect:
 225              	.LFB69:
 254:Src/control.c **** 
 255:Src/control.c **** uint8_t Nunchuk_Connect() {
 226              		.loc 1 255 27 is_stmt 1 view -0
 227              		.cfi_startproc
 228              		@ args = 0, pretend = 0, frame = 0
 229              		@ frame_needed = 0, uses_anonymous_args = 0
 230 0000 08B5     		push	{r3, lr}
 231              	.LCFI9:
 232              		.cfi_def_cfa_offset 8
 233              		.cfi_offset 3, -8
 234              		.cfi_offset 14, -4
 256:Src/control.c ****   /* Initialise / re-initialise I2C peripheral */
 257:Src/control.c ****   I2C_Init();
 235              		.loc 1 257 3 view .LVU41
 236 0002 FFF7FEFF 		bl	I2C_Init
 237              	.LVL12:
 258:Src/control.c ****   
 259:Src/control.c ****   /* Initialise / re-initialise nunchuk */
 260:Src/control.c ****   if(Nunchuk_Init() == true) {
 238              		.loc 1 260 3 view .LVU42
 239              		.loc 1 260 6 is_stmt 0 view .LVU43
 240 0006 FFF7FEFF 		bl	Nunchuk_Init
 241              	.LVL13:
 242              		.loc 1 260 5 view .LVU44
 243 000a 0128     		cmp	r0, #1
 244 000c 01D0     		beq	.L23
 261:Src/control.c ****     nunchukState = NUNCHUK_CONNECTED;
 262:Src/control.c ****     return true;
 263:Src/control.c ****   } else {
ARM GAS  /tmp/cczfimbn.s 			page 10


 264:Src/control.c ****     return false;
 245              		.loc 1 264 12 view .LVU45
 246 000e 0020     		movs	r0, #0
 247              	.L20:
 265:Src/control.c ****   }
 266:Src/control.c **** }
 248              		.loc 1 266 1 view .LVU46
 249 0010 08BD     		pop	{r3, pc}
 250              	.L23:
 261:Src/control.c ****     nunchukState = NUNCHUK_CONNECTED;
 251              		.loc 1 261 5 is_stmt 1 view .LVU47
 261:Src/control.c ****     nunchukState = NUNCHUK_CONNECTED;
 252              		.loc 1 261 18 is_stmt 0 view .LVU48
 253 0012 024B     		ldr	r3, .L24
 254 0014 0322     		movs	r2, #3
 255 0016 1A70     		strb	r2, [r3]
 262:Src/control.c ****   } else {
 256              		.loc 1 262 5 is_stmt 1 view .LVU49
 262:Src/control.c ****   } else {
 257              		.loc 1 262 12 is_stmt 0 view .LVU50
 258 0018 FAE7     		b	.L20
 259              	.L25:
 260 001a 00BF     		.align	2
 261              	.L24:
 262 001c 00000000 		.word	.LANCHOR1
 263              		.cfi_endproc
 264              	.LFE69:
 266              		.section	.text.Nunchuk_Read,"ax",%progbits
 267              		.align	1
 268              		.global	Nunchuk_Read
 269              		.syntax unified
 270              		.thumb
 271              		.thumb_func
 272              		.fpu softvfp
 274              	Nunchuk_Read:
 275              	.LFB70:
 267:Src/control.c **** 
 268:Src/control.c **** nunchuk_state Nunchuk_Read(void) {
 276              		.loc 1 268 34 is_stmt 1 view -0
 277              		.cfi_startproc
 278              		@ args = 0, pretend = 0, frame = 0
 279              		@ frame_needed = 0, uses_anonymous_args = 0
 280 0000 38B5     		push	{r3, r4, r5, lr}
 281              	.LCFI10:
 282              		.cfi_def_cfa_offset 16
 283              		.cfi_offset 3, -16
 284              		.cfi_offset 4, -12
 285              		.cfi_offset 5, -8
 286              		.cfi_offset 14, -4
 269:Src/control.c ****   static uint8_t delay_counter = 0;
 287              		.loc 1 269 3 view .LVU52
 270:Src/control.c ****   uint16_t checksum = 0;
 288              		.loc 1 270 3 view .LVU53
 289              	.LVL14:
 271:Src/control.c ****   uint8_t success = true;
 290              		.loc 1 271 3 view .LVU54
 272:Src/control.c ****   uint8_t i = 0;
ARM GAS  /tmp/cczfimbn.s 			page 11


 291              		.loc 1 272 3 view .LVU55
 273:Src/control.c **** 
 274:Src/control.c ****   switch(nunchukState) {
 292              		.loc 1 274 3 view .LVU56
 293 0002 3A4B     		ldr	r3, .L46
 294 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 295 0006 032B     		cmp	r3, #3
 296 0008 62D8     		bhi	.L27
 297 000a DFE803F0 		tbb	[pc, r3]
 298              	.L29:
 299 000e 0F       		.byte	(.L30-.L29)/2
 300 000f 02       		.byte	(.L31-.L29)/2
 301 0010 0F       		.byte	(.L30-.L29)/2
 302 0011 18       		.byte	(.L28-.L29)/2
 303              		.p2align 1
 304              	.L31:
 275:Src/control.c ****     case NUNCHUK_DISCONNECTED:
 276:Src/control.c ****       success = false;
 305              		.loc 1 276 7 view .LVU57
 306              	.LVL15:
 277:Src/control.c ****       /* Delay a bit before reconnecting */
 278:Src/control.c ****       if(delay_counter++ > 100) {
 307              		.loc 1 278 7 view .LVU58
 308              		.loc 1 278 23 is_stmt 0 view .LVU59
 309 0012 374A     		ldr	r2, .L46+4
 310 0014 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 311 0016 591C     		adds	r1, r3, #1
 312 0018 1170     		strb	r1, [r2]
 313              		.loc 1 278 9 view .LVU60
 314 001a 642B     		cmp	r3, #100
 315 001c 5DD9     		bls	.L32
 279:Src/control.c ****         success = Nunchuk_Connect();
 316              		.loc 1 279 9 is_stmt 1 view .LVU61
 317              		.loc 1 279 19 is_stmt 0 view .LVU62
 318 001e FFF7FEFF 		bl	Nunchuk_Connect
 319              	.LVL16:
 320 0022 0446     		mov	r4, r0
 321              	.LVL17:
 280:Src/control.c ****         delay_counter = 0;
 322              		.loc 1 280 9 is_stmt 1 view .LVU63
 323              		.loc 1 280 23 is_stmt 0 view .LVU64
 324 0024 324B     		ldr	r3, .L46+4
 325 0026 0022     		movs	r2, #0
 326 0028 1A70     		strb	r2, [r3]
 327 002a 4FE0     		b	.L33
 328              	.LVL18:
 329              	.L30:
 281:Src/control.c ****       }
 282:Src/control.c ****       break;
 283:Src/control.c ****       
 284:Src/control.c ****     case NUNCHUK_CONNECTING:
 285:Src/control.c ****     case NUNCHUK_RECONNECTING:
 286:Src/control.c ****         /* Try to reconnect once, if fails again fall back to disconnected state */
 287:Src/control.c ****         success = Nunchuk_Connect();
 330              		.loc 1 287 9 is_stmt 1 view .LVU65
 331              		.loc 1 287 19 is_stmt 0 view .LVU66
 332 002c FFF7FEFF 		bl	Nunchuk_Connect
ARM GAS  /tmp/cczfimbn.s 			page 12


 333              	.LVL19:
 288:Src/control.c ****         if(!success) {
 334              		.loc 1 288 9 is_stmt 1 view .LVU67
 335              		.loc 1 288 11 is_stmt 0 view .LVU68
 336 0030 0446     		mov	r4, r0
 337 0032 0028     		cmp	r0, #0
 338 0034 4AD1     		bne	.L33
 289:Src/control.c ****           nunchukState = NUNCHUK_DISCONNECTED;
 339              		.loc 1 289 11 is_stmt 1 view .LVU69
 340              		.loc 1 289 24 is_stmt 0 view .LVU70
 341 0036 2D4B     		ldr	r3, .L46
 342 0038 0122     		movs	r2, #1
 343 003a 1A70     		strb	r2, [r3]
 344 003c 46E0     		b	.L33
 345              	.LVL20:
 346              	.L28:
 290:Src/control.c ****         }
 291:Src/control.c ****       break;
 292:Src/control.c **** 
 293:Src/control.c ****     case NUNCHUK_CONNECTED:
 294:Src/control.c ****       /* Send read address of 0x00 to the Nunchuk */
 295:Src/control.c ****       i2cBuffer[0] = 0x00;
 347              		.loc 1 295 7 is_stmt 1 view .LVU71
 348              		.loc 1 295 20 is_stmt 0 view .LVU72
 349 003e 2D48     		ldr	r0, .L46+8
 350 0040 0023     		movs	r3, #0
 351 0042 0370     		strb	r3, [r0]
 296:Src/control.c ****       if(!Nunchuk_tx(i2cBuffer, 1)) {
 352              		.loc 1 296 7 is_stmt 1 view .LVU73
 353              		.loc 1 296 11 is_stmt 0 view .LVU74
 354 0044 0121     		movs	r1, #1
 355 0046 FFF7FEFF 		bl	Nunchuk_tx
 356              	.LVL21:
 357              		.loc 1 296 9 view .LVU75
 358 004a 0546     		mov	r5, r0
 359 004c 00B1     		cbz	r0, .L34
 271:Src/control.c ****   uint8_t i = 0;
 360              		.loc 1 271 11 view .LVU76
 361 004e 0125     		movs	r5, #1
 362              	.L34:
 363              	.LVL22:
 297:Src/control.c ****         success = false;
 298:Src/control.c ****       }
 299:Src/control.c ****       HAL_Delay(3);
 364              		.loc 1 299 7 is_stmt 1 view .LVU77
 365 0050 0320     		movs	r0, #3
 366 0052 FFF7FEFF 		bl	HAL_Delay
 367              	.LVL23:
 300:Src/control.c **** 
 301:Src/control.c ****       /* Clear the receive data buffer */
 302:Src/control.c ****       for(i = 0; i<6; i++) {
 368              		.loc 1 302 7 view .LVU78
 369              		.loc 1 302 13 is_stmt 0 view .LVU79
 370 0056 0023     		movs	r3, #0
 371              		.loc 1 302 7 view .LVU80
 372 0058 04E0     		b	.L35
 373              	.LVL24:
ARM GAS  /tmp/cczfimbn.s 			page 13


 374              	.L36:
 303:Src/control.c ****         nunchuk_data[i] = 0;
 375              		.loc 1 303 9 is_stmt 1 discriminator 3 view .LVU81
 376              		.loc 1 303 25 is_stmt 0 discriminator 3 view .LVU82
 377 005a 274A     		ldr	r2, .L46+12
 378 005c 0021     		movs	r1, #0
 379 005e D154     		strb	r1, [r2, r3]
 302:Src/control.c ****         nunchuk_data[i] = 0;
 380              		.loc 1 302 23 is_stmt 1 discriminator 3 view .LVU83
 302:Src/control.c ****         nunchuk_data[i] = 0;
 381              		.loc 1 302 24 is_stmt 0 discriminator 3 view .LVU84
 382 0060 0133     		adds	r3, r3, #1
 383              	.LVL25:
 302:Src/control.c ****         nunchuk_data[i] = 0;
 384              		.loc 1 302 24 discriminator 3 view .LVU85
 385 0062 DBB2     		uxtb	r3, r3
 386              	.LVL26:
 387              	.L35:
 302:Src/control.c ****         nunchuk_data[i] = 0;
 388              		.loc 1 302 18 is_stmt 1 discriminator 1 view .LVU86
 302:Src/control.c ****         nunchuk_data[i] = 0;
 389              		.loc 1 302 7 is_stmt 0 discriminator 1 view .LVU87
 390 0064 052B     		cmp	r3, #5
 391 0066 F8D9     		bls	.L36
 304:Src/control.c ****       }
 305:Src/control.c **** 
 306:Src/control.c ****       /* Read back 6 bytes from the Nunchuk */
 307:Src/control.c ****       if(!Nunchuk_rx(nunchuk_data, 6)) {
 392              		.loc 1 307 7 is_stmt 1 view .LVU88
 393              		.loc 1 307 11 is_stmt 0 view .LVU89
 394 0068 0621     		movs	r1, #6
 395 006a 2348     		ldr	r0, .L46+12
 396 006c FFF7FEFF 		bl	Nunchuk_rx
 397              	.LVL27:
 398              		.loc 1 307 9 view .LVU90
 399 0070 0446     		mov	r4, r0
 400 0072 00B1     		cbz	r0, .L37
 401 0074 2C46     		mov	r4, r5
 402              	.L37:
 403              	.LVL28:
 308:Src/control.c ****         success = false;
 309:Src/control.c ****       }
 310:Src/control.c ****       HAL_Delay(3);
 404              		.loc 1 310 7 is_stmt 1 view .LVU91
 405 0076 0320     		movs	r0, #3
 406 0078 FFF7FEFF 		bl	HAL_Delay
 407              	.LVL29:
 311:Src/control.c **** 
 312:Src/control.c ****       /* Checksum the receive buffer to ensure it is not in an error condition, i.e. all 0x00 or 0x
 313:Src/control.c ****       for(i = 0; i<6; i++) {
 408              		.loc 1 313 7 view .LVU92
 409              		.loc 1 313 13 is_stmt 0 view .LVU93
 410 007c 0023     		movs	r3, #0
 270:Src/control.c ****   uint8_t success = true;
 411              		.loc 1 270 12 view .LVU94
 412 007e 1A46     		mov	r2, r3
 413              		.loc 1 313 7 view .LVU95
ARM GAS  /tmp/cczfimbn.s 			page 14


 414 0080 05E0     		b	.L38
 415              	.LVL30:
 416              	.L39:
 314:Src/control.c ****         checksum += nunchuk_data[i];
 417              		.loc 1 314 9 is_stmt 1 discriminator 3 view .LVU96
 418              		.loc 1 314 33 is_stmt 0 discriminator 3 view .LVU97
 419 0082 1D49     		ldr	r1, .L46+12
 420 0084 C95C     		ldrb	r1, [r1, r3]	@ zero_extendqisi2
 421              		.loc 1 314 18 discriminator 3 view .LVU98
 422 0086 0A44     		add	r2, r2, r1
 423              	.LVL31:
 424              		.loc 1 314 18 discriminator 3 view .LVU99
 425 0088 92B2     		uxth	r2, r2
 426              	.LVL32:
 313:Src/control.c ****         checksum += nunchuk_data[i];
 427              		.loc 1 313 23 is_stmt 1 discriminator 3 view .LVU100
 313:Src/control.c ****         checksum += nunchuk_data[i];
 428              		.loc 1 313 24 is_stmt 0 discriminator 3 view .LVU101
 429 008a 0133     		adds	r3, r3, #1
 430              	.LVL33:
 313:Src/control.c ****         checksum += nunchuk_data[i];
 431              		.loc 1 313 24 discriminator 3 view .LVU102
 432 008c DBB2     		uxtb	r3, r3
 433              	.LVL34:
 434              	.L38:
 313:Src/control.c ****         checksum += nunchuk_data[i];
 435              		.loc 1 313 18 is_stmt 1 discriminator 1 view .LVU103
 313:Src/control.c ****         checksum += nunchuk_data[i];
 436              		.loc 1 313 7 is_stmt 0 discriminator 1 view .LVU104
 437 008e 052B     		cmp	r3, #5
 438 0090 F7D9     		bls	.L39
 315:Src/control.c ****       }
 316:Src/control.c ****       if(checksum == 0 || checksum == 0x5FA) {
 439              		.loc 1 316 7 is_stmt 1 view .LVU105
 440              		.loc 1 316 9 is_stmt 0 view .LVU106
 441 0092 2AB3     		cbz	r2, .L43
 442              		.loc 1 316 24 discriminator 1 view .LVU107
 443 0094 40F2FA53 		movw	r3, #1530
 444              	.LVL35:
 445              		.loc 1 316 24 discriminator 1 view .LVU108
 446 0098 9A42     		cmp	r2, r3
 447 009a 24D0     		beq	.L44
 317:Src/control.c ****         success = false;
 318:Src/control.c ****       }
 319:Src/control.c **** 
 320:Src/control.c ****       /* Comms failure or timeout counter reached timeout limit */
 321:Src/control.c ****       if(success == false || timeoutCntGen > 3) {
 448              		.loc 1 321 7 is_stmt 1 view .LVU109
 449              		.loc 1 321 9 is_stmt 0 view .LVU110
 450 009c 0CB3     		cbz	r4, .L40
 451              		.loc 1 321 44 discriminator 1 view .LVU111
 452 009e 174B     		ldr	r3, .L46+16
 453 00a0 1B68     		ldr	r3, [r3]
 454              		.loc 1 321 27 discriminator 1 view .LVU112
 455 00a2 032B     		cmp	r3, #3
 456 00a4 1DD8     		bhi	.L40
 457 00a6 11E0     		b	.L33
ARM GAS  /tmp/cczfimbn.s 			page 15


 458              	.LVL36:
 459              	.L42:
 322:Src/control.c ****         /* Clear the receive data buffer */
 323:Src/control.c ****         for(i = 0; i<6; i++) {
 324:Src/control.c ****           nunchuk_data[i] = 0;
 460              		.loc 1 324 11 is_stmt 1 discriminator 3 view .LVU113
 461              		.loc 1 324 27 is_stmt 0 discriminator 3 view .LVU114
 462 00a8 134A     		ldr	r2, .L46+12
 463 00aa 0021     		movs	r1, #0
 464 00ac D154     		strb	r1, [r2, r3]
 323:Src/control.c ****           nunchuk_data[i] = 0;
 465              		.loc 1 323 25 is_stmt 1 discriminator 3 view .LVU115
 323:Src/control.c ****           nunchuk_data[i] = 0;
 466              		.loc 1 323 26 is_stmt 0 discriminator 3 view .LVU116
 467 00ae 0133     		adds	r3, r3, #1
 468              	.LVL37:
 323:Src/control.c ****           nunchuk_data[i] = 0;
 469              		.loc 1 323 26 discriminator 3 view .LVU117
 470 00b0 DBB2     		uxtb	r3, r3
 471              	.LVL38:
 472              	.L41:
 323:Src/control.c ****           nunchuk_data[i] = 0;
 473              		.loc 1 323 20 is_stmt 1 discriminator 1 view .LVU118
 323:Src/control.c ****           nunchuk_data[i] = 0;
 474              		.loc 1 323 9 is_stmt 0 discriminator 1 view .LVU119
 475 00b2 052B     		cmp	r3, #5
 476 00b4 F8D9     		bls	.L42
 325:Src/control.c ****         }
 326:Src/control.c ****         /* Brings motors to safe stop */
 327:Src/control.c ****         /* Expected values from nunchuk for stopped (mid) position */
 328:Src/control.c ****         nunchuk_data[0] = 127;
 477              		.loc 1 328 9 is_stmt 1 view .LVU120
 478              		.loc 1 328 25 is_stmt 0 view .LVU121
 479 00b6 104B     		ldr	r3, .L46+12
 480              	.LVL39:
 481              		.loc 1 328 25 view .LVU122
 482 00b8 7F22     		movs	r2, #127
 483 00ba 1A70     		strb	r2, [r3]
 329:Src/control.c ****         nunchuk_data[1] = 128;
 484              		.loc 1 329 9 is_stmt 1 view .LVU123
 485              		.loc 1 329 25 is_stmt 0 view .LVU124
 486 00bc 8022     		movs	r2, #128
 487 00be 5A70     		strb	r2, [r3, #1]
 330:Src/control.c ****         timeoutFlgGen = 1;
 488              		.loc 1 330 9 is_stmt 1 view .LVU125
 489              		.loc 1 330 23 is_stmt 0 view .LVU126
 490 00c0 0F4B     		ldr	r3, .L46+20
 491 00c2 0122     		movs	r2, #1
 492 00c4 1A70     		strb	r2, [r3]
 331:Src/control.c ****         nunchukState = NUNCHUK_RECONNECTING;
 493              		.loc 1 331 9 is_stmt 1 view .LVU127
 494              		.loc 1 331 22 is_stmt 0 view .LVU128
 495 00c6 094B     		ldr	r3, .L46
 496 00c8 0222     		movs	r2, #2
 497 00ca 1A70     		strb	r2, [r3]
 498              	.L33:
 499              	.LVL40:
ARM GAS  /tmp/cczfimbn.s 			page 16


 332:Src/control.c ****       }
 333:Src/control.c ****       break;
 334:Src/control.c ****   }
 335:Src/control.c ****   /* Reset the timeout flag and counter if successful communication */
 336:Src/control.c ****   if(success == true) {
 500              		.loc 1 336 3 is_stmt 1 view .LVU129
 501              		.loc 1 336 5 is_stmt 0 view .LVU130
 502 00cc 012C     		cmp	r4, #1
 503 00ce 04D1     		bne	.L32
 504              	.LVL41:
 505              	.L27:
 337:Src/control.c ****     timeoutCntGen = 0;
 506              		.loc 1 337 5 is_stmt 1 view .LVU131
 507              		.loc 1 337 19 is_stmt 0 view .LVU132
 508 00d0 0023     		movs	r3, #0
 509 00d2 0A4A     		ldr	r2, .L46+16
 510 00d4 1360     		str	r3, [r2]
 338:Src/control.c ****     timeoutFlgGen = 0;
 511              		.loc 1 338 5 is_stmt 1 view .LVU133
 512              		.loc 1 338 19 is_stmt 0 view .LVU134
 513 00d6 0A4A     		ldr	r2, .L46+20
 514 00d8 1370     		strb	r3, [r2]
 515              	.L32:
 339:Src/control.c ****   }
 340:Src/control.c ****   return nunchukState;
 516              		.loc 1 340 3 is_stmt 1 view .LVU135
 341:Src/control.c ****   //setScopeChannel(0, (int)nunchuk_data[0]);
 342:Src/control.c ****   //setScopeChannel(1, (int)nunchuk_data[1]);
 343:Src/control.c ****   //setScopeChannel(2, (int)nunchuk_data[5] & 1);
 344:Src/control.c ****   //setScopeChannel(3, ((int)nunchuk_data[5] >> 1) & 1);
 345:Src/control.c **** }
 517              		.loc 1 345 1 is_stmt 0 view .LVU136
 518 00da 044B     		ldr	r3, .L46
 519 00dc 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 520 00de 38BD     		pop	{r3, r4, r5, pc}
 521              	.LVL42:
 522              	.L43:
 317:Src/control.c ****       }
 523              		.loc 1 317 17 view .LVU137
 524 00e0 0024     		movs	r4, #0
 525              	.LVL43:
 526              	.L40:
 317:Src/control.c ****       }
 527              		.loc 1 317 17 discriminator 1 view .LVU138
 528 00e2 0023     		movs	r3, #0
 529 00e4 E5E7     		b	.L41
 530              	.LVL44:
 531              	.L44:
 317:Src/control.c ****       }
 532              		.loc 1 317 17 view .LVU139
 533 00e6 0024     		movs	r4, #0
 534              	.LVL45:
 317:Src/control.c ****       }
 535              		.loc 1 317 17 view .LVU140
 536 00e8 FBE7     		b	.L40
 537              	.L47:
 538 00ea 00BF     		.align	2
ARM GAS  /tmp/cczfimbn.s 			page 17


 539              	.L46:
 540 00ec 00000000 		.word	.LANCHOR1
 541 00f0 00000000 		.word	.LANCHOR2
 542 00f4 00000000 		.word	.LANCHOR0
 543 00f8 00000000 		.word	.LANCHOR3
 544 00fc 00000000 		.word	.LANCHOR4
 545 0100 00000000 		.word	.LANCHOR5
 546              		.cfi_endproc
 547              	.LFE70:
 549              		.global	nunchukState
 550              		.global	i2cBuffer
 551              		.global	nunchuk_data
 552              		.global	timeoutFlgGen
 553              		.global	timeoutCntGen
 554              		.global	pwm_count
 555              		.global	ppm_count
 556              		.global	TimHandle2
 557              		.global	TimHandle
 558              		.section	.bss.TimHandle,"aw",%nobits
 559              		.align	2
 562              	TimHandle:
 563 0000 00000000 		.space	64
 563      00000000 
 563      00000000 
 563      00000000 
 563      00000000 
 564              		.section	.bss.TimHandle2,"aw",%nobits
 565              		.align	2
 568              	TimHandle2:
 569 0000 00000000 		.space	64
 569      00000000 
 569      00000000 
 569      00000000 
 569      00000000 
 570              		.section	.bss.delay_counter.0,"aw",%nobits
 571              		.set	.LANCHOR2,. + 0
 574              	delay_counter.0:
 575 0000 00       		.space	1
 576              		.section	.bss.i2cBuffer,"aw",%nobits
 577              		.align	2
 578              		.set	.LANCHOR0,. + 0
 581              	i2cBuffer:
 582 0000 0000     		.space	2
 583              		.section	.bss.nunchukState,"aw",%nobits
 584              		.set	.LANCHOR1,. + 0
 587              	nunchukState:
 588 0000 00       		.space	1
 589              		.section	.bss.nunchuk_data,"aw",%nobits
 590              		.align	2
 591              		.set	.LANCHOR3,. + 0
 594              	nunchuk_data:
 595 0000 00000000 		.space	6
 595      0000
 596              		.section	.bss.ppm_count,"aw",%nobits
 599              	ppm_count:
 600 0000 00       		.space	1
 601              		.section	.bss.pwm_count,"aw",%nobits
ARM GAS  /tmp/cczfimbn.s 			page 18


 604              	pwm_count:
 605 0000 00       		.space	1
 606              		.section	.bss.timeoutFlgGen,"aw",%nobits
 607              		.set	.LANCHOR5,. + 0
 610              	timeoutFlgGen:
 611 0000 00       		.space	1
 612              		.section	.data.timeoutCntGen,"aw"
 613              		.align	2
 614              		.set	.LANCHOR4,. + 0
 617              	timeoutCntGen:
 618 0000 14000000 		.word	20
 619              		.text
 620              	.Letext0:
 621              		.file 2 "/usr/lib/gcc/arm-none-eabi/10.3.1/include/stdint.h"
 622              		.file 3 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 623              		.file 4 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 624              		.file 5 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 625              		.file 6 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_i2c.h"
 626              		.file 7 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_tim.h"
 627              		.file 8 "Inc/defines.h"
 628              		.file 9 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
ARM GAS  /tmp/cczfimbn.s 			page 19


DEFINED SYMBOLS
                            *ABS*:0000000000000000 control.c
     /tmp/cczfimbn.s:16     .text.Nunchuk_tx:0000000000000000 $t
     /tmp/cczfimbn.s:24     .text.Nunchuk_tx:0000000000000000 Nunchuk_tx
     /tmp/cczfimbn.s:75     .text.Nunchuk_tx:0000000000000024 $d
     /tmp/cczfimbn.s:80     .text.Nunchuk_rx:0000000000000000 $t
     /tmp/cczfimbn.s:87     .text.Nunchuk_rx:0000000000000000 Nunchuk_rx
     /tmp/cczfimbn.s:137    .text.Nunchuk_rx:0000000000000024 $d
     /tmp/cczfimbn.s:142    .text.Nunchuk_Init:0000000000000000 $t
     /tmp/cczfimbn.s:149    .text.Nunchuk_Init:0000000000000000 Nunchuk_Init
     /tmp/cczfimbn.s:212    .text.Nunchuk_Init:000000000000003c $d
     /tmp/cczfimbn.s:217    .text.Nunchuk_Connect:0000000000000000 $t
     /tmp/cczfimbn.s:224    .text.Nunchuk_Connect:0000000000000000 Nunchuk_Connect
     /tmp/cczfimbn.s:262    .text.Nunchuk_Connect:000000000000001c $d
     /tmp/cczfimbn.s:267    .text.Nunchuk_Read:0000000000000000 $t
     /tmp/cczfimbn.s:274    .text.Nunchuk_Read:0000000000000000 Nunchuk_Read
     /tmp/cczfimbn.s:299    .text.Nunchuk_Read:000000000000000e $d
     /tmp/cczfimbn.s:303    .text.Nunchuk_Read:0000000000000012 $t
     /tmp/cczfimbn.s:540    .text.Nunchuk_Read:00000000000000ec $d
     /tmp/cczfimbn.s:587    .bss.nunchukState:0000000000000000 nunchukState
     /tmp/cczfimbn.s:581    .bss.i2cBuffer:0000000000000000 i2cBuffer
     /tmp/cczfimbn.s:594    .bss.nunchuk_data:0000000000000000 nunchuk_data
     /tmp/cczfimbn.s:610    .bss.timeoutFlgGen:0000000000000000 timeoutFlgGen
     /tmp/cczfimbn.s:617    .data.timeoutCntGen:0000000000000000 timeoutCntGen
     /tmp/cczfimbn.s:604    .bss.pwm_count:0000000000000000 pwm_count
     /tmp/cczfimbn.s:599    .bss.ppm_count:0000000000000000 ppm_count
     /tmp/cczfimbn.s:568    .bss.TimHandle2:0000000000000000 TimHandle2
     /tmp/cczfimbn.s:562    .bss.TimHandle:0000000000000000 TimHandle
     /tmp/cczfimbn.s:559    .bss.TimHandle:0000000000000000 $d
     /tmp/cczfimbn.s:565    .bss.TimHandle2:0000000000000000 $d
     /tmp/cczfimbn.s:574    .bss.delay_counter.0:0000000000000000 delay_counter.0
     /tmp/cczfimbn.s:575    .bss.delay_counter.0:0000000000000000 $d
     /tmp/cczfimbn.s:577    .bss.i2cBuffer:0000000000000000 $d
     /tmp/cczfimbn.s:588    .bss.nunchukState:0000000000000000 $d
     /tmp/cczfimbn.s:590    .bss.nunchuk_data:0000000000000000 $d
     /tmp/cczfimbn.s:600    .bss.ppm_count:0000000000000000 $d
     /tmp/cczfimbn.s:605    .bss.pwm_count:0000000000000000 $d
     /tmp/cczfimbn.s:611    .bss.timeoutFlgGen:0000000000000000 $d
     /tmp/cczfimbn.s:613    .data.timeoutCntGen:0000000000000000 $d

UNDEFINED SYMBOLS
HAL_I2C_Master_Transmit
hi2c2
HAL_I2C_Master_Receive
HAL_Delay
I2C_Init
